/* concurrentset.c generated by valac 0.20.1.1-1480, the Vala compiler
 * generated from concurrentset.vala, do not modify */

/* concurrentset.vala
 *
 * Copyright (C) 2012  Maciej Piechotka
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Maciej Piechotka <uzytkownik2@gmail.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <string.h>
#include <gobject/gvaluecollector.h>


#define GEE_TYPE_TRAVERSABLE (gee_traversable_get_type ())
#define GEE_TRAVERSABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_TRAVERSABLE, GeeTraversable))
#define GEE_IS_TRAVERSABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_TRAVERSABLE))
#define GEE_TRAVERSABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_TRAVERSABLE, GeeTraversableIface))

typedef struct _GeeTraversable GeeTraversable;
typedef struct _GeeTraversableIface GeeTraversableIface;

#define GEE_TRAVERSABLE_TYPE_STREAM (gee_traversable_stream_get_type ())

#define GEE_TYPE_LAZY (gee_lazy_get_type ())
#define GEE_LAZY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_LAZY, GeeLazy))
#define GEE_LAZY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_LAZY, GeeLazyClass))
#define GEE_IS_LAZY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_LAZY))
#define GEE_IS_LAZY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_LAZY))
#define GEE_LAZY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_LAZY, GeeLazyClass))

typedef struct _GeeLazy GeeLazy;
typedef struct _GeeLazyClass GeeLazyClass;

#define GEE_TYPE_ITERATOR (gee_iterator_get_type ())
#define GEE_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_ITERATOR, GeeIterator))
#define GEE_IS_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_ITERATOR))
#define GEE_ITERATOR_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_ITERATOR, GeeIteratorIface))

typedef struct _GeeIterator GeeIterator;
typedef struct _GeeIteratorIface GeeIteratorIface;

#define GEE_TYPE_ITERABLE (gee_iterable_get_type ())
#define GEE_ITERABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_ITERABLE, GeeIterable))
#define GEE_IS_ITERABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_ITERABLE))
#define GEE_ITERABLE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_ITERABLE, GeeIterableIface))

typedef struct _GeeIterable GeeIterable;
typedef struct _GeeIterableIface GeeIterableIface;

#define GEE_TYPE_COLLECTION (gee_collection_get_type ())
#define GEE_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_COLLECTION, GeeCollection))
#define GEE_IS_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_COLLECTION))
#define GEE_COLLECTION_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_COLLECTION, GeeCollectionIface))

typedef struct _GeeCollection GeeCollection;
typedef struct _GeeCollectionIface GeeCollectionIface;

#define GEE_TYPE_ABSTRACT_COLLECTION (gee_abstract_collection_get_type ())
#define GEE_ABSTRACT_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_ABSTRACT_COLLECTION, GeeAbstractCollection))
#define GEE_ABSTRACT_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_ABSTRACT_COLLECTION, GeeAbstractCollectionClass))
#define GEE_IS_ABSTRACT_COLLECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_ABSTRACT_COLLECTION))
#define GEE_IS_ABSTRACT_COLLECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_ABSTRACT_COLLECTION))
#define GEE_ABSTRACT_COLLECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_ABSTRACT_COLLECTION, GeeAbstractCollectionClass))

typedef struct _GeeAbstractCollection GeeAbstractCollection;
typedef struct _GeeAbstractCollectionClass GeeAbstractCollectionClass;
typedef struct _GeeAbstractCollectionPrivate GeeAbstractCollectionPrivate;

#define GEE_TYPE_SET (gee_set_get_type ())
#define GEE_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_SET, GeeSet))
#define GEE_IS_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_SET))
#define GEE_SET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_SET, GeeSetIface))

typedef struct _GeeSet GeeSet;
typedef struct _GeeSetIface GeeSetIface;

#define GEE_TYPE_ABSTRACT_SET (gee_abstract_set_get_type ())
#define GEE_ABSTRACT_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_ABSTRACT_SET, GeeAbstractSet))
#define GEE_ABSTRACT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_ABSTRACT_SET, GeeAbstractSetClass))
#define GEE_IS_ABSTRACT_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_ABSTRACT_SET))
#define GEE_IS_ABSTRACT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_ABSTRACT_SET))
#define GEE_ABSTRACT_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_ABSTRACT_SET, GeeAbstractSetClass))

typedef struct _GeeAbstractSet GeeAbstractSet;
typedef struct _GeeAbstractSetClass GeeAbstractSetClass;
typedef struct _GeeAbstractSetPrivate GeeAbstractSetPrivate;

#define GEE_TYPE_SORTED_SET (gee_sorted_set_get_type ())
#define GEE_SORTED_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_SORTED_SET, GeeSortedSet))
#define GEE_IS_SORTED_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_SORTED_SET))
#define GEE_SORTED_SET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GEE_TYPE_SORTED_SET, GeeSortedSetIface))

typedef struct _GeeSortedSet GeeSortedSet;
typedef struct _GeeSortedSetIface GeeSortedSetIface;

#define GEE_TYPE_ABSTRACT_SORTED_SET (gee_abstract_sorted_set_get_type ())
#define GEE_ABSTRACT_SORTED_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_ABSTRACT_SORTED_SET, GeeAbstractSortedSet))
#define GEE_ABSTRACT_SORTED_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_ABSTRACT_SORTED_SET, GeeAbstractSortedSetClass))
#define GEE_IS_ABSTRACT_SORTED_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_ABSTRACT_SORTED_SET))
#define GEE_IS_ABSTRACT_SORTED_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_ABSTRACT_SORTED_SET))
#define GEE_ABSTRACT_SORTED_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_ABSTRACT_SORTED_SET, GeeAbstractSortedSetClass))

typedef struct _GeeAbstractSortedSet GeeAbstractSortedSet;
typedef struct _GeeAbstractSortedSetClass GeeAbstractSortedSetClass;
typedef struct _GeeAbstractSortedSetPrivate GeeAbstractSortedSetPrivate;

#define GEE_TYPE_CONCURRENT_SET (gee_concurrent_set_get_type ())
#define GEE_CONCURRENT_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_CONCURRENT_SET, GeeConcurrentSet))
#define GEE_CONCURRENT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_CONCURRENT_SET, GeeConcurrentSetClass))
#define GEE_IS_CONCURRENT_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_CONCURRENT_SET))
#define GEE_IS_CONCURRENT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_CONCURRENT_SET))
#define GEE_CONCURRENT_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_CONCURRENT_SET, GeeConcurrentSetClass))

typedef struct _GeeConcurrentSet GeeConcurrentSet;
typedef struct _GeeConcurrentSetClass GeeConcurrentSetClass;
typedef struct _GeeConcurrentSetPrivate GeeConcurrentSetPrivate;

#define GEE_CONCURRENT_SET_TYPE_TOWER (gee_concurrent_set_tower_get_type ())
#define GEE_CONCURRENT_SET_TOWER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_CONCURRENT_SET_TYPE_TOWER, GeeConcurrentSetTower))
#define GEE_CONCURRENT_SET_TOWER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_CONCURRENT_SET_TYPE_TOWER, GeeConcurrentSetTowerClass))
#define GEE_CONCURRENT_SET_IS_TOWER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_CONCURRENT_SET_TYPE_TOWER))
#define GEE_CONCURRENT_SET_IS_TOWER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_CONCURRENT_SET_TYPE_TOWER))
#define GEE_CONCURRENT_SET_TOWER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_CONCURRENT_SET_TYPE_TOWER, GeeConcurrentSetTowerClass))

typedef struct _GeeConcurrentSetTower GeeConcurrentSetTower;
typedef struct _GeeConcurrentSetTowerClass GeeConcurrentSetTowerClass;

#define GEE_HAZARD_POINTER_TYPE_POLICY (gee_hazard_pointer_policy_get_type ())
typedef struct _GeeHazardPointerContext GeeHazardPointerContext;
#define _gee_concurrent_set_tower_unref0(var) ((var == NULL) ? NULL : (var = (gee_concurrent_set_tower_unref (var), NULL)))
#define _gee_hazard_pointer_context_free0(var) ((var == NULL) ? NULL : (var = (gee_hazard_pointer_context_free (var), NULL)))

#define GEE_CONCURRENT_SET_TYPE_RANGE_TYPE (gee_concurrent_set_range_type_get_type ())

#define GEE_CONCURRENT_SET_TYPE_STATE (gee_concurrent_set_state_get_type ())

#define GEE_CONCURRENT_SET_TYPE_ITERATOR (gee_concurrent_set_iterator_get_type ())
#define GEE_CONCURRENT_SET_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIterator))
#define GEE_CONCURRENT_SET_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIteratorClass))
#define GEE_CONCURRENT_SET_IS_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_CONCURRENT_SET_TYPE_ITERATOR))
#define GEE_CONCURRENT_SET_IS_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_CONCURRENT_SET_TYPE_ITERATOR))
#define GEE_CONCURRENT_SET_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIteratorClass))

typedef struct _GeeConcurrentSetIterator GeeConcurrentSetIterator;
typedef struct _GeeConcurrentSetIteratorClass GeeConcurrentSetIteratorClass;

#define GEE_CONCURRENT_SET_TYPE_TOWER_ITER (gee_concurrent_set_tower_iter_get_type ())
typedef struct _GeeConcurrentSetTowerIter GeeConcurrentSetTowerIter;
typedef struct _GeeConcurrentSetTowerPrivate GeeConcurrentSetTowerPrivate;

#define GEE_CONCURRENT_SET_TYPE_TOWER_NODE (gee_concurrent_set_tower_node_get_type ())
typedef struct _GeeConcurrentSetTowerNode GeeConcurrentSetTowerNode;

#define GEE_CONCURRENT_SET_TYPE_RANGE (gee_concurrent_set_range_get_type ())
#define GEE_CONCURRENT_SET_RANGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_CONCURRENT_SET_TYPE_RANGE, GeeConcurrentSetRange))
#define GEE_CONCURRENT_SET_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_CONCURRENT_SET_TYPE_RANGE, GeeConcurrentSetRangeClass))
#define GEE_CONCURRENT_SET_IS_RANGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_CONCURRENT_SET_TYPE_RANGE))
#define GEE_CONCURRENT_SET_IS_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_CONCURRENT_SET_TYPE_RANGE))
#define GEE_CONCURRENT_SET_RANGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_CONCURRENT_SET_TYPE_RANGE, GeeConcurrentSetRangeClass))

typedef struct _GeeConcurrentSetRange GeeConcurrentSetRange;
typedef struct _GeeConcurrentSetRangeClass GeeConcurrentSetRangeClass;

#define GEE_CONCURRENT_SET_TYPE_SUB_SET (gee_concurrent_set_sub_set_get_type ())
#define GEE_CONCURRENT_SET_SUB_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSet))
#define GEE_CONCURRENT_SET_SUB_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSetClass))
#define GEE_CONCURRENT_SET_IS_SUB_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_CONCURRENT_SET_TYPE_SUB_SET))
#define GEE_CONCURRENT_SET_IS_SUB_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_CONCURRENT_SET_TYPE_SUB_SET))
#define GEE_CONCURRENT_SET_SUB_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSetClass))

typedef struct _GeeConcurrentSetSubSet GeeConcurrentSetSubSet;
typedef struct _GeeConcurrentSetSubSetClass GeeConcurrentSetSubSetClass;
#define _gee_concurrent_set_range_unref0(var) ((var == NULL) ? NULL : (var = (gee_concurrent_set_range_unref (var), NULL)))
typedef struct _GeeConcurrentSetIteratorPrivate GeeConcurrentSetIteratorPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _GeeConcurrentSetSubSetPrivate GeeConcurrentSetSubSetPrivate;

#define GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR (gee_concurrent_set_sub_iterator_get_type ())
#define GEE_CONCURRENT_SET_SUB_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIterator))
#define GEE_CONCURRENT_SET_SUB_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIteratorClass))
#define GEE_CONCURRENT_SET_IS_SUB_ITERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR))
#define GEE_CONCURRENT_SET_IS_SUB_ITERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR))
#define GEE_CONCURRENT_SET_SUB_ITERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIteratorClass))

typedef struct _GeeConcurrentSetSubIterator GeeConcurrentSetSubIterator;
typedef struct _GeeConcurrentSetSubIteratorClass GeeConcurrentSetSubIteratorClass;
typedef struct _GeeConcurrentSetRangePrivate GeeConcurrentSetRangePrivate;

#define GEE_CONCURRENT_SET_RANGE_TYPE_POSITION (gee_concurrent_set_range_position_get_type ())
typedef struct _GeeConcurrentSetSubIteratorPrivate GeeConcurrentSetSubIteratorPrivate;
#define _g_destroy_func0(var) (((var == NULL) || (g_destroy_func == NULL)) ? NULL : (var = (g_destroy_func (var), NULL)))
typedef struct _GeeConcurrentSetParamSpecRange GeeConcurrentSetParamSpecRange;
typedef struct _GeeConcurrentSetParamSpecTower GeeConcurrentSetParamSpecTower;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

typedef gboolean (*GeeForallFunc) (gpointer g, void* user_data);
typedef enum  {
	GEE_TRAVERSABLE_STREAM_YIELD,
	GEE_TRAVERSABLE_STREAM_CONTINUE,
	GEE_TRAVERSABLE_STREAM_END
} GeeTraversableStream;

typedef GeeTraversableStream (*GeeStreamFunc) (GeeTraversableStream state, GeeLazy* g, GeeLazy** lazy, void* user_data);
struct _GeeIteratorIface {
	GTypeInterface parent_iface;
	gboolean (*next) (GeeIterator* self);
	gboolean (*has_next) (GeeIterator* self);
	gpointer (*get) (GeeIterator* self);
	void (*remove) (GeeIterator* self);
	gboolean (*get_valid) (GeeIterator* self);
	gboolean (*get_read_only) (GeeIterator* self);
};

typedef gpointer (*GeeFoldFunc) (gpointer g, gpointer a, void* user_data);
typedef gpointer (*GeeMapFunc) (gpointer g, void* user_data);
typedef gboolean (*GeePredicate) (gconstpointer g, void* user_data);
struct _GeeTraversableIface {
	GTypeInterface parent_iface;
	GType (*get_g_type) (GeeTraversable* self);
	GBoxedCopyFunc (*get_g_dup_func) (GeeTraversable* self);
	GDestroyNotify (*get_g_destroy_func) (GeeTraversable* self);
	gboolean (*foreach) (GeeTraversable* self, GeeForallFunc f, void* f_target);
	GeeIterator* (*stream) (GeeTraversable* self, GType a_type, GBoxedCopyFunc a_dup_func, GDestroyNotify a_destroy_func, GeeStreamFunc f, void* f_target, GDestroyNotify f_target_destroy_notify);
	gpointer (*fold) (GeeTraversable* self, GType a_type, GBoxedCopyFunc a_dup_func, GDestroyNotify a_destroy_func, GeeFoldFunc f, void* f_target, gpointer seed);
	GeeIterator* (*map) (GeeTraversable* self, GType a_type, GBoxedCopyFunc a_dup_func, GDestroyNotify a_destroy_func, GeeMapFunc f, void* f_target);
	GeeIterator* (*scan) (GeeTraversable* self, GType a_type, GBoxedCopyFunc a_dup_func, GDestroyNotify a_destroy_func, GeeFoldFunc f, void* f_target, gpointer seed);
	GeeIterator* (*filter) (GeeTraversable* self, GeePredicate pred, void* pred_target, GDestroyNotify pred_target_destroy_notify);
	GeeIterator* (*chop) (GeeTraversable* self, gint offset, gint length);
	GType (*get_element_type) (GeeTraversable* self);
};

struct _GeeIterableIface {
	GTypeInterface parent_iface;
	GType (*get_g_type) (GeeIterable* self);
	GBoxedCopyFunc (*get_g_dup_func) (GeeIterable* self);
	GDestroyNotify (*get_g_destroy_func) (GeeIterable* self);
	GeeIterator* (*iterator) (GeeIterable* self);
};

struct _GeeCollectionIface {
	GTypeInterface parent_iface;
	GType (*get_g_type) (GeeCollection* self);
	GBoxedCopyFunc (*get_g_dup_func) (GeeCollection* self);
	GDestroyNotify (*get_g_destroy_func) (GeeCollection* self);
	gboolean (*contains) (GeeCollection* self, gconstpointer item);
	gboolean (*add) (GeeCollection* self, gconstpointer item);
	gboolean (*remove) (GeeCollection* self, gconstpointer item);
	void (*clear) (GeeCollection* self);
	gboolean (*add_all) (GeeCollection* self, GeeCollection* collection);
	gboolean (*contains_all) (GeeCollection* self, GeeCollection* collection);
	gboolean (*remove_all) (GeeCollection* self, GeeCollection* collection);
	gboolean (*retain_all) (GeeCollection* self, GeeCollection* collection);
	gpointer* (*to_array) (GeeCollection* self, int* result_length1);
	gint (*get_size) (GeeCollection* self);
	gboolean (*get_is_empty) (GeeCollection* self);
	gboolean (*get_read_only) (GeeCollection* self);
	GeeCollection* (*get_read_only_view) (GeeCollection* self);
};

struct _GeeAbstractCollection {
	GObject parent_instance;
	GeeAbstractCollectionPrivate * priv;
};

struct _GeeAbstractCollectionClass {
	GObjectClass parent_class;
	gboolean (*contains) (GeeAbstractCollection* self, gconstpointer item);
	gboolean (*add) (GeeAbstractCollection* self, gconstpointer item);
	gboolean (*remove) (GeeAbstractCollection* self, gconstpointer item);
	void (*clear) (GeeAbstractCollection* self);
	GeeIterator* (*iterator) (GeeAbstractCollection* self);
	gboolean (*foreach) (GeeAbstractCollection* self, GeeForallFunc f, void* f_target);
	void (*reserved0) (GeeAbstractCollection* self);
	void (*reserved1) (GeeAbstractCollection* self);
	void (*reserved2) (GeeAbstractCollection* self);
	void (*reserved3) (GeeAbstractCollection* self);
	void (*reserved4) (GeeAbstractCollection* self);
	void (*reserved5) (GeeAbstractCollection* self);
	void (*reserved6) (GeeAbstractCollection* self);
	void (*reserved7) (GeeAbstractCollection* self);
	void (*reserved8) (GeeAbstractCollection* self);
	void (*reserved9) (GeeAbstractCollection* self);
	gint (*get_size) (GeeAbstractCollection* self);
	gboolean (*get_read_only) (GeeAbstractCollection* self);
	GeeCollection* (*get_read_only_view) (GeeAbstractCollection* self);
};

struct _GeeSetIface {
	GTypeInterface parent_iface;
	GType (*get_g_type) (GeeSet* self);
	GBoxedCopyFunc (*get_g_dup_func) (GeeSet* self);
	GDestroyNotify (*get_g_destroy_func) (GeeSet* self);
	GeeSet* (*get_read_only_view) (GeeSet* self);
};

struct _GeeAbstractSet {
	GeeAbstractCollection parent_instance;
	GeeAbstractSetPrivate * priv;
};

struct _GeeAbstractSetClass {
	GeeAbstractCollectionClass parent_class;
	void (*reserved0) (GeeAbstractSet* self);
	void (*reserved1) (GeeAbstractSet* self);
	void (*reserved2) (GeeAbstractSet* self);
	void (*reserved3) (GeeAbstractSet* self);
	void (*reserved4) (GeeAbstractSet* self);
	void (*reserved5) (GeeAbstractSet* self);
	void (*reserved6) (GeeAbstractSet* self);
	void (*reserved7) (GeeAbstractSet* self);
	void (*reserved8) (GeeAbstractSet* self);
	void (*reserved9) (GeeAbstractSet* self);
	GeeSet* (*get_read_only_view) (GeeAbstractSet* self);
};

struct _GeeSortedSetIface {
	GTypeInterface parent_iface;
	GType (*get_g_type) (GeeSortedSet* self);
	GBoxedCopyFunc (*get_g_dup_func) (GeeSortedSet* self);
	GDestroyNotify (*get_g_destroy_func) (GeeSortedSet* self);
	gpointer (*first) (GeeSortedSet* self);
	gpointer (*last) (GeeSortedSet* self);
	GeeIterator* (*iterator_at) (GeeSortedSet* self, gconstpointer element);
	gpointer (*lower) (GeeSortedSet* self, gconstpointer element);
	gpointer (*higher) (GeeSortedSet* self, gconstpointer element);
	gpointer (*floor) (GeeSortedSet* self, gconstpointer element);
	gpointer (*ceil) (GeeSortedSet* self, gconstpointer element);
	GeeSortedSet* (*head_set) (GeeSortedSet* self, gconstpointer before);
	GeeSortedSet* (*tail_set) (GeeSortedSet* self, gconstpointer after);
	GeeSortedSet* (*sub_set) (GeeSortedSet* self, gconstpointer from, gconstpointer to);
	GeeSortedSet* (*get_read_only_view) (GeeSortedSet* self);
};

struct _GeeAbstractSortedSet {
	GeeAbstractSet parent_instance;
	GeeAbstractSortedSetPrivate * priv;
};

struct _GeeAbstractSortedSetClass {
	GeeAbstractSetClass parent_class;
	gpointer (*first) (GeeAbstractSortedSet* self);
	gpointer (*last) (GeeAbstractSortedSet* self);
	GeeIterator* (*iterator_at) (GeeAbstractSortedSet* self, gconstpointer element);
	gpointer (*lower) (GeeAbstractSortedSet* self, gconstpointer element);
	gpointer (*higher) (GeeAbstractSortedSet* self, gconstpointer element);
	gpointer (*floor) (GeeAbstractSortedSet* self, gconstpointer element);
	gpointer (*ceil) (GeeAbstractSortedSet* self, gconstpointer element);
	GeeSortedSet* (*head_set) (GeeAbstractSortedSet* self, gconstpointer before);
	GeeSortedSet* (*tail_set) (GeeAbstractSortedSet* self, gconstpointer after);
	GeeSortedSet* (*sub_set) (GeeAbstractSortedSet* self, gconstpointer from, gconstpointer to);
	void (*reserved0) (GeeAbstractSortedSet* self);
	void (*reserved1) (GeeAbstractSortedSet* self);
	void (*reserved2) (GeeAbstractSortedSet* self);
	void (*reserved3) (GeeAbstractSortedSet* self);
	void (*reserved4) (GeeAbstractSortedSet* self);
	void (*reserved5) (GeeAbstractSortedSet* self);
	void (*reserved6) (GeeAbstractSortedSet* self);
	void (*reserved7) (GeeAbstractSortedSet* self);
	void (*reserved8) (GeeAbstractSortedSet* self);
	void (*reserved9) (GeeAbstractSortedSet* self);
	GeeSortedSet* (*get_read_only_view) (GeeAbstractSortedSet* self);
};

struct _GeeConcurrentSet {
	GeeAbstractSortedSet parent_instance;
	GeeConcurrentSetPrivate * priv;
};

struct _GeeConcurrentSetClass {
	GeeAbstractSortedSetClass parent_class;
};

struct _GeeConcurrentSetPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	gint _size;
	GeeConcurrentSetTower* _head;
	GCompareDataFunc _cmp;
	gpointer _cmp_target;
	GDestroyNotify _cmp_target_destroy_notify;
};

typedef enum  {
	GEE_HAZARD_POINTER_POLICY_DEFAULT,
	GEE_HAZARD_POINTER_POLICY_THREAD_EXIT,
	GEE_HAZARD_POINTER_POLICY_TRY_FREE,
	GEE_HAZARD_POINTER_POLICY_FREE,
	GEE_HAZARD_POINTER_POLICY_TRY_RELEASE,
	GEE_HAZARD_POINTER_POLICY_RELEASE
} GeeHazardPointerPolicy;

typedef enum  {
	GEE_CONCURRENT_SET_RANGE_TYPE_HEAD,
	GEE_CONCURRENT_SET_RANGE_TYPE_TAIL,
	GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED,
	GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY
} GeeConcurrentSetRangeType;

typedef enum  {
	GEE_CONCURRENT_SET_STATE_NONE = 0,
	GEE_CONCURRENT_SET_STATE_MARKED = 1,
	GEE_CONCURRENT_SET_STATE_FLAGGED = 2
} GeeConcurrentSetState;

struct _GeeConcurrentSetTowerIter {
	GeeConcurrentSetTower* _iter[31];
};

struct _GeeConcurrentSetTowerNode {
	GeeConcurrentSetTower* _succ;
	GeeConcurrentSetTower* _backlink;
};

struct _GeeConcurrentSetTower {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GeeConcurrentSetTowerPrivate * priv;
	GeeConcurrentSetTowerNode* _nodes;
	gpointer _data;
	gint _height;
};

struct _GeeConcurrentSetTowerClass {
	GTypeClass parent_class;
	void (*finalize) (GeeConcurrentSetTower *self);
};

struct _GeeConcurrentSetIterator {
	GObject parent_instance;
	GeeConcurrentSetIteratorPrivate * priv;
};

struct _GeeConcurrentSetIteratorClass {
	GObjectClass parent_class;
};

struct _GeeConcurrentSetIteratorPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	gboolean _removed;
	GeeConcurrentSet* _set;
	GeeConcurrentSetTowerIter _prev;
	GeeConcurrentSetTower* _curr;
};

struct _GeeConcurrentSetSubSet {
	GeeAbstractSortedSet parent_instance;
	GeeConcurrentSetSubSetPrivate * priv;
};

struct _GeeConcurrentSetSubSetClass {
	GeeAbstractSortedSetClass parent_class;
};

struct _GeeConcurrentSetSubSetPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	GeeConcurrentSetRange* _range;
};

struct _GeeConcurrentSetRange {
	GTypeInstance parent_instance;
	volatile int ref_count;
	GeeConcurrentSetRangePrivate * priv;
	gpointer _start;
	gpointer _end;
	GeeConcurrentSetRangeType _type;
	GeeConcurrentSetTowerIter _bookmark;
	GeeConcurrentSet* _set;
};

struct _GeeConcurrentSetRangeClass {
	GTypeClass parent_class;
	void (*finalize) (GeeConcurrentSetRange *self);
};

typedef enum  {
	GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE = -1,
	GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE = 0,
	GEE_CONCURRENT_SET_RANGE_POSITION_AFTER = 1,
	GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY
} GeeConcurrentSetRangePosition;

struct _GeeConcurrentSetSubIterator {
	GObject parent_instance;
	GeeConcurrentSetSubIteratorPrivate * priv;
};

struct _GeeConcurrentSetSubIteratorClass {
	GObjectClass parent_class;
};

struct _GeeConcurrentSetSubIteratorPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	GeeConcurrentSetRange* _range;
	GeeConcurrentSetTowerIter _prev;
	GeeConcurrentSetTower* _curr;
	gboolean _removed;
};

struct _GeeConcurrentSetRangePrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
};

struct _GeeConcurrentSetParamSpecRange {
	GParamSpec parent_instance;
};

struct _GeeConcurrentSetTowerPrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
};

struct _GeeConcurrentSetParamSpecTower {
	GParamSpec parent_instance;
};


static gpointer gee_concurrent_set_parent_class = NULL;
static GPrivate* gee_concurrent_set_rand;
static GPrivate* gee_concurrent_set_rand = NULL;
static gpointer gee_concurrent_set_iterator_parent_class = NULL;
static GeeTraversableIface* gee_concurrent_set_iterator_gee_traversable_parent_iface = NULL;
static GeeIteratorIface* gee_concurrent_set_iterator_gee_iterator_parent_iface = NULL;
static gpointer gee_concurrent_set_sub_set_parent_class = NULL;
static gpointer gee_concurrent_set_sub_iterator_parent_class = NULL;
static GeeTraversableIface* gee_concurrent_set_sub_iterator_gee_traversable_parent_iface = NULL;
static GeeIteratorIface* gee_concurrent_set_sub_iterator_gee_iterator_parent_iface = NULL;
static gpointer gee_concurrent_set_range_parent_class = NULL;
static gpointer gee_concurrent_set_tower_parent_class = NULL;

GType gee_traversable_stream_get_type (void) G_GNUC_CONST;
gpointer gee_lazy_ref (gpointer instance);
void gee_lazy_unref (gpointer instance);
GParamSpec* gee_param_spec_lazy (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void gee_value_set_lazy (GValue* value, gpointer v_object);
void gee_value_take_lazy (GValue* value, gpointer v_object);
gpointer gee_value_get_lazy (const GValue* value);
GType gee_lazy_get_type (void) G_GNUC_CONST;
GType gee_iterator_get_type (void) G_GNUC_CONST;
GType gee_traversable_get_type (void) G_GNUC_CONST;
GType gee_iterable_get_type (void) G_GNUC_CONST;
GType gee_collection_get_type (void) G_GNUC_CONST;
GType gee_abstract_collection_get_type (void) G_GNUC_CONST;
GType gee_set_get_type (void) G_GNUC_CONST;
GType gee_abstract_set_get_type (void) G_GNUC_CONST;
GType gee_sorted_set_get_type (void) G_GNUC_CONST;
GType gee_abstract_sorted_set_get_type (void) G_GNUC_CONST;
GType gee_concurrent_set_get_type (void) G_GNUC_CONST;
static gpointer gee_concurrent_set_tower_ref (gpointer instance);
static void gee_concurrent_set_tower_unref (gpointer instance);
static GParamSpec* gee_concurrent_set_param_spec_tower (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void gee_concurrent_set_value_set_tower (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void gee_concurrent_set_value_take_tower (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer gee_concurrent_set_value_get_tower (const GValue* value) G_GNUC_UNUSED;
static GType gee_concurrent_set_tower_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define GEE_CONCURRENT_SET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_TYPE_CONCURRENT_SET, GeeConcurrentSetPrivate))
enum  {
	GEE_CONCURRENT_SET_DUMMY_PROPERTY,
	GEE_CONCURRENT_SET_G_TYPE,
	GEE_CONCURRENT_SET_G_DUP_FUNC,
	GEE_CONCURRENT_SET_G_DESTROY_FUNC,
	GEE_CONCURRENT_SET_SIZE,
	GEE_CONCURRENT_SET_READ_ONLY
};
GType gee_hazard_pointer_policy_get_type (void) G_GNUC_CONST;
GeeHazardPointerContext* gee_hazard_pointer_context_new (GeeHazardPointerPolicy* policy);
GeeHazardPointerContext* gee_hazard_pointer_context_new (GeeHazardPointerPolicy* policy);
void gee_hazard_pointer_context_free (GeeHazardPointerContext* self);
GType gee_concurrent_set_range_type_get_type (void) G_GNUC_CONST;
static GType gee_concurrent_set_state_get_type (void) G_GNUC_UNUSED;
static GeeConcurrentSetTower* gee_concurrent_set_tower_new_head (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func);
static GeeConcurrentSetTower* gee_concurrent_set_tower_construct_head (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func);
static void _gee_concurrent_set_rand_lambda37_ (void* ptr);
static void __gee_concurrent_set_rand_lambda37__gdestroy_notify (void* data);
#define GEE_CONCURRENT_SET__MAX_HEIGHT 31
GeeConcurrentSet* gee_concurrent_set_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc compare_func, void* compare_func_target, GDestroyNotify compare_func_target_destroy_notify);
GeeConcurrentSet* gee_concurrent_set_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc compare_func, void* compare_func_target, GDestroyNotify compare_func_target_destroy_notify);
GeeAbstractSortedSet* gee_abstract_sorted_set_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func);
GCompareDataFunc gee_functions_get_compare_func_for (GType t, void** result_target, GDestroyNotify* result_target_destroy_notify);
static GeeIterator* gee_concurrent_set_real_iterator (GeeAbstractCollection* base);
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTower* head);
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTower* head);
static GType gee_concurrent_set_iterator_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static gboolean gee_concurrent_set_real_contains (GeeAbstractCollection* base, gconstpointer key);
static inline gboolean gee_concurrent_set_tower_search (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, gconstpointer key, GeeConcurrentSetTower** prev, GeeConcurrentSetTower** next, guint8 to_level, guint8 from_level);
static gboolean gee_concurrent_set_real_add (GeeAbstractCollection* base, gconstpointer key);
static GType gee_concurrent_set_tower_iter_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GeeConcurrentSetTowerIter* gee_concurrent_set_tower_iter_dup (const GeeConcurrentSetTowerIter* self);
static void gee_concurrent_set_tower_iter_free (GeeConcurrentSetTowerIter* self);
static void gee_concurrent_set_tower_iter_copy (const GeeConcurrentSetTowerIter* self, GeeConcurrentSetTowerIter* dest);
static void gee_concurrent_set_tower_iter_destroy (GeeConcurrentSetTowerIter* self);
static inline GeeConcurrentSetTower* gee_concurrent_set_tower_insert (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, gconstpointer key, guint8 chosen_level);
static gboolean gee_concurrent_set_real_remove (GeeAbstractCollection* base, gconstpointer item);
static inline gboolean gee_concurrent_set_tower_remove_key (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, gconstpointer key, guint8 from_level);
static void gee_concurrent_set_real_clear (GeeAbstractCollection* base);
static inline GeeConcurrentSetTower* gee_concurrent_set_tower_get_next (GeeConcurrentSetTower* self, guint8 level);
gboolean gee_abstract_collection_remove (GeeAbstractCollection* self, gconstpointer item);
static GType gee_concurrent_set_tower_node_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GeeConcurrentSetTowerNode* gee_concurrent_set_tower_node_dup (const GeeConcurrentSetTowerNode* self);
static void gee_concurrent_set_tower_node_free (GeeConcurrentSetTowerNode* self);
static gpointer gee_concurrent_set_real_first (GeeAbstractSortedSet* base);
static inline gboolean gee_concurrent_set_tower_proceed (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower** arg_prev, GeeConcurrentSetTower** arg_curr, guint8 level, gboolean force);
static gpointer gee_concurrent_set_real_last (GeeAbstractSortedSet* base);
static GeeIterator* gee_concurrent_set_real_iterator_at (GeeAbstractSortedSet* base, gconstpointer element);
static inline gboolean gee_concurrent_set_tower_search_from_bookmark (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, gconstpointer key, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTowerIter* next, guint8 to_level, guint8 from_level);
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_new_point_at (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr);
static GeeConcurrentSetIterator* gee_concurrent_set_iterator_construct_point_at (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr);
static gpointer gee_concurrent_set_real_lower (GeeAbstractSortedSet* base, gconstpointer element);
static gpointer gee_concurrent_set_real_higher (GeeAbstractSortedSet* base, gconstpointer element);
static gpointer gee_concurrent_set_real_floor (GeeAbstractSortedSet* base, gconstpointer element);
static gpointer gee_concurrent_set_real_ceil (GeeAbstractSortedSet* base, gconstpointer element);
static GeeSortedSet* gee_concurrent_set_real_head_set (GeeAbstractSortedSet* base, gconstpointer before);
static GeeConcurrentSetRange* gee_concurrent_set_range_new_head (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer end);
static GeeConcurrentSetRange* gee_concurrent_set_range_construct_head (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer end);
static gpointer gee_concurrent_set_range_ref (gpointer instance);
static void gee_concurrent_set_range_unref (gpointer instance);
static GParamSpec* gee_concurrent_set_param_spec_range (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void gee_concurrent_set_value_set_range (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void gee_concurrent_set_value_take_range (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer gee_concurrent_set_value_get_range (const GValue* value) G_GNUC_UNUSED;
static GType gee_concurrent_set_range_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GeeConcurrentSetSubSet* gee_concurrent_set_sub_set_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range);
static GeeConcurrentSetSubSet* gee_concurrent_set_sub_set_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range);
static GType gee_concurrent_set_sub_set_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GeeSortedSet* gee_concurrent_set_real_tail_set (GeeAbstractSortedSet* base, gconstpointer after);
static GeeConcurrentSetRange* gee_concurrent_set_range_new_tail (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start);
static GeeConcurrentSetRange* gee_concurrent_set_range_construct_tail (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start);
static GeeSortedSet* gee_concurrent_set_real_sub_set (GeeAbstractSortedSet* base, gconstpointer from, gconstpointer to);
static GeeConcurrentSetRange* gee_concurrent_set_range_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start, gconstpointer end);
static GeeConcurrentSetRange* gee_concurrent_set_range_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start, gconstpointer end);
static gconstpointer gee_concurrent_set_max (GeeConcurrentSet* self, gconstpointer a, gconstpointer b, gboolean* changed);
static gconstpointer gee_concurrent_set_min (GeeConcurrentSet* self, gconstpointer a, gconstpointer b, gboolean* changed);
#define GEE_CONCURRENT_SET_ITERATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIteratorPrivate))
enum  {
	GEE_CONCURRENT_SET_ITERATOR_DUMMY_PROPERTY,
	GEE_CONCURRENT_SET_ITERATOR_G_TYPE,
	GEE_CONCURRENT_SET_ITERATOR_G_DUP_FUNC,
	GEE_CONCURRENT_SET_ITERATOR_G_DESTROY_FUNC,
	GEE_CONCURRENT_SET_ITERATOR_VALID,
	GEE_CONCURRENT_SET_ITERATOR_READ_ONLY
};
static gboolean gee_concurrent_set_iterator_real_foreach (GeeTraversable* base, GeeForallFunc f, void* f_target);
static inline gint gee_concurrent_set_tower_get_height (GeeConcurrentSetTower* self);
static gboolean gee_concurrent_set_iterator_real_next (GeeIterator* base);
static gboolean gee_concurrent_set_iterator_real_has_next (GeeIterator* base);
static gpointer gee_concurrent_set_iterator_real_get (GeeIterator* base);
gboolean gee_iterator_get_valid (GeeIterator* self);
static void gee_concurrent_set_iterator_real_remove (GeeIterator* base);
static inline gboolean gee_concurrent_set_tower_remove (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr);
static void gee_concurrent_set_iterator_finalize (GObject* obj);
gboolean gee_iterator_get_read_only (GeeIterator* self);
static void _vala_gee_concurrent_set_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_concurrent_set_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define GEE_CONCURRENT_SET_SUB_SET_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSetPrivate))
enum  {
	GEE_CONCURRENT_SET_SUB_SET_DUMMY_PROPERTY,
	GEE_CONCURRENT_SET_SUB_SET_G_TYPE,
	GEE_CONCURRENT_SET_SUB_SET_G_DUP_FUNC,
	GEE_CONCURRENT_SET_SUB_SET_G_DESTROY_FUNC,
	GEE_CONCURRENT_SET_SUB_SET_SIZE,
	GEE_CONCURRENT_SET_SUB_SET_IS_EMPTY,
	GEE_CONCURRENT_SET_SUB_SET_READ_ONLY
};
static GeeIterator* gee_concurrent_set_sub_set_real_iterator (GeeAbstractCollection* base);
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range);
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range);
static GType gee_concurrent_set_sub_iterator_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static gboolean gee_concurrent_set_sub_set_real_contains (GeeAbstractCollection* base, gconstpointer item);
static gboolean gee_concurrent_set_range_inside (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, gconstpointer val);
static void gee_concurrent_set_range_improve_bookmark (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTower** out_curr, GeeConcurrentSetTowerIter* prev);
static gboolean gee_concurrent_set_sub_set_real_add (GeeAbstractCollection* base, gconstpointer key);
static gboolean gee_concurrent_set_sub_set_real_remove (GeeAbstractCollection* base, gconstpointer key);
static void gee_concurrent_set_sub_set_real_clear (GeeAbstractCollection* base);
static gpointer gee_concurrent_set_sub_set_real_first (GeeAbstractSortedSet* base);
static gpointer gee_concurrent_set_sub_set_real_last (GeeAbstractSortedSet* base);
static gboolean gee_concurrent_set_range_proceed (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTower** prev, GeeConcurrentSetTower** curr, guint8 level);
static GeeIterator* gee_concurrent_set_sub_set_real_iterator_at (GeeAbstractSortedSet* base, gconstpointer element);
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_new_point_at (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr);
static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_construct_point_at (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr);
static gpointer gee_concurrent_set_sub_set_real_lower (GeeAbstractSortedSet* base, gconstpointer element);
static gint gee_concurrent_set_range_cmp (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, gconstpointer val);
static GType gee_concurrent_set_range_position_get_type (void) G_GNUC_UNUSED;
gpointer gee_abstract_sorted_set_last (GeeAbstractSortedSet* self);
static gpointer gee_concurrent_set_sub_set_real_higher (GeeAbstractSortedSet* base, gconstpointer element);
gpointer gee_abstract_sorted_set_first (GeeAbstractSortedSet* self);
static gpointer gee_concurrent_set_sub_set_real_floor (GeeAbstractSortedSet* base, gconstpointer element);
static inline gboolean gee_concurrent_set_tower_is_head (GeeConcurrentSetTower* self);
static gpointer gee_concurrent_set_sub_set_real_ceil (GeeAbstractSortedSet* base, gconstpointer element);
static GeeSortedSet* gee_concurrent_set_sub_set_real_head_set (GeeAbstractSortedSet* base, gconstpointer before);
static GeeConcurrentSetRange* gee_concurrent_set_range_cut_tail (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* from, gconstpointer end);
static GeeSortedSet* gee_concurrent_set_sub_set_real_tail_set (GeeAbstractSortedSet* base, gconstpointer after);
static GeeConcurrentSetRange* gee_concurrent_set_range_cut_head (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* from, gconstpointer start);
static GeeSortedSet* gee_concurrent_set_sub_set_real_sub_set (GeeAbstractSortedSet* base, gconstpointer from, gconstpointer to);
static GeeConcurrentSetRange* gee_concurrent_set_range_cut (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* from, gconstpointer start, gconstpointer end);
gpointer gee_hazard_pointer_get_pointer (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, gconstpointer** aptr, gsize mask, gsize* mask_out);
static gboolean gee_concurrent_set_sub_set_get_is_empty (GeeConcurrentSetSubSet* self);
static void gee_concurrent_set_sub_set_finalize (GObject* obj);
gint gee_abstract_collection_get_size (GeeAbstractCollection* self);
gboolean gee_abstract_collection_get_read_only (GeeAbstractCollection* self);
static void _vala_gee_concurrent_set_sub_set_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_concurrent_set_sub_set_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define GEE_CONCURRENT_SET_SUB_ITERATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIteratorPrivate))
enum  {
	GEE_CONCURRENT_SET_SUB_ITERATOR_DUMMY_PROPERTY,
	GEE_CONCURRENT_SET_SUB_ITERATOR_G_TYPE,
	GEE_CONCURRENT_SET_SUB_ITERATOR_G_DUP_FUNC,
	GEE_CONCURRENT_SET_SUB_ITERATOR_G_DESTROY_FUNC,
	GEE_CONCURRENT_SET_SUB_ITERATOR_VALID,
	GEE_CONCURRENT_SET_SUB_ITERATOR_READ_ONLY
};
static gboolean gee_concurrent_set_sub_iterator_real_foreach (GeeTraversable* base, GeeForallFunc f, void* f_target);
static gboolean gee_concurrent_set_sub_iterator_begin (GeeConcurrentSetSubIterator* self);
static gboolean gee_concurrent_set_sub_iterator_real_next (GeeIterator* base);
static gboolean gee_concurrent_set_sub_iterator_real_has_next (GeeIterator* base);
static gboolean gee_concurrent_set_range_beyond (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTower* tw);
static gpointer gee_concurrent_set_sub_iterator_real_get (GeeIterator* base);
static void gee_concurrent_set_sub_iterator_real_remove (GeeIterator* base);
static void gee_concurrent_set_sub_iterator_finalize (GObject* obj);
static void _vala_gee_concurrent_set_sub_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_concurrent_set_sub_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define GEE_CONCURRENT_SET_RANGE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_CONCURRENT_SET_TYPE_RANGE, GeeConcurrentSetRangePrivate))
enum  {
	GEE_CONCURRENT_SET_RANGE_DUMMY_PROPERTY
};
static GeeConcurrentSetRange* gee_concurrent_set_range_new_empty (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset);
static GeeConcurrentSetRange* gee_concurrent_set_range_construct_empty (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset);
static void gee_concurrent_set_range_copy_bookmark (GeeConcurrentSetRange* self, GeeConcurrentSetRange* range);
static inline void gee_concurrent_set_tower_backtrace (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetTower** curr, guint8 level);
static inline gint gee_concurrent_set_tower_compare (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower* a, GeeConcurrentSetTower* b);
gboolean gee_hazard_pointer_compare_and_exchange_pointer (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, gconstpointer** aptr, gconstpointer old_ptr, gpointer _new_ptr, gsize mask, gsize old_mask, gsize new_mask);
static inline gint gee_concurrent_set_tower_compare_data (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower* a, gconstpointer b);
static void gee_concurrent_set_range_finalize (GeeConcurrentSetRange* obj);
#define GEE_CONCURRENT_SET_TOWER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GEE_CONCURRENT_SET_TYPE_TOWER, GeeConcurrentSetTowerPrivate))
enum  {
	GEE_CONCURRENT_SET_TOWER_DUMMY_PROPERTY
};
static inline void gee_concurrent_set_tower_set_succ (GeeConcurrentSetTower* self, GeeConcurrentSetTower* next, GeeConcurrentSetState state, guint8 level);
static inline void gee_concurrent_set_tower_set_backlink (GeeConcurrentSetTower* self, GeeConcurrentSetTower* backlink, guint8 level);
static GeeConcurrentSetTower* gee_concurrent_set_tower_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, gconstpointer data, guint8 height);
static GeeConcurrentSetTower* gee_concurrent_set_tower_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, gconstpointer data, guint8 height);
static inline gboolean gee_concurrent_set_tower_search_helper (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, gconstpointer key, GeeConcurrentSetTower** prev, GeeConcurrentSetTower** next, guint8 level);
static inline GeeConcurrentSetTower* gee_concurrent_set_tower_insert_helper (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, gconstpointer key, guint8 chosen_level, guint8 level);
static inline GeeConcurrentSetTower* gee_concurrent_set_tower_get_succ (GeeConcurrentSetTower* self, GeeConcurrentSetState* state, guint8 level);
static inline void gee_concurrent_set_tower_help_flagged (GeeConcurrentSetTower* self, GeeConcurrentSetTower* prev, guint8 level);
static inline gboolean gee_concurrent_set_tower_compare_and_exchange (GeeConcurrentSetTower* self, GeeConcurrentSetTower* old_tower, GeeConcurrentSetState old_state, GeeConcurrentSetTower* new_tower, GeeConcurrentSetState new_state, guint8 level);
static inline GeeConcurrentSetState gee_concurrent_set_tower_get_state (GeeConcurrentSetTower* self, guint8 level);
static inline gboolean gee_concurrent_set_tower_remove_level (GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower** prev, GeeConcurrentSetTower* curr, guint8 level);
static inline gboolean gee_concurrent_set_tower_try_flag (GeeConcurrentSetTower* self, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower** prev_tower, gboolean* status, guint8 level);
static inline void gee_concurrent_set_tower_help_marked (GeeConcurrentSetTower* self, GeeConcurrentSetTower* prev_tower, guint8 level);
static inline void gee_concurrent_set_tower_try_mark (GeeConcurrentSetTower* self, guint8 level);
static inline gboolean gee_concurrent_set_tower_compare_succ (GeeConcurrentSetTower* self, GeeConcurrentSetTower* next, GeeConcurrentSetState state, guint8 level);
static inline GeeConcurrentSetTower* gee_concurrent_set_tower_get_backlink (GeeConcurrentSetTower* self, guint8 level);
void gee_hazard_pointer_set_pointer (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, gconstpointer** aptr, gpointer new_ptr, gsize mask, gsize new_mask);
static void gee_concurrent_set_tower_finalize (GeeConcurrentSetTower* obj);
static void _vala_array_copy2 (GeeConcurrentSetTower** self, GeeConcurrentSetTower** dest);
static void gee_concurrent_set_finalize (GObject* obj);
static void _vala_gee_concurrent_set_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_gee_concurrent_set_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


GType gee_concurrent_set_range_type_get_type (void) {
	static volatile gsize gee_concurrent_set_range_type_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_range_type_type_id__volatile)) {
		static const GEnumValue values[] = {{GEE_CONCURRENT_SET_RANGE_TYPE_HEAD, "GEE_CONCURRENT_SET_RANGE_TYPE_HEAD", "head"}, {GEE_CONCURRENT_SET_RANGE_TYPE_TAIL, "GEE_CONCURRENT_SET_RANGE_TYPE_TAIL", "tail"}, {GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED, "GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED", "bounded"}, {GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY, "GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY", "empty"}, {0, NULL, NULL}};
		GType gee_concurrent_set_range_type_type_id;
		gee_concurrent_set_range_type_type_id = g_enum_register_static ("GeeConcurrentSetRangeType", values);
		g_once_init_leave (&gee_concurrent_set_range_type_type_id__volatile, gee_concurrent_set_range_type_type_id);
	}
	return gee_concurrent_set_range_type_type_id__volatile;
}


static GType gee_concurrent_set_state_get_type (void) {
	static volatile gsize gee_concurrent_set_state_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_state_type_id__volatile)) {
		static const GEnumValue values[] = {{GEE_CONCURRENT_SET_STATE_NONE, "GEE_CONCURRENT_SET_STATE_NONE", "none"}, {GEE_CONCURRENT_SET_STATE_MARKED, "GEE_CONCURRENT_SET_STATE_MARKED", "marked"}, {GEE_CONCURRENT_SET_STATE_FLAGGED, "GEE_CONCURRENT_SET_STATE_FLAGGED", "flagged"}, {0, NULL, NULL}};
		GType gee_concurrent_set_state_type_id;
		gee_concurrent_set_state_type_id = g_enum_register_static ("GeeConcurrentSetState", values);
		g_once_init_leave (&gee_concurrent_set_state_type_id__volatile, gee_concurrent_set_state_type_id);
	}
	return gee_concurrent_set_state_type_id__volatile;
}


static void _gee_concurrent_set_rand_lambda37_ (void* ptr) {
	void* _tmp0_;
	GRand* rnd;
	GRand* _tmp1_;
	_tmp0_ = ptr;
	rnd = (GRand*) _tmp0_;
	_tmp1_ = rnd;
	g_rand_free (_tmp1_);
}


static void __gee_concurrent_set_rand_lambda37__gdestroy_notify (void* data) {
	_gee_concurrent_set_rand_lambda37_ (data);
}


GeeConcurrentSet* gee_concurrent_set_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc compare_func, void* compare_func_target, GDestroyNotify compare_func_target_destroy_notify) {
	GeeConcurrentSet * self = NULL;
	GCompareDataFunc _tmp0_;
	void* _tmp0__target;
	GCompareDataFunc _tmp4_;
	void* _tmp4__target;
	self = (GeeConcurrentSet*) gee_abstract_sorted_set_construct (object_type, g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = compare_func;
	_tmp0__target = compare_func_target;
	if (_tmp0_ == NULL) {
		void* _tmp1_ = NULL;
		GDestroyNotify _tmp2_ = NULL;
		GCompareDataFunc _tmp3_ = NULL;
		_tmp3_ = gee_functions_get_compare_func_for (g_type, &_tmp1_, &_tmp2_);
		(compare_func_target_destroy_notify == NULL) ? NULL : (compare_func_target_destroy_notify (compare_func_target), NULL);
		compare_func = NULL;
		compare_func_target = NULL;
		compare_func_target_destroy_notify = NULL;
		compare_func = _tmp3_;
		compare_func_target = _tmp1_;
		compare_func_target_destroy_notify = _tmp2_;
	}
	_tmp4_ = compare_func;
	_tmp4__target = compare_func_target;
	(self->priv->_cmp_target_destroy_notify == NULL) ? NULL : (self->priv->_cmp_target_destroy_notify (self->priv->_cmp_target), NULL);
	self->priv->_cmp = NULL;
	self->priv->_cmp_target = NULL;
	self->priv->_cmp_target_destroy_notify = NULL;
	self->priv->_cmp = _tmp4_;
	self->priv->_cmp_target = _tmp4__target;
	self->priv->_cmp_target_destroy_notify = NULL;
	(compare_func_target_destroy_notify == NULL) ? NULL : (compare_func_target_destroy_notify (compare_func_target), NULL);
	compare_func = NULL;
	compare_func_target = NULL;
	compare_func_target_destroy_notify = NULL;
	return self;
}


GeeConcurrentSet* gee_concurrent_set_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc compare_func, void* compare_func_target, GDestroyNotify compare_func_target_destroy_notify) {
	return gee_concurrent_set_construct (GEE_TYPE_CONCURRENT_SET, g_type, g_dup_func, g_destroy_func, compare_func, compare_func_target, compare_func_target_destroy_notify);
}


static GeeIterator* gee_concurrent_set_real_iterator (GeeAbstractCollection* base) {
	GeeConcurrentSet * self;
	GeeIterator* result = NULL;
	GeeConcurrentSetTower* _tmp0_;
	GeeConcurrentSetIterator* _tmp1_;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = self->priv->_head;
	_tmp1_ = gee_concurrent_set_iterator_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, self, _tmp0_);
	result = (GeeIterator*) _tmp1_;
	return result;
}


static gpointer _gee_concurrent_set_tower_ref0 (gpointer self) {
	return self ? gee_concurrent_set_tower_ref (self) : NULL;
}


static gboolean gee_concurrent_set_real_contains (GeeAbstractCollection* base, gconstpointer key) {
	GeeConcurrentSet * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTower* _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* prev;
	GCompareDataFunc _tmp3_;
	void* _tmp3__target;
	gconstpointer _tmp4_;
	gboolean _tmp5_ = FALSE;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_head;
	_tmp2_ = _gee_concurrent_set_tower_ref0 (_tmp1_);
	prev = _tmp2_;
	_tmp3_ = self->priv->_cmp;
	_tmp3__target = self->priv->_cmp_target;
	_tmp4_ = key;
	_tmp5_ = gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp3_, _tmp3__target, _tmp4_, &prev, NULL, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	result = _tmp5_;
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_real_add (GeeAbstractCollection* base, gconstpointer key) {
	GeeConcurrentSet * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GPrivate* _tmp1_;
	void* _tmp2_ = NULL;
	GRand* rnd;
	GRand* _tmp3_;
	GRand* _tmp7_;
	gint32 _tmp8_;
	gint32 _tmp9_ = 0;
	guint32 rand_int;
	guint32 _tmp10_;
	gint _tmp11_ = 0;
	guint8 height;
	GeeConcurrentSetTowerIter prev = {0};
	guint8 _tmp12_;
	GeeConcurrentSetTower* _tmp13_;
	GeeConcurrentSetTower* _tmp14_;
	GeeConcurrentSetTower* _tmp15_;
	GCompareDataFunc _tmp16_;
	void* _tmp16__target;
	gconstpointer _tmp17_;
	guint8 _tmp18_;
	guint8 _tmp19_;
	gboolean _tmp20_ = FALSE;
	GCompareDataFunc _tmp32_;
	void* _tmp32__target;
	gconstpointer _tmp33_;
	guint8 _tmp34_;
	GeeConcurrentSetTower* _tmp35_ = NULL;
	GeeConcurrentSetTower* _result_;
	GeeConcurrentSetTower* _tmp36_;
	GeeConcurrentSetTower* _tmp37_;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = gee_concurrent_set_rand;
	_tmp2_ = g_private_get (_tmp1_);
	rnd = _tmp2_;
	_tmp3_ = rnd;
	if (_tmp3_ == NULL) {
		GPrivate* _tmp4_;
		GRand* _tmp5_;
		GRand* _tmp6_;
		_tmp4_ = gee_concurrent_set_rand;
		_tmp5_ = g_rand_new ();
		rnd = _tmp5_;
		_tmp6_ = rnd;
		g_private_set (_tmp4_, _tmp6_);
	}
	_tmp7_ = rnd;
	_tmp8_ = G_MAXINT32;
	_tmp9_ = g_rand_int_range (_tmp7_, (gint32) 0, _tmp8_);
	rand_int = (guint32) _tmp9_;
	_tmp10_ = rand_int;
	_tmp11_ = g_bit_nth_lsf ((gulong) (~_tmp10_), -1);
	height = (guint8) (1 + ((guint8) _tmp11_));
	memset (&prev, 0, sizeof (GeeConcurrentSetTowerIter));
	_tmp12_ = height;
	_tmp13_ = self->priv->_head;
	_tmp14_ = _gee_concurrent_set_tower_ref0 (_tmp13_);
	_gee_concurrent_set_tower_unref0 (prev._iter[_tmp12_ - 1]);
	prev._iter[_tmp12_ - 1] = _tmp14_;
	_tmp15_ = prev._iter[_tmp12_ - 1];
	_tmp16_ = self->priv->_cmp;
	_tmp16__target = self->priv->_cmp_target;
	_tmp17_ = key;
	_tmp18_ = height;
	_tmp19_ = height;
	_tmp20_ = gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp16_, _tmp16__target, _tmp17_, &prev._iter[_tmp18_ - 1], NULL, (guint8) (_tmp19_ - 1), (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	if (_tmp20_) {
		result = FALSE;
		gee_concurrent_set_tower_iter_destroy (&prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	{
		guint8 _tmp21_;
		gint i;
		_tmp21_ = height;
		i = _tmp21_ - 2;
		{
			gboolean _tmp22_;
			_tmp22_ = TRUE;
			while (TRUE) {
				gboolean _tmp23_;
				gint _tmp25_;
				gint _tmp26_;
				GeeConcurrentSetTowerIter _tmp27_;
				guint8 _tmp28_;
				GeeConcurrentSetTower* _tmp29_;
				GeeConcurrentSetTower* _tmp30_;
				GeeConcurrentSetTower* _tmp31_;
				_tmp23_ = _tmp22_;
				if (!_tmp23_) {
					gint _tmp24_;
					_tmp24_ = i;
					i = _tmp24_ - 1;
				}
				_tmp22_ = FALSE;
				_tmp25_ = i;
				if (!(_tmp25_ >= 0)) {
					break;
				}
				_tmp26_ = i;
				_tmp27_ = prev;
				_tmp28_ = height;
				_tmp29_ = _tmp27_._iter[_tmp28_ - 1];
				_tmp30_ = _gee_concurrent_set_tower_ref0 (_tmp29_);
				_gee_concurrent_set_tower_unref0 (prev._iter[_tmp26_]);
				prev._iter[_tmp26_] = _tmp30_;
				_tmp31_ = prev._iter[_tmp26_];
			}
		}
	}
	_tmp32_ = self->priv->_cmp;
	_tmp32__target = self->priv->_cmp_target;
	_tmp33_ = key;
	_tmp34_ = height;
	_tmp35_ = gee_concurrent_set_tower_insert (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp32_, _tmp32__target, &prev, _tmp33_, (guint8) (_tmp34_ - 1));
	_result_ = _tmp35_;
	_tmp36_ = _result_;
	if (_tmp36_ != NULL) {
		g_atomic_int_inc ((volatile gint *) (&self->priv->_size));
	}
	_tmp37_ = _result_;
	result = _tmp37_ != NULL;
	_gee_concurrent_set_tower_unref0 (_result_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_real_remove (GeeAbstractCollection* base, gconstpointer item) {
	GeeConcurrentSet * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTowerIter prev = {0};
	GCompareDataFunc _tmp9_;
	void* _tmp9__target;
	gconstpointer _tmp10_;
	gboolean _tmp11_ = FALSE;
	gboolean _result_;
	gboolean _tmp12_;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	memset (&prev, 0, sizeof (GeeConcurrentSetTowerIter));
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				gint _tmp5_;
				GeeConcurrentSetTower* _tmp6_;
				GeeConcurrentSetTower* _tmp7_;
				GeeConcurrentSetTower* _tmp8_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				if (!(_tmp4_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp5_ = i;
				_tmp6_ = self->priv->_head;
				_tmp7_ = _gee_concurrent_set_tower_ref0 (_tmp6_);
				_gee_concurrent_set_tower_unref0 (prev._iter[_tmp5_]);
				prev._iter[_tmp5_] = _tmp7_;
				_tmp8_ = prev._iter[_tmp5_];
			}
		}
	}
	_tmp9_ = self->priv->_cmp;
	_tmp9__target = self->priv->_cmp_target;
	_tmp10_ = item;
	_tmp11_ = gee_concurrent_set_tower_remove_key (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp9_, _tmp9__target, &prev, _tmp10_, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_result_ = _tmp11_;
	_tmp12_ = _result_;
	if (_tmp12_) {
		g_atomic_int_dec_and_test ((volatile gint *) (&self->priv->_size));
	}
	result = _result_;
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static void gee_concurrent_set_real_clear (GeeAbstractCollection* base) {
	GeeConcurrentSet * self;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTower* first = NULL;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	while (TRUE) {
		GeeConcurrentSetTower* _tmp1_;
		GeeConcurrentSetTower* _tmp2_ = NULL;
		GeeConcurrentSetTower* _tmp3_;
		GeeConcurrentSetTower* _tmp4_;
		gconstpointer _tmp5_;
		_tmp1_ = self->priv->_head;
		_tmp2_ = gee_concurrent_set_tower_get_next (_tmp1_, (guint8) 0);
		_gee_concurrent_set_tower_unref0 (first);
		first = _tmp2_;
		_tmp3_ = first;
		if (!(_tmp3_ != NULL)) {
			break;
		}
		_tmp4_ = first;
		_tmp5_ = _tmp4_->_data;
		gee_abstract_collection_remove ((GeeAbstractCollection*) self, _tmp5_);
	}
	_gee_concurrent_set_tower_unref0 (first);
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_real_first (GeeAbstractSortedSet* base) {
	GeeConcurrentSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTower* prev;
	GeeConcurrentSetTower* _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* curr;
	GCompareDataFunc _tmp3_;
	void* _tmp3__target;
	gboolean _tmp4_ = FALSE;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	prev = NULL;
	_tmp1_ = self->priv->_head;
	_tmp2_ = _gee_concurrent_set_tower_ref0 (_tmp1_);
	curr = _tmp2_;
	_tmp3_ = self->priv->_cmp;
	_tmp3__target = self->priv->_cmp_target;
	_tmp4_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp3_, _tmp3__target, &prev, &curr, (guint8) 0, FALSE);
	if (_tmp4_) {
		GeeConcurrentSetTower* _tmp5_;
		gconstpointer _tmp6_;
		gpointer _tmp7_;
		_tmp5_ = curr;
		_tmp6_ = _tmp5_->_data;
		_tmp7_ = ((_tmp6_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp6_) : ((gpointer) _tmp6_);
		result = _tmp7_;
		_gee_concurrent_set_tower_unref0 (curr);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	} else {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (curr);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_gee_concurrent_set_tower_unref0 (curr);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_real_last (GeeAbstractSortedSet* base) {
	GeeConcurrentSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTower* prev;
	GeeConcurrentSetTower* _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* curr;
	gboolean found;
	gboolean _tmp9_;
	GeeConcurrentSetTower* _tmp10_;
	gconstpointer _tmp11_;
	gpointer _tmp12_;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	prev = NULL;
	_tmp1_ = self->priv->_head;
	_tmp2_ = _gee_concurrent_set_tower_ref0 (_tmp1_);
	curr = _tmp2_;
	found = FALSE;
	{
		gint i;
		i = GEE_CONCURRENT_SET__MAX_HEIGHT;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_;
				gint _tmp6_;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					gint _tmp5_;
					_tmp5_ = i;
					i = _tmp5_ - 1;
				}
				_tmp3_ = FALSE;
				_tmp6_ = i;
				if (!(_tmp6_ >= 0)) {
					break;
				}
				while (TRUE) {
					GCompareDataFunc _tmp7_;
					void* _tmp7__target;
					gboolean _tmp8_ = FALSE;
					_tmp7_ = self->priv->_cmp;
					_tmp7__target = self->priv->_cmp_target;
					_tmp8_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp7_, _tmp7__target, &prev, &curr, (guint8) 0, FALSE);
					if (!_tmp8_) {
						break;
					}
					found = TRUE;
				}
			}
		}
	}
	_tmp9_ = found;
	if (!_tmp9_) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (curr);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp10_ = curr;
	_tmp11_ = _tmp10_->_data;
	_tmp12_ = ((_tmp11_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp11_) : ((gpointer) _tmp11_);
	result = _tmp12_;
	_gee_concurrent_set_tower_unref0 (curr);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeIterator* gee_concurrent_set_real_iterator_at (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSet * self;
	GeeIterator* result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetTowerIter curr = {0};
	GCompareDataFunc _tmp9_;
	void* _tmp9__target;
	gconstpointer _tmp10_;
	GeeConcurrentSetTowerIter _tmp11_ = {0};
	gboolean _tmp12_ = FALSE;
	GeeConcurrentSetTowerIter _tmp13_;
	GeeConcurrentSetTower* _tmp14_;
	GeeConcurrentSetIterator* _tmp15_;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	memset (&prev, 0, sizeof (GeeConcurrentSetTowerIter));
	{
		gint i;
		i = 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				gint _tmp5_;
				GeeConcurrentSetTower* _tmp6_;
				GeeConcurrentSetTower* _tmp7_;
				GeeConcurrentSetTower* _tmp8_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				if (!(_tmp4_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp5_ = i;
				_tmp6_ = self->priv->_head;
				_tmp7_ = _gee_concurrent_set_tower_ref0 (_tmp6_);
				_gee_concurrent_set_tower_unref0 (prev._iter[_tmp5_]);
				prev._iter[_tmp5_] = _tmp7_;
				_tmp8_ = prev._iter[_tmp5_];
			}
		}
	}
	_tmp9_ = self->priv->_cmp;
	_tmp9__target = self->priv->_cmp_target;
	_tmp10_ = element;
	_tmp12_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp9_, _tmp9__target, _tmp10_, &prev, &_tmp11_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	gee_concurrent_set_tower_iter_destroy (&curr);
	curr = _tmp11_;
	if (!_tmp12_) {
		result = NULL;
		gee_concurrent_set_tower_iter_destroy (&curr);
		gee_concurrent_set_tower_iter_destroy (&prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp13_ = curr;
	_tmp14_ = _tmp13_._iter[0];
	_tmp15_ = gee_concurrent_set_iterator_new_point_at (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, self, &prev, _tmp14_);
	result = (GeeIterator*) _tmp15_;
	gee_concurrent_set_tower_iter_destroy (&curr);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gpointer gee_concurrent_set_real_lower (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTower* _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* prev;
	GCompareDataFunc _tmp3_;
	void* _tmp3__target;
	gconstpointer _tmp4_;
	GeeConcurrentSetTower* _tmp5_;
	GeeConcurrentSetTower* _tmp6_;
	GeeConcurrentSetTower* _tmp7_;
	gconstpointer _tmp8_;
	gpointer _tmp9_;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_head;
	_tmp2_ = _gee_concurrent_set_tower_ref0 (_tmp1_);
	prev = _tmp2_;
	_tmp3_ = self->priv->_cmp;
	_tmp3__target = self->priv->_cmp_target;
	_tmp4_ = element;
	gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp3_, _tmp3__target, _tmp4_, &prev, NULL, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_tmp5_ = prev;
	_tmp6_ = self->priv->_head;
	if (_tmp5_ == _tmp6_) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp7_ = prev;
	_tmp8_ = _tmp7_->_data;
	_tmp9_ = ((_tmp8_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp8_) : ((gpointer) _tmp8_);
	result = _tmp9_;
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gpointer gee_concurrent_set_real_higher (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTower* _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* prev;
	GeeConcurrentSetTower* next = NULL;
	GCompareDataFunc _tmp3_;
	void* _tmp3__target;
	gconstpointer _tmp4_;
	GeeConcurrentSetTower* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	GeeConcurrentSetTower* _tmp9_;
	GeeConcurrentSetTower* _tmp10_;
	gconstpointer _tmp11_;
	gpointer _tmp12_;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_head;
	_tmp2_ = _gee_concurrent_set_tower_ref0 (_tmp1_);
	prev = _tmp2_;
	_tmp3_ = self->priv->_cmp;
	_tmp3__target = self->priv->_cmp_target;
	_tmp4_ = element;
	_tmp6_ = gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp3_, _tmp3__target, _tmp4_, &prev, &_tmp5_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_gee_concurrent_set_tower_unref0 (next);
	next = _tmp5_;
	if (_tmp6_) {
		GCompareDataFunc _tmp7_;
		void* _tmp7__target;
		gboolean _tmp8_ = FALSE;
		_tmp7_ = self->priv->_cmp;
		_tmp7__target = self->priv->_cmp_target;
		_tmp8_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp7_, _tmp7__target, &prev, &next, (guint8) 0, FALSE);
		if (!_tmp8_) {
			result = NULL;
			_gee_concurrent_set_tower_unref0 (next);
			_gee_concurrent_set_tower_unref0 (prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
	}
	_tmp9_ = next;
	if (_tmp9_ == NULL) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp10_ = next;
	_tmp11_ = _tmp10_->_data;
	_tmp12_ = ((_tmp11_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp11_) : ((gpointer) _tmp11_);
	result = _tmp12_;
	_gee_concurrent_set_tower_unref0 (next);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gpointer gee_concurrent_set_real_floor (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTower* _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* prev;
	GeeConcurrentSetTower* next = NULL;
	GCompareDataFunc _tmp3_;
	void* _tmp3__target;
	gconstpointer _tmp4_;
	GeeConcurrentSetTower* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_head;
	_tmp2_ = _gee_concurrent_set_tower_ref0 (_tmp1_);
	prev = _tmp2_;
	_tmp3_ = self->priv->_cmp;
	_tmp3__target = self->priv->_cmp_target;
	_tmp4_ = element;
	_tmp6_ = gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp3_, _tmp3__target, _tmp4_, &prev, &_tmp5_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_gee_concurrent_set_tower_unref0 (next);
	next = _tmp5_;
	if (_tmp6_) {
		GeeConcurrentSetTower* _tmp7_;
		gconstpointer _tmp8_;
		gpointer _tmp9_;
		_tmp7_ = next;
		_tmp8_ = _tmp7_->_data;
		_tmp9_ = ((_tmp8_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp8_) : ((gpointer) _tmp8_);
		result = _tmp9_;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	} else {
		GeeConcurrentSetTower* _tmp10_;
		GeeConcurrentSetTower* _tmp11_;
		_tmp10_ = prev;
		_tmp11_ = self->priv->_head;
		if (_tmp10_ != _tmp11_) {
			GeeConcurrentSetTower* _tmp12_;
			gconstpointer _tmp13_;
			gpointer _tmp14_;
			_tmp12_ = prev;
			_tmp13_ = _tmp12_->_data;
			_tmp14_ = ((_tmp13_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp13_) : ((gpointer) _tmp13_);
			result = _tmp14_;
			_gee_concurrent_set_tower_unref0 (next);
			_gee_concurrent_set_tower_unref0 (prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		} else {
			result = NULL;
			_gee_concurrent_set_tower_unref0 (next);
			_gee_concurrent_set_tower_unref0 (prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
	}
	_gee_concurrent_set_tower_unref0 (next);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_real_ceil (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTower* _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* prev;
	GeeConcurrentSetTower* next = NULL;
	GCompareDataFunc _tmp3_;
	void* _tmp3__target;
	gconstpointer _tmp4_;
	GeeConcurrentSetTower* _tmp5_ = NULL;
	GeeConcurrentSetTower* _tmp6_;
	GeeConcurrentSetTower* _tmp7_;
	gconstpointer _tmp8_;
	gpointer _tmp9_;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_head;
	_tmp2_ = _gee_concurrent_set_tower_ref0 (_tmp1_);
	prev = _tmp2_;
	_tmp3_ = self->priv->_cmp;
	_tmp3__target = self->priv->_cmp_target;
	_tmp4_ = element;
	gee_concurrent_set_tower_search (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp3_, _tmp3__target, _tmp4_, &prev, &_tmp5_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_gee_concurrent_set_tower_unref0 (next);
	next = _tmp5_;
	_tmp6_ = next;
	if (_tmp6_ == NULL) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp7_ = next;
	_tmp8_ = _tmp7_->_data;
	_tmp9_ = ((_tmp8_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp8_) : ((gpointer) _tmp8_);
	result = _tmp9_;
	_gee_concurrent_set_tower_unref0 (next);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeSortedSet* gee_concurrent_set_real_head_set (GeeAbstractSortedSet* base, gconstpointer before) {
	GeeConcurrentSet * self;
	GeeSortedSet* result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	gconstpointer _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetRange* _tmp3_;
	GeeConcurrentSetSubSet* _tmp4_;
	GeeSortedSet* _tmp5_;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = before;
	_tmp2_ = gee_concurrent_set_range_new_head (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, self, _tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp3_);
	_tmp5_ = (GeeSortedSet*) _tmp4_;
	_gee_concurrent_set_range_unref0 (_tmp3_);
	result = _tmp5_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeSortedSet* gee_concurrent_set_real_tail_set (GeeAbstractSortedSet* base, gconstpointer after) {
	GeeConcurrentSet * self;
	GeeSortedSet* result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	gconstpointer _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetRange* _tmp3_;
	GeeConcurrentSetSubSet* _tmp4_;
	GeeSortedSet* _tmp5_;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = after;
	_tmp2_ = gee_concurrent_set_range_new_tail (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, self, _tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp3_);
	_tmp5_ = (GeeSortedSet*) _tmp4_;
	_gee_concurrent_set_range_unref0 (_tmp3_);
	result = _tmp5_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeSortedSet* gee_concurrent_set_real_sub_set (GeeAbstractSortedSet* base, gconstpointer from, gconstpointer to) {
	GeeConcurrentSet * self;
	GeeSortedSet* result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	gconstpointer _tmp1_;
	gconstpointer _tmp2_;
	GeeConcurrentSetRange* _tmp3_;
	GeeConcurrentSetRange* _tmp4_;
	GeeConcurrentSetSubSet* _tmp5_;
	GeeSortedSet* _tmp6_;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = from;
	_tmp2_ = to;
	_tmp3_ = gee_concurrent_set_range_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, self, _tmp1_, _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_);
	_tmp6_ = (GeeSortedSet*) _tmp5_;
	_gee_concurrent_set_range_unref0 (_tmp4_);
	result = _tmp6_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gconstpointer gee_concurrent_set_max (GeeConcurrentSet* self, gconstpointer a, gconstpointer b, gboolean* changed) {
	gboolean _vala_changed = FALSE;
	gconstpointer result = NULL;
	GCompareDataFunc _tmp0_;
	void* _tmp0__target;
	gconstpointer _tmp1_;
	gconstpointer _tmp2_;
	gint _tmp3_ = 0;
	gconstpointer _tmp4_ = NULL;
	gboolean _tmp5_;
	gconstpointer _tmp8_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_cmp;
	_tmp0__target = self->priv->_cmp_target;
	_tmp1_ = a;
	_tmp2_ = b;
	_tmp3_ = _tmp0_ (_tmp1_, _tmp2_, _tmp0__target);
	_vala_changed = _tmp3_ < 0;
	_tmp5_ = _vala_changed;
	if (_tmp5_) {
		gconstpointer _tmp6_;
		_tmp6_ = b;
		_tmp4_ = _tmp6_;
	} else {
		gconstpointer _tmp7_;
		_tmp7_ = a;
		_tmp4_ = _tmp7_;
	}
	_tmp8_ = _tmp4_;
	result = _tmp8_;
	if (changed) {
		*changed = _vala_changed;
	}
	return result;
}


static gconstpointer gee_concurrent_set_min (GeeConcurrentSet* self, gconstpointer a, gconstpointer b, gboolean* changed) {
	gboolean _vala_changed = FALSE;
	gconstpointer result = NULL;
	GCompareDataFunc _tmp0_;
	void* _tmp0__target;
	gconstpointer _tmp1_;
	gconstpointer _tmp2_;
	gint _tmp3_ = 0;
	gconstpointer _tmp4_ = NULL;
	gboolean _tmp5_;
	gconstpointer _tmp8_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_cmp;
	_tmp0__target = self->priv->_cmp_target;
	_tmp1_ = a;
	_tmp2_ = b;
	_tmp3_ = _tmp0_ (_tmp1_, _tmp2_, _tmp0__target);
	_vala_changed = _tmp3_ > 0;
	_tmp5_ = _vala_changed;
	if (_tmp5_) {
		gconstpointer _tmp6_;
		_tmp6_ = b;
		_tmp4_ = _tmp6_;
	} else {
		gconstpointer _tmp7_;
		_tmp7_ = a;
		_tmp4_ = _tmp7_;
	}
	_tmp8_ = _tmp4_;
	result = _tmp8_;
	if (changed) {
		*changed = _vala_changed;
	}
	return result;
}


static gint gee_concurrent_set_real_get_size (GeeAbstractCollection* base) {
	gint result;
	GeeConcurrentSet* self;
	gint _tmp0_ = 0;
	self = (GeeConcurrentSet*) base;
	_tmp0_ = g_atomic_int_get ((volatile gint *) (&self->priv->_size));
	result = _tmp0_;
	return result;
}


static gboolean gee_concurrent_set_real_get_read_only (GeeAbstractCollection* base) {
	gboolean result;
	GeeConcurrentSet* self;
	self = (GeeConcurrentSet*) base;
	result = FALSE;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static GeeConcurrentSetIterator* gee_concurrent_set_iterator_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTower* head) {
	GeeConcurrentSetIterator * self = NULL;
	GeeConcurrentSetTower* _tmp0_;
	GeeConcurrentSetTower* _tmp1_;
	GeeConcurrentSet* _tmp2_;
	GeeConcurrentSet* _tmp3_;
	GeeConcurrentSetTower* _tmp4_;
	g_return_val_if_fail (cset != NULL, NULL);
	g_return_val_if_fail (head != NULL, NULL);
	self = (GeeConcurrentSetIterator*) g_object_new (object_type, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = head;
	_tmp1_ = _gee_concurrent_set_tower_ref0 (_tmp0_);
	_gee_concurrent_set_tower_unref0 (self->priv->_curr);
	self->priv->_curr = _tmp1_;
	_tmp2_ = cset;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->priv->_set);
	self->priv->_set = _tmp3_;
	_tmp4_ = self->priv->_curr;
	_vala_assert (_tmp4_ != NULL, "_curr != null");
	return self;
}


static GeeConcurrentSetIterator* gee_concurrent_set_iterator_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTower* head) {
	return gee_concurrent_set_iterator_construct (GEE_CONCURRENT_SET_TYPE_ITERATOR, g_type, g_dup_func, g_destroy_func, cset, head);
}


static GeeConcurrentSetIterator* gee_concurrent_set_iterator_construct_point_at (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr) {
	GeeConcurrentSetIterator * self = NULL;
	GeeConcurrentSetTower* _tmp0_;
	GeeConcurrentSetTower* _tmp1_;
	GeeConcurrentSet* _tmp2_;
	GeeConcurrentSet* _tmp3_;
	GeeConcurrentSetTowerIter _tmp4_;
	GeeConcurrentSetTowerIter _tmp5_ = {0};
	GeeConcurrentSetTower* _tmp6_;
	g_return_val_if_fail (cset != NULL, NULL);
	g_return_val_if_fail (prev != NULL, NULL);
	g_return_val_if_fail (curr != NULL, NULL);
	self = (GeeConcurrentSetIterator*) g_object_new (object_type, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = curr;
	_tmp1_ = _gee_concurrent_set_tower_ref0 (_tmp0_);
	_gee_concurrent_set_tower_unref0 (self->priv->_curr);
	self->priv->_curr = _tmp1_;
	_tmp2_ = cset;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->priv->_set);
	self->priv->_set = _tmp3_;
	_tmp4_ = *prev;
	gee_concurrent_set_tower_iter_copy (&_tmp4_, &_tmp5_);
	gee_concurrent_set_tower_iter_destroy (&self->priv->_prev);
	self->priv->_prev = _tmp5_;
	_tmp6_ = self->priv->_curr;
	_vala_assert (_tmp6_ != NULL, "_curr != null");
	return self;
}


static GeeConcurrentSetIterator* gee_concurrent_set_iterator_new_point_at (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr) {
	return gee_concurrent_set_iterator_construct_point_at (GEE_CONCURRENT_SET_TYPE_ITERATOR, g_type, g_dup_func, g_destroy_func, cset, prev, curr);
}


static gboolean gee_concurrent_set_iterator_real_foreach (GeeTraversable* base, GeeForallFunc f, void* f_target) {
	GeeConcurrentSetIterator * self;
	gboolean result = FALSE;
	GeeConcurrentSetTower* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeHazardPointerContext* ctx;
	gboolean _tmp2_ = FALSE;
	GeeConcurrentSetTowerIter _tmp3_;
	GeeConcurrentSetTower* _tmp4_;
	gboolean _tmp6_;
	GeeConcurrentSetTowerIter _tmp13_;
	GeeConcurrentSetTower* _tmp14_;
	GeeConcurrentSetTower* _tmp15_;
	GeeConcurrentSetTower* new_prev;
	GeeConcurrentSetTower* _tmp16_;
	GeeConcurrentSetTower* _tmp17_;
	GeeConcurrentSetTower* new_curr;
	GeeConcurrentSetTower* _tmp47_;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = self->priv->_curr;
	_vala_assert (_tmp0_ != NULL, "_curr != null");
	_tmp1_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp1_;
	_tmp3_ = self->priv->_prev;
	_tmp4_ = _tmp3_._iter[0];
	if (_tmp4_ != NULL) {
		gboolean _tmp5_;
		_tmp5_ = self->priv->_removed;
		_tmp2_ = !_tmp5_;
	} else {
		_tmp2_ = FALSE;
	}
	_tmp6_ = _tmp2_;
	if (_tmp6_) {
		GeeForallFunc _tmp7_;
		void* _tmp7__target;
		GeeConcurrentSetTower* _tmp8_;
		gconstpointer _tmp9_;
		gpointer _tmp10_;
		gboolean _tmp11_ = FALSE;
		_tmp7_ = f;
		_tmp7__target = f_target;
		_tmp8_ = self->priv->_curr;
		_tmp9_ = _tmp8_->_data;
		_tmp10_ = ((_tmp9_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp9_) : ((gpointer) _tmp9_);
		_tmp11_ = _tmp7_ (_tmp10_, _tmp7__target);
		if (!_tmp11_) {
			GeeConcurrentSetTower* _tmp12_;
			_tmp12_ = self->priv->_curr;
			_vala_assert (_tmp12_ != NULL, "_curr != null");
			result = FALSE;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
	}
	_tmp13_ = self->priv->_prev;
	_tmp14_ = _tmp13_._iter[0];
	_tmp15_ = _gee_concurrent_set_tower_ref0 (_tmp14_);
	new_prev = _tmp15_;
	_tmp16_ = self->priv->_curr;
	_tmp17_ = _gee_concurrent_set_tower_ref0 (_tmp16_);
	new_curr = _tmp17_;
	while (TRUE) {
		GeeConcurrentSet* _tmp18_;
		GCompareDataFunc _tmp19_;
		void* _tmp19__target;
		gboolean _tmp20_ = FALSE;
		GeeConcurrentSetTower* _tmp21_;
		gboolean _tmp22_;
		GeeConcurrentSetTower* _tmp39_;
		GeeConcurrentSetTower* _tmp40_;
		GeeForallFunc _tmp41_;
		void* _tmp41__target;
		GeeConcurrentSetTower* _tmp42_;
		gconstpointer _tmp43_;
		gpointer _tmp44_;
		gboolean _tmp45_ = FALSE;
		_tmp18_ = self->priv->_set;
		_tmp19_ = _tmp18_->priv->_cmp;
		_tmp19__target = _tmp18_->priv->_cmp_target;
		_tmp20_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp19_, _tmp19__target, &new_prev, &new_curr, (guint8) 0, FALSE);
		if (!_tmp20_) {
			break;
		}
		_tmp21_ = self->priv->_curr;
		_vala_assert (_tmp21_ != NULL, "_curr != null");
		_tmp22_ = self->priv->_removed;
		if (!_tmp22_) {
			GeeConcurrentSetTower* _tmp23_;
			GeeConcurrentSetTower* _tmp24_;
			GeeConcurrentSetTower* _tmp25_;
			GeeConcurrentSetTowerIter _tmp26_;
			GeeConcurrentSetTower* _tmp27_;
			gint _tmp28_ = 0;
			gint prev_height;
			_tmp23_ = new_prev;
			_tmp24_ = _gee_concurrent_set_tower_ref0 (_tmp23_);
			_gee_concurrent_set_tower_unref0 (self->priv->_prev._iter[0]);
			self->priv->_prev._iter[0] = _tmp24_;
			_tmp25_ = self->priv->_prev._iter[0];
			_tmp26_ = self->priv->_prev;
			_tmp27_ = _tmp26_._iter[0];
			_tmp28_ = gee_concurrent_set_tower_get_height (_tmp27_);
			prev_height = _tmp28_;
			{
				gint i;
				i = 1;
				{
					gboolean _tmp29_;
					_tmp29_ = TRUE;
					while (TRUE) {
						gboolean _tmp30_;
						gint _tmp32_;
						gint _tmp33_;
						gint _tmp34_;
						GeeConcurrentSetTowerIter _tmp35_;
						GeeConcurrentSetTower* _tmp36_;
						GeeConcurrentSetTower* _tmp37_;
						GeeConcurrentSetTower* _tmp38_;
						_tmp30_ = _tmp29_;
						if (!_tmp30_) {
							gint _tmp31_;
							_tmp31_ = i;
							i = _tmp31_ + 1;
						}
						_tmp29_ = FALSE;
						_tmp32_ = i;
						_tmp33_ = prev_height;
						if (!(_tmp32_ < _tmp33_)) {
							break;
						}
						_tmp34_ = i;
						_tmp35_ = self->priv->_prev;
						_tmp36_ = _tmp35_._iter[0];
						_tmp37_ = _gee_concurrent_set_tower_ref0 (_tmp36_);
						_gee_concurrent_set_tower_unref0 (self->priv->_prev._iter[_tmp34_]);
						self->priv->_prev._iter[_tmp34_] = _tmp37_;
						_tmp38_ = self->priv->_prev._iter[_tmp34_];
					}
				}
			}
		}
		_tmp39_ = new_curr;
		_tmp40_ = _gee_concurrent_set_tower_ref0 (_tmp39_);
		_gee_concurrent_set_tower_unref0 (self->priv->_curr);
		self->priv->_curr = _tmp40_;
		self->priv->_removed = FALSE;
		_tmp41_ = f;
		_tmp41__target = f_target;
		_tmp42_ = self->priv->_curr;
		_tmp43_ = _tmp42_->_data;
		_tmp44_ = ((_tmp43_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp43_) : ((gpointer) _tmp43_);
		_tmp45_ = _tmp41_ (_tmp44_, _tmp41__target);
		if (!_tmp45_) {
			GeeConcurrentSetTower* _tmp46_;
			_tmp46_ = self->priv->_curr;
			_vala_assert (_tmp46_ != NULL, "_curr != null");
			result = FALSE;
			_gee_concurrent_set_tower_unref0 (new_curr);
			_gee_concurrent_set_tower_unref0 (new_prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
	}
	_tmp47_ = self->priv->_curr;
	_vala_assert (_tmp47_ != NULL, "_curr != null");
	result = TRUE;
	_gee_concurrent_set_tower_unref0 (new_curr);
	_gee_concurrent_set_tower_unref0 (new_prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_iterator_real_next (GeeIterator* base) {
	GeeConcurrentSetIterator * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTowerIter _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	GeeConcurrentSetTower* new_prev;
	GeeConcurrentSetTower* _tmp4_;
	GeeConcurrentSetTower* _tmp5_;
	GeeConcurrentSetTower* new_curr;
	GeeConcurrentSet* _tmp6_;
	GCompareDataFunc _tmp7_;
	void* _tmp7__target;
	gboolean _tmp8_ = FALSE;
	gboolean success;
	gboolean _tmp9_;
	GeeConcurrentSetTower* _tmp27_;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_prev;
	_tmp2_ = _tmp1_._iter[0];
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	new_prev = _tmp3_;
	_tmp4_ = self->priv->_curr;
	_tmp5_ = _gee_concurrent_set_tower_ref0 (_tmp4_);
	new_curr = _tmp5_;
	_tmp6_ = self->priv->_set;
	_tmp7_ = _tmp6_->priv->_cmp;
	_tmp7__target = _tmp6_->priv->_cmp_target;
	_tmp8_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp7_, _tmp7__target, &new_prev, &new_curr, (guint8) 0, FALSE);
	success = _tmp8_;
	_tmp9_ = success;
	if (_tmp9_) {
		gboolean _tmp10_;
		GeeConcurrentSetTower* _tmp26_;
		_tmp10_ = self->priv->_removed;
		if (!_tmp10_) {
			GeeConcurrentSetTower* _tmp11_;
			GeeConcurrentSetTower* _tmp12_;
			GeeConcurrentSetTowerIter _tmp13_;
			GeeConcurrentSetTower* _tmp14_;
			gint _tmp15_ = 0;
			gint prev_height;
			_tmp11_ = new_prev;
			new_prev = NULL;
			_gee_concurrent_set_tower_unref0 (self->priv->_prev._iter[0]);
			self->priv->_prev._iter[0] = _tmp11_;
			_tmp12_ = self->priv->_prev._iter[0];
			_tmp13_ = self->priv->_prev;
			_tmp14_ = _tmp13_._iter[0];
			_tmp15_ = gee_concurrent_set_tower_get_height (_tmp14_);
			prev_height = _tmp15_;
			{
				gint i;
				i = 1;
				{
					gboolean _tmp16_;
					_tmp16_ = TRUE;
					while (TRUE) {
						gboolean _tmp17_;
						gint _tmp19_;
						gint _tmp20_;
						gint _tmp21_;
						GeeConcurrentSetTowerIter _tmp22_;
						GeeConcurrentSetTower* _tmp23_;
						GeeConcurrentSetTower* _tmp24_;
						GeeConcurrentSetTower* _tmp25_;
						_tmp17_ = _tmp16_;
						if (!_tmp17_) {
							gint _tmp18_;
							_tmp18_ = i;
							i = _tmp18_ + 1;
						}
						_tmp16_ = FALSE;
						_tmp19_ = i;
						_tmp20_ = prev_height;
						if (!(_tmp19_ < _tmp20_)) {
							break;
						}
						_tmp21_ = i;
						_tmp22_ = self->priv->_prev;
						_tmp23_ = _tmp22_._iter[0];
						_tmp24_ = _gee_concurrent_set_tower_ref0 (_tmp23_);
						_gee_concurrent_set_tower_unref0 (self->priv->_prev._iter[_tmp21_]);
						self->priv->_prev._iter[_tmp21_] = _tmp24_;
						_tmp25_ = self->priv->_prev._iter[_tmp21_];
					}
				}
			}
		}
		_tmp26_ = new_curr;
		new_curr = NULL;
		_gee_concurrent_set_tower_unref0 (self->priv->_curr);
		self->priv->_curr = _tmp26_;
		self->priv->_removed = FALSE;
	}
	_tmp27_ = self->priv->_curr;
	_vala_assert (_tmp27_ != NULL, "_curr != null");
	result = success;
	_gee_concurrent_set_tower_unref0 (new_curr);
	_gee_concurrent_set_tower_unref0 (new_prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_iterator_real_has_next (GeeIterator* base) {
	GeeConcurrentSetIterator * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTowerIter _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	GeeConcurrentSetTower* prev;
	GeeConcurrentSetTower* _tmp4_;
	GeeConcurrentSetTower* _tmp5_;
	GeeConcurrentSetTower* curr;
	GeeConcurrentSet* _tmp6_;
	GCompareDataFunc _tmp7_;
	void* _tmp7__target;
	gboolean _tmp8_ = FALSE;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_prev;
	_tmp2_ = _tmp1_._iter[0];
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	prev = _tmp3_;
	_tmp4_ = self->priv->_curr;
	_tmp5_ = _gee_concurrent_set_tower_ref0 (_tmp4_);
	curr = _tmp5_;
	_tmp6_ = self->priv->_set;
	_tmp7_ = _tmp6_->priv->_cmp;
	_tmp7__target = _tmp6_->priv->_cmp_target;
	_tmp8_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp7_, _tmp7__target, &prev, &curr, (guint8) 0, FALSE);
	result = _tmp8_;
	_gee_concurrent_set_tower_unref0 (curr);
	_gee_concurrent_set_tower_unref0 (prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gpointer gee_concurrent_set_iterator_real_get (GeeIterator* base) {
	GeeConcurrentSetIterator * self;
	gpointer result = NULL;
	gboolean _tmp0_;
	gboolean _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	gconstpointer _tmp3_;
	gpointer _tmp4_;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = gee_iterator_get_valid ((GeeIterator*) self);
	_tmp1_ = _tmp0_;
	_vala_assert (_tmp1_, "valid");
	_tmp2_ = self->priv->_curr;
	_tmp3_ = _tmp2_->_data;
	_tmp4_ = ((_tmp3_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp3_) : ((gpointer) _tmp3_);
	result = _tmp4_;
	return result;
}


static void gee_concurrent_set_iterator_real_remove (GeeIterator* base) {
	GeeConcurrentSetIterator * self;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	gboolean _tmp1_;
	gboolean _tmp2_;
	GeeConcurrentSet* _tmp3_;
	GCompareDataFunc _tmp4_;
	void* _tmp4__target;
	GeeConcurrentSetTower* _tmp5_;
	gboolean _tmp6_ = FALSE;
	self = (GeeConcurrentSetIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = gee_iterator_get_valid ((GeeIterator*) self);
	_tmp2_ = _tmp1_;
	_vala_assert (_tmp2_, "valid");
	_tmp3_ = self->priv->_set;
	_tmp4_ = _tmp3_->priv->_cmp;
	_tmp4__target = _tmp3_->priv->_cmp_target;
	_tmp5_ = self->priv->_curr;
	_tmp6_ = gee_concurrent_set_tower_remove (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_, _tmp4__target, &self->priv->_prev, _tmp5_);
	if (_tmp6_) {
		GeeConcurrentSet* _tmp7_;
		_tmp7_ = self->priv->_set;
		g_atomic_int_dec_and_test ((volatile gint *) (&_tmp7_->priv->_size));
	}
	self->priv->_removed = TRUE;
	_gee_hazard_pointer_context_free0 (ctx);
}


static gboolean gee_concurrent_set_iterator_real_get_valid (GeeIterator* base) {
	gboolean result;
	GeeConcurrentSetIterator* self;
	gboolean _tmp0_ = FALSE;
	GeeConcurrentSetTowerIter _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	gboolean _tmp4_;
	self = (GeeConcurrentSetIterator*) base;
	_tmp1_ = self->priv->_prev;
	_tmp2_ = _tmp1_._iter[0];
	if (_tmp2_ != NULL) {
		gboolean _tmp3_;
		_tmp3_ = self->priv->_removed;
		_tmp0_ = !_tmp3_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp4_ = _tmp0_;
	result = _tmp4_;
	return result;
}


static gboolean gee_concurrent_set_iterator_real_get_read_only (GeeIterator* base) {
	gboolean result;
	GeeConcurrentSetIterator* self;
	self = (GeeConcurrentSetIterator*) base;
	result = TRUE;
	return result;
}


static void gee_concurrent_set_iterator_class_init (GeeConcurrentSetIteratorClass * klass) {
	gee_concurrent_set_iterator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeConcurrentSetIteratorPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_concurrent_set_iterator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_concurrent_set_iterator_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_concurrent_set_iterator_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_ITERATOR_G_TYPE, g_param_spec_gtype ("g-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_ITERATOR_G_DUP_FUNC, g_param_spec_pointer ("g-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_ITERATOR_G_DESTROY_FUNC, g_param_spec_pointer ("g-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_ITERATOR_VALID, g_param_spec_boolean ("valid", "valid", "valid", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_ITERATOR_READ_ONLY, g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static GType gee_concurrent_set_iterator_gee_traversable_get_g_type (GeeConcurrentSetIterator* self) {
	return self->priv->g_type;
}


static GBoxedCopyFunc gee_concurrent_set_iterator_gee_traversable_get_g_dup_func (GeeConcurrentSetIterator* self) {
	return self->priv->g_dup_func;
}


static GDestroyNotify gee_concurrent_set_iterator_gee_traversable_get_g_destroy_func (GeeConcurrentSetIterator* self) {
	return self->priv->g_destroy_func;
}


static void gee_concurrent_set_iterator_gee_traversable_interface_init (GeeTraversableIface * iface) {
	gee_concurrent_set_iterator_gee_traversable_parent_iface = g_type_interface_peek_parent (iface);
	iface->foreach = (gboolean (*)(GeeTraversable*, GeeForallFunc, void*)) gee_concurrent_set_iterator_real_foreach;
	iface->get_g_type = (GType(*)(GeeTraversable*)) gee_concurrent_set_iterator_gee_traversable_get_g_type;
	iface->get_g_dup_func = (GBoxedCopyFunc(*)(GeeTraversable*)) gee_concurrent_set_iterator_gee_traversable_get_g_dup_func;
	iface->get_g_destroy_func = (GDestroyNotify(*)(GeeTraversable*)) gee_concurrent_set_iterator_gee_traversable_get_g_destroy_func;
}


static void gee_concurrent_set_iterator_gee_iterator_interface_init (GeeIteratorIface * iface) {
	gee_concurrent_set_iterator_gee_iterator_parent_iface = g_type_interface_peek_parent (iface);
	iface->next = (gboolean (*)(GeeIterator*)) gee_concurrent_set_iterator_real_next;
	iface->has_next = (gboolean (*)(GeeIterator*)) gee_concurrent_set_iterator_real_has_next;
	iface->get = (gpointer (*)(GeeIterator*)) gee_concurrent_set_iterator_real_get;
	iface->remove = (void (*)(GeeIterator*)) gee_concurrent_set_iterator_real_remove;
	iface->get_valid = gee_concurrent_set_iterator_real_get_valid;
	iface->get_read_only = gee_concurrent_set_iterator_real_get_read_only;
}


static void gee_concurrent_set_iterator_instance_init (GeeConcurrentSetIterator * self) {
	self->priv = GEE_CONCURRENT_SET_ITERATOR_GET_PRIVATE (self);
	self->priv->_removed = FALSE;
}


static void gee_concurrent_set_iterator_finalize (GObject* obj) {
	GeeConcurrentSetIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIterator);
	_g_object_unref0 (self->priv->_set);
	gee_concurrent_set_tower_iter_destroy (&self->priv->_prev);
	_gee_concurrent_set_tower_unref0 (self->priv->_curr);
	G_OBJECT_CLASS (gee_concurrent_set_iterator_parent_class)->finalize (obj);
}


static GType gee_concurrent_set_iterator_get_type (void) {
	static volatile gsize gee_concurrent_set_iterator_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_iterator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSetIterator), 0, (GInstanceInitFunc) gee_concurrent_set_iterator_instance_init, NULL };
		static const GInterfaceInfo gee_traversable_info = { (GInterfaceInitFunc) gee_concurrent_set_iterator_gee_traversable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		static const GInterfaceInfo gee_iterator_info = { (GInterfaceInitFunc) gee_concurrent_set_iterator_gee_iterator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gee_concurrent_set_iterator_type_id;
		gee_concurrent_set_iterator_type_id = g_type_register_static (G_TYPE_OBJECT, "GeeConcurrentSetIterator", &g_define_type_info, 0);
		g_type_add_interface_static (gee_concurrent_set_iterator_type_id, GEE_TYPE_TRAVERSABLE, &gee_traversable_info);
		g_type_add_interface_static (gee_concurrent_set_iterator_type_id, GEE_TYPE_ITERATOR, &gee_iterator_info);
		g_once_init_leave (&gee_concurrent_set_iterator_type_id__volatile, gee_concurrent_set_iterator_type_id);
	}
	return gee_concurrent_set_iterator_type_id__volatile;
}


static void _vala_gee_concurrent_set_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeConcurrentSetIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIterator);
	switch (property_id) {
		case GEE_CONCURRENT_SET_ITERATOR_VALID:
		g_value_set_boolean (value, gee_iterator_get_valid ((GeeIterator*) self));
		break;
		case GEE_CONCURRENT_SET_ITERATOR_READ_ONLY:
		g_value_set_boolean (value, gee_iterator_get_read_only ((GeeIterator*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_concurrent_set_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeConcurrentSetIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_ITERATOR, GeeConcurrentSetIterator);
	switch (property_id) {
		case GEE_CONCURRENT_SET_ITERATOR_G_TYPE:
		self->priv->g_type = g_value_get_gtype (value);
		break;
		case GEE_CONCURRENT_SET_ITERATOR_G_DUP_FUNC:
		self->priv->g_dup_func = g_value_get_pointer (value);
		break;
		case GEE_CONCURRENT_SET_ITERATOR_G_DESTROY_FUNC:
		self->priv->g_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static gpointer _gee_concurrent_set_range_ref0 (gpointer self) {
	return self ? gee_concurrent_set_range_ref (self) : NULL;
}


static GeeConcurrentSetSubSet* gee_concurrent_set_sub_set_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range) {
	GeeConcurrentSetSubSet * self = NULL;
	GeeConcurrentSetRange* _tmp0_;
	GeeConcurrentSetRange* _tmp1_;
	g_return_val_if_fail (range != NULL, NULL);
	self = (GeeConcurrentSetSubSet*) gee_abstract_sorted_set_construct (object_type, g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = range;
	_tmp1_ = _gee_concurrent_set_range_ref0 (_tmp0_);
	_gee_concurrent_set_range_unref0 (self->priv->_range);
	self->priv->_range = _tmp1_;
	return self;
}


static GeeConcurrentSetSubSet* gee_concurrent_set_sub_set_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range) {
	return gee_concurrent_set_sub_set_construct (GEE_CONCURRENT_SET_TYPE_SUB_SET, g_type, g_dup_func, g_destroy_func, range);
}


static GeeIterator* gee_concurrent_set_sub_set_real_iterator (GeeAbstractCollection* base) {
	GeeConcurrentSetSubSet * self;
	GeeIterator* result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetSubIterator* _tmp2_;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	_tmp2_ = gee_concurrent_set_sub_iterator_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_);
	result = (GeeIterator*) _tmp2_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_sub_set_real_contains (GeeAbstractCollection* base, gconstpointer item) {
	GeeConcurrentSetSubSet * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetRange* _tmp1_;
	gconstpointer _tmp2_;
	gboolean _tmp3_ = FALSE;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetRange* _tmp4_;
	GeeConcurrentSetTowerIter _tmp5_ = {0};
	GeeConcurrentSetRange* _tmp6_;
	GeeConcurrentSet* _tmp7_;
	GCompareDataFunc _tmp8_;
	void* _tmp8__target;
	gconstpointer _tmp9_;
	gboolean _tmp10_ = FALSE;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	_tmp2_ = item;
	_tmp3_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, _tmp2_);
	if (!_tmp3_) {
		result = FALSE;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp4_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_, NULL, &_tmp5_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp5_;
	_tmp6_ = self->priv->_range;
	_tmp7_ = _tmp6_->_set;
	_tmp8_ = _tmp7_->priv->_cmp;
	_tmp8__target = _tmp7_->priv->_cmp_target;
	_tmp9_ = item;
	_tmp10_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp8_, _tmp8__target, _tmp9_, &prev, NULL, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	result = _tmp10_;
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_sub_set_real_add (GeeAbstractCollection* base, gconstpointer key) {
	GeeConcurrentSetSubSet * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetRange* _tmp1_;
	gconstpointer _tmp2_;
	gboolean _tmp3_ = FALSE;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetRange* _tmp4_;
	GeeConcurrentSetTowerIter _tmp5_ = {0};
	GPrivate* _tmp6_;
	void* _tmp7_ = NULL;
	GRand* rnd;
	GRand* _tmp8_;
	GRand* _tmp12_;
	gint32 _tmp13_;
	gint32 _tmp14_ = 0;
	guint32 rand_int;
	guint32 _tmp15_;
	gint _tmp16_ = 0;
	guint8 height;
	GeeConcurrentSetRange* _tmp17_;
	GeeConcurrentSet* _tmp18_;
	GCompareDataFunc _tmp19_;
	void* _tmp19__target;
	gconstpointer _tmp20_;
	guint8 _tmp21_;
	gboolean _tmp22_ = FALSE;
	GeeConcurrentSetRange* _tmp34_;
	GeeConcurrentSet* _tmp35_;
	GCompareDataFunc _tmp36_;
	void* _tmp36__target;
	gconstpointer _tmp37_;
	guint8 _tmp38_;
	GeeConcurrentSetTower* _tmp39_ = NULL;
	GeeConcurrentSetTower* _result_;
	GeeConcurrentSetTower* _tmp40_;
	GeeConcurrentSetTower* _tmp43_;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	_tmp2_ = key;
	_tmp3_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, _tmp2_);
	if (!_tmp3_) {
		result = FALSE;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp4_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_, NULL, &_tmp5_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp5_;
	_tmp6_ = gee_concurrent_set_rand;
	_tmp7_ = g_private_get (_tmp6_);
	rnd = _tmp7_;
	_tmp8_ = rnd;
	if (_tmp8_ == NULL) {
		GPrivate* _tmp9_;
		GRand* _tmp10_;
		GRand* _tmp11_;
		_tmp9_ = gee_concurrent_set_rand;
		_tmp10_ = g_rand_new ();
		rnd = _tmp10_;
		_tmp11_ = rnd;
		g_private_set (_tmp9_, _tmp11_);
	}
	_tmp12_ = rnd;
	_tmp13_ = G_MAXINT32;
	_tmp14_ = g_rand_int_range (_tmp12_, (gint32) 0, _tmp13_);
	rand_int = (guint32) _tmp14_;
	_tmp15_ = rand_int;
	_tmp16_ = g_bit_nth_lsf ((gulong) (~_tmp15_), -1);
	height = (guint8) (1 + ((guint8) _tmp16_));
	_tmp17_ = self->priv->_range;
	_tmp18_ = _tmp17_->_set;
	_tmp19_ = _tmp18_->priv->_cmp;
	_tmp19__target = _tmp18_->priv->_cmp_target;
	_tmp20_ = key;
	_tmp21_ = height;
	_tmp22_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp19_, _tmp19__target, _tmp20_, &prev, NULL, (guint8) (_tmp21_ - 1), (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	if (_tmp22_) {
		result = FALSE;
		gee_concurrent_set_tower_iter_destroy (&prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	{
		guint8 _tmp23_;
		gint i;
		_tmp23_ = height;
		i = _tmp23_ - 2;
		{
			gboolean _tmp24_;
			_tmp24_ = TRUE;
			while (TRUE) {
				gboolean _tmp25_;
				gint _tmp27_;
				gint _tmp28_;
				GeeConcurrentSetTowerIter _tmp29_;
				guint8 _tmp30_;
				GeeConcurrentSetTower* _tmp31_;
				GeeConcurrentSetTower* _tmp32_;
				GeeConcurrentSetTower* _tmp33_;
				_tmp25_ = _tmp24_;
				if (!_tmp25_) {
					gint _tmp26_;
					_tmp26_ = i;
					i = _tmp26_ - 1;
				}
				_tmp24_ = FALSE;
				_tmp27_ = i;
				if (!(_tmp27_ >= 0)) {
					break;
				}
				_tmp28_ = i;
				_tmp29_ = prev;
				_tmp30_ = height;
				_tmp31_ = _tmp29_._iter[_tmp30_ - 1];
				_tmp32_ = _gee_concurrent_set_tower_ref0 (_tmp31_);
				_gee_concurrent_set_tower_unref0 (prev._iter[_tmp28_]);
				prev._iter[_tmp28_] = _tmp32_;
				_tmp33_ = prev._iter[_tmp28_];
			}
		}
	}
	_tmp34_ = self->priv->_range;
	_tmp35_ = _tmp34_->_set;
	_tmp36_ = _tmp35_->priv->_cmp;
	_tmp36__target = _tmp35_->priv->_cmp_target;
	_tmp37_ = key;
	_tmp38_ = height;
	_tmp39_ = gee_concurrent_set_tower_insert (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp36_, _tmp36__target, &prev, _tmp37_, (guint8) (_tmp38_ - 1));
	_result_ = _tmp39_;
	_tmp40_ = _result_;
	if (_tmp40_ != NULL) {
		GeeConcurrentSetRange* _tmp41_;
		GeeConcurrentSet* _tmp42_;
		_tmp41_ = self->priv->_range;
		_tmp42_ = _tmp41_->_set;
		g_atomic_int_inc ((volatile gint *) (&_tmp42_->priv->_size));
	}
	_tmp43_ = _result_;
	result = _tmp43_ != NULL;
	_gee_concurrent_set_tower_unref0 (_result_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_sub_set_real_remove (GeeAbstractCollection* base, gconstpointer key) {
	GeeConcurrentSetSubSet * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetRange* _tmp1_;
	gconstpointer _tmp2_;
	gboolean _tmp3_ = FALSE;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetRange* _tmp4_;
	GeeConcurrentSetTowerIter _tmp5_ = {0};
	GeeConcurrentSetRange* _tmp6_;
	GeeConcurrentSet* _tmp7_;
	GCompareDataFunc _tmp8_;
	void* _tmp8__target;
	gconstpointer _tmp9_;
	gboolean _tmp10_ = FALSE;
	gboolean _result_;
	gboolean _tmp11_;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	_tmp2_ = key;
	_tmp3_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, _tmp2_);
	if (!_tmp3_) {
		result = FALSE;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp4_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_, NULL, &_tmp5_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp5_;
	_tmp6_ = self->priv->_range;
	_tmp7_ = _tmp6_->_set;
	_tmp8_ = _tmp7_->priv->_cmp;
	_tmp8__target = _tmp7_->priv->_cmp_target;
	_tmp9_ = key;
	_tmp10_ = gee_concurrent_set_tower_remove_key (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp8_, _tmp8__target, &prev, _tmp9_, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	_result_ = _tmp10_;
	_tmp11_ = _result_;
	if (_tmp11_) {
		GeeConcurrentSetRange* _tmp12_;
		GeeConcurrentSet* _tmp13_;
		_tmp12_ = self->priv->_range;
		_tmp13_ = _tmp12_->_set;
		g_atomic_int_dec_and_test ((volatile gint *) (&_tmp13_->priv->_size));
	}
	result = _result_;
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static void gee_concurrent_set_sub_set_real_clear (GeeAbstractCollection* base) {
	GeeConcurrentSetSubSet * self;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetTower* first = NULL;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetTowerIter _tmp3_ = {0};
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, &_tmp2_, &_tmp3_);
	_gee_concurrent_set_tower_unref0 (first);
	first = _tmp2_;
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp3_;
	while (TRUE) {
		GeeConcurrentSetTower* _tmp4_;
		GeeConcurrentSetRange* _tmp5_;
		GeeConcurrentSet* _tmp6_;
		GCompareDataFunc _tmp7_;
		void* _tmp7__target;
		GeeConcurrentSetTower* _tmp8_;
		GeeConcurrentSetRange* _tmp9_;
		GeeConcurrentSetTower* _tmp10_ = NULL;
		GeeConcurrentSetTowerIter _tmp11_ = {0};
		_tmp4_ = first;
		if (!(_tmp4_ != NULL)) {
			break;
		}
		_tmp5_ = self->priv->_range;
		_tmp6_ = _tmp5_->_set;
		_tmp7_ = _tmp6_->priv->_cmp;
		_tmp7__target = _tmp6_->priv->_cmp_target;
		_tmp8_ = first;
		gee_concurrent_set_tower_remove (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp7_, _tmp7__target, &prev, _tmp8_);
		_tmp9_ = self->priv->_range;
		gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp9_, &_tmp10_, &_tmp11_);
		_gee_concurrent_set_tower_unref0 (first);
		first = _tmp10_;
		gee_concurrent_set_tower_iter_destroy (&prev);
		prev = _tmp11_;
	}
	_gee_concurrent_set_tower_unref0 (first);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_sub_set_real_first (GeeAbstractSortedSet* base) {
	GeeConcurrentSetSubSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTower* first = NULL;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_;
	GeeConcurrentSetTower* _tmp4_;
	gconstpointer _tmp5_;
	gpointer _tmp6_;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, &_tmp2_, NULL);
	_gee_concurrent_set_tower_unref0 (first);
	first = _tmp2_;
	_tmp3_ = first;
	if (_tmp3_ == NULL) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (first);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp4_ = first;
	_tmp5_ = _tmp4_->_data;
	_tmp6_ = ((_tmp5_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp5_) : ((gpointer) _tmp5_);
	result = _tmp6_;
	_gee_concurrent_set_tower_unref0 (first);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gpointer gee_concurrent_set_sub_set_real_last (GeeAbstractSortedSet* base) {
	GeeConcurrentSetSubSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetTowerIter _tmp2_ = {0};
	GeeConcurrentSetTower* curr;
	GeeConcurrentSetTower* _tmp34_;
	GeeConcurrentSetTower* _tmp35_;
	gconstpointer _tmp36_;
	gpointer _tmp37_;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, NULL, &_tmp2_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp2_;
	curr = NULL;
	{
		gint i;
		i = GEE_CONCURRENT_SET__MAX_HEIGHT - 1;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_;
				gint _tmp6_;
				GeeConcurrentSetTower* _tmp7_;
				gboolean improved;
				gboolean _tmp24_ = FALSE;
				gboolean _tmp25_;
				gboolean _tmp27_;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					gint _tmp5_;
					_tmp5_ = i;
					i = _tmp5_ - 1;
				}
				_tmp3_ = FALSE;
				_tmp6_ = i;
				if (!(_tmp6_ >= 0)) {
					break;
				}
				_tmp7_ = curr;
				if (_tmp7_ == NULL) {
					GeeConcurrentSetTowerIter _tmp8_;
					gint _tmp9_;
					GeeConcurrentSetTower* _tmp10_;
					gint _tmp11_;
					GeeConcurrentSetTower* _tmp12_ = NULL;
					gboolean _tmp13_ = FALSE;
					GeeConcurrentSetTower* _tmp14_;
					gboolean _tmp19_;
					_tmp8_ = prev;
					_tmp9_ = i;
					_tmp10_ = _tmp8_._iter[_tmp9_];
					_tmp11_ = i;
					_tmp12_ = gee_concurrent_set_tower_get_next (_tmp10_, (guint8) _tmp11_);
					_gee_concurrent_set_tower_unref0 (curr);
					curr = _tmp12_;
					_tmp14_ = curr;
					if (_tmp14_ == NULL) {
						_tmp13_ = TRUE;
					} else {
						GeeConcurrentSetRange* _tmp15_;
						GeeConcurrentSetTower* _tmp16_;
						gconstpointer _tmp17_;
						gboolean _tmp18_ = FALSE;
						_tmp15_ = self->priv->_range;
						_tmp16_ = curr;
						_tmp17_ = _tmp16_->_data;
						_tmp18_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp15_, _tmp17_);
						_tmp13_ = !_tmp18_;
					}
					_tmp19_ = _tmp13_;
					if (_tmp19_) {
						_gee_concurrent_set_tower_unref0 (curr);
						curr = NULL;
						continue;
					}
				}
				improved = FALSE;
				while (TRUE) {
					GeeConcurrentSetRange* _tmp20_;
					gint _tmp21_;
					gint _tmp22_;
					gboolean _tmp23_ = FALSE;
					_tmp20_ = self->priv->_range;
					_tmp21_ = i;
					_tmp22_ = i;
					_tmp23_ = gee_concurrent_set_range_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp20_, &prev._iter[_tmp21_], &curr, (guint8) _tmp22_);
					if (!_tmp23_) {
						break;
					}
					improved = TRUE;
				}
				_tmp25_ = improved;
				if (_tmp25_) {
					gint _tmp26_;
					_tmp26_ = i;
					_tmp24_ = _tmp26_ > 0;
				} else {
					_tmp24_ = FALSE;
				}
				_tmp27_ = _tmp24_;
				if (_tmp27_) {
					gint _tmp28_;
					GeeConcurrentSetTowerIter _tmp29_;
					gint _tmp30_;
					GeeConcurrentSetTower* _tmp31_;
					GeeConcurrentSetTower* _tmp32_;
					GeeConcurrentSetTower* _tmp33_;
					_tmp28_ = i;
					_tmp29_ = prev;
					_tmp30_ = i;
					_tmp31_ = _tmp29_._iter[_tmp30_];
					_tmp32_ = _gee_concurrent_set_tower_ref0 (_tmp31_);
					_gee_concurrent_set_tower_unref0 (prev._iter[_tmp28_ - 1]);
					prev._iter[_tmp28_ - 1] = _tmp32_;
					_tmp33_ = prev._iter[_tmp28_ - 1];
				}
			}
		}
	}
	_tmp34_ = curr;
	if (_tmp34_ == NULL) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (curr);
		gee_concurrent_set_tower_iter_destroy (&prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp35_ = curr;
	_tmp36_ = _tmp35_->_data;
	_tmp37_ = ((_tmp36_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp36_) : ((gpointer) _tmp36_);
	result = _tmp37_;
	_gee_concurrent_set_tower_unref0 (curr);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeIterator* gee_concurrent_set_sub_set_real_iterator_at (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSetSubSet * self;
	GeeIterator* result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetRange* _tmp1_;
	gconstpointer _tmp2_;
	gboolean _tmp3_ = FALSE;
	GeeConcurrentSetTowerIter prev = {0};
	GeeConcurrentSetTowerIter next = {0};
	GeeConcurrentSetRange* _tmp4_;
	GeeConcurrentSetTowerIter _tmp5_ = {0};
	GeeConcurrentSetRange* _tmp6_;
	GeeConcurrentSet* _tmp7_;
	GCompareDataFunc _tmp8_;
	void* _tmp8__target;
	gconstpointer _tmp9_;
	GeeConcurrentSetTowerIter _tmp10_ = {0};
	gboolean _tmp11_ = FALSE;
	GeeConcurrentSetRange* _tmp12_;
	GeeConcurrentSetTowerIter _tmp13_;
	GeeConcurrentSetTower* _tmp14_;
	GeeConcurrentSetTower* _tmp15_;
	GeeConcurrentSetSubIterator* _tmp16_;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	_tmp2_ = element;
	_tmp3_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, _tmp2_);
	if (!_tmp3_) {
		result = NULL;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp4_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_, NULL, &_tmp5_);
	gee_concurrent_set_tower_iter_destroy (&prev);
	prev = _tmp5_;
	_tmp6_ = self->priv->_range;
	_tmp7_ = _tmp6_->_set;
	_tmp8_ = _tmp7_->priv->_cmp;
	_tmp8__target = _tmp7_->priv->_cmp_target;
	_tmp9_ = element;
	_tmp11_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp8_, _tmp8__target, _tmp9_, &prev, &_tmp10_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
	gee_concurrent_set_tower_iter_destroy (&next);
	next = _tmp10_;
	if (!_tmp11_) {
		result = NULL;
		gee_concurrent_set_tower_iter_destroy (&next);
		gee_concurrent_set_tower_iter_destroy (&prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp12_ = self->priv->_range;
	_tmp13_ = next;
	_tmp14_ = _tmp13_._iter[0];
	_tmp15_ = _gee_concurrent_set_tower_ref0 (_tmp14_);
	_tmp16_ = gee_concurrent_set_sub_iterator_new_point_at (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp12_, &prev, _tmp15_);
	result = (GeeIterator*) _tmp16_;
	gee_concurrent_set_tower_iter_destroy (&next);
	gee_concurrent_set_tower_iter_destroy (&prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gpointer gee_concurrent_set_sub_set_real_lower (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSetSubSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetRange* _tmp1_;
	gconstpointer _tmp2_;
	gint _tmp3_ = 0;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	_tmp2_ = element;
	_tmp3_ = gee_concurrent_set_range_cmp (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, _tmp2_);
	switch (_tmp3_) {
		case GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE:
		case GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY:
		{
			result = NULL;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE:
		{
			GeeConcurrentSetTowerIter prev = {0};
			GeeConcurrentSetRange* _tmp4_;
			GeeConcurrentSetTowerIter _tmp5_ = {0};
			GeeConcurrentSetRange* _tmp6_;
			GeeConcurrentSet* _tmp7_;
			GCompareDataFunc _tmp8_;
			void* _tmp8__target;
			gconstpointer _tmp9_;
			gboolean _tmp10_ = FALSE;
			GeeConcurrentSetTowerIter _tmp11_;
			GeeConcurrentSetTower* _tmp12_;
			GeeConcurrentSetRange* _tmp13_;
			GeeConcurrentSet* _tmp14_;
			GeeConcurrentSetTower* _tmp15_;
			gboolean _tmp21_;
			GeeConcurrentSetTowerIter _tmp22_;
			GeeConcurrentSetTower* _tmp23_;
			gconstpointer _tmp24_;
			gpointer _tmp25_;
			_tmp4_ = self->priv->_range;
			gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_, NULL, &_tmp5_);
			gee_concurrent_set_tower_iter_destroy (&prev);
			prev = _tmp5_;
			_tmp6_ = self->priv->_range;
			_tmp7_ = _tmp6_->_set;
			_tmp8_ = _tmp7_->priv->_cmp;
			_tmp8__target = _tmp7_->priv->_cmp_target;
			_tmp9_ = element;
			gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp8_, _tmp8__target, _tmp9_, &prev, NULL, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
			_tmp11_ = prev;
			_tmp12_ = _tmp11_._iter[0];
			_tmp13_ = self->priv->_range;
			_tmp14_ = _tmp13_->_set;
			_tmp15_ = _tmp14_->priv->_head;
			if (_tmp12_ == _tmp15_) {
				_tmp10_ = TRUE;
			} else {
				GeeConcurrentSetRange* _tmp16_;
				GeeConcurrentSetTowerIter _tmp17_;
				GeeConcurrentSetTower* _tmp18_;
				gconstpointer _tmp19_;
				gboolean _tmp20_ = FALSE;
				_tmp16_ = self->priv->_range;
				_tmp17_ = prev;
				_tmp18_ = _tmp17_._iter[0];
				_tmp19_ = _tmp18_->_data;
				_tmp20_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp16_, _tmp19_);
				_tmp10_ = !_tmp20_;
			}
			_tmp21_ = _tmp10_;
			if (_tmp21_) {
				result = NULL;
				gee_concurrent_set_tower_iter_destroy (&prev);
				_gee_hazard_pointer_context_free0 (ctx);
				return result;
			}
			_tmp22_ = prev;
			_tmp23_ = _tmp22_._iter[0];
			_tmp24_ = _tmp23_->_data;
			_tmp25_ = ((_tmp24_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp24_) : ((gpointer) _tmp24_);
			result = _tmp25_;
			gee_concurrent_set_tower_iter_destroy (&prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_AFTER:
		{
			gpointer _tmp26_ = NULL;
			_tmp26_ = gee_abstract_sorted_set_last ((GeeAbstractSortedSet*) self);
			result = _tmp26_;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_sub_set_real_higher (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSetSubSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetRange* _tmp1_;
	gconstpointer _tmp2_;
	gint _tmp3_ = 0;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	_tmp2_ = element;
	_tmp3_ = gee_concurrent_set_range_cmp (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, _tmp2_);
	switch (_tmp3_) {
		case GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE:
		{
			gpointer _tmp4_ = NULL;
			_tmp4_ = gee_abstract_sorted_set_first ((GeeAbstractSortedSet*) self);
			result = _tmp4_;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE:
		{
			GeeConcurrentSetTowerIter prev = {0};
			GeeConcurrentSetTowerIter curr = {0};
			GeeConcurrentSetRange* _tmp5_;
			GeeConcurrentSetTowerIter _tmp6_ = {0};
			GeeConcurrentSetRange* _tmp7_;
			GeeConcurrentSet* _tmp8_;
			GCompareDataFunc _tmp9_;
			void* _tmp9__target;
			gconstpointer _tmp10_;
			GeeConcurrentSetTowerIter _tmp11_ = {0};
			gboolean _tmp12_ = FALSE;
			gboolean _tmp17_ = FALSE;
			GeeConcurrentSetTowerIter _tmp18_;
			GeeConcurrentSetTower* _tmp19_;
			gboolean _tmp25_;
			GeeConcurrentSetTowerIter _tmp26_;
			GeeConcurrentSetTower* _tmp27_;
			gconstpointer _tmp28_;
			gpointer _tmp29_;
			_tmp5_ = self->priv->_range;
			gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp5_, NULL, &_tmp6_);
			gee_concurrent_set_tower_iter_destroy (&prev);
			prev = _tmp6_;
			_tmp7_ = self->priv->_range;
			_tmp8_ = _tmp7_->_set;
			_tmp9_ = _tmp8_->priv->_cmp;
			_tmp9__target = _tmp8_->priv->_cmp_target;
			_tmp10_ = element;
			_tmp12_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp9_, _tmp9__target, _tmp10_, &prev, &_tmp11_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
			gee_concurrent_set_tower_iter_destroy (&curr);
			curr = _tmp11_;
			if (_tmp12_) {
				GeeConcurrentSetRange* _tmp13_;
				GeeConcurrentSet* _tmp14_;
				GCompareDataFunc _tmp15_;
				void* _tmp15__target;
				gboolean _tmp16_ = FALSE;
				_tmp13_ = self->priv->_range;
				_tmp14_ = _tmp13_->_set;
				_tmp15_ = _tmp14_->priv->_cmp;
				_tmp15__target = _tmp14_->priv->_cmp_target;
				_tmp16_ = gee_concurrent_set_tower_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp15_, _tmp15__target, &prev._iter[0], &curr._iter[0], (guint8) 0, FALSE);
				if (!_tmp16_) {
					result = NULL;
					gee_concurrent_set_tower_iter_destroy (&curr);
					gee_concurrent_set_tower_iter_destroy (&prev);
					_gee_hazard_pointer_context_free0 (ctx);
					return result;
				}
			}
			_tmp18_ = curr;
			_tmp19_ = _tmp18_._iter[0];
			if (_tmp19_ == NULL) {
				_tmp17_ = TRUE;
			} else {
				GeeConcurrentSetRange* _tmp20_;
				GeeConcurrentSetTowerIter _tmp21_;
				GeeConcurrentSetTower* _tmp22_;
				gconstpointer _tmp23_;
				gboolean _tmp24_ = FALSE;
				_tmp20_ = self->priv->_range;
				_tmp21_ = curr;
				_tmp22_ = _tmp21_._iter[0];
				_tmp23_ = _tmp22_->_data;
				_tmp24_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp20_, _tmp23_);
				_tmp17_ = !_tmp24_;
			}
			_tmp25_ = _tmp17_;
			if (_tmp25_) {
				result = NULL;
				gee_concurrent_set_tower_iter_destroy (&curr);
				gee_concurrent_set_tower_iter_destroy (&prev);
				_gee_hazard_pointer_context_free0 (ctx);
				return result;
			}
			_tmp26_ = curr;
			_tmp27_ = _tmp26_._iter[0];
			_tmp28_ = _tmp27_->_data;
			_tmp29_ = ((_tmp28_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp28_) : ((gpointer) _tmp28_);
			result = _tmp29_;
			gee_concurrent_set_tower_iter_destroy (&curr);
			gee_concurrent_set_tower_iter_destroy (&prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_AFTER:
		case GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY:
		{
			result = NULL;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_sub_set_real_floor (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSetSubSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetRange* _tmp1_;
	gconstpointer _tmp2_;
	gint _tmp3_ = 0;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	_tmp2_ = element;
	_tmp3_ = gee_concurrent_set_range_cmp (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, _tmp2_);
	switch (_tmp3_) {
		case GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE:
		case GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY:
		{
			result = NULL;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE:
		{
			GeeConcurrentSetTowerIter curr = {0};
			GeeConcurrentSetTowerIter prev = {0};
			GeeConcurrentSetRange* _tmp4_;
			GeeConcurrentSetTowerIter _tmp5_ = {0};
			GeeConcurrentSetRange* _tmp6_;
			GeeConcurrentSet* _tmp7_;
			GCompareDataFunc _tmp8_;
			void* _tmp8__target;
			gconstpointer _tmp9_;
			GeeConcurrentSetTowerIter _tmp10_ = {0};
			gboolean _tmp11_ = FALSE;
			gboolean _tmp14_ = FALSE;
			gboolean _tmp15_ = FALSE;
			GeeConcurrentSetTowerIter _tmp16_;
			GeeConcurrentSetTower* _tmp17_;
			gboolean _tmp21_;
			gboolean _tmp27_;
			GeeConcurrentSetTowerIter _tmp28_;
			GeeConcurrentSetTower* _tmp29_;
			gconstpointer _tmp30_;
			gpointer _tmp31_;
			_tmp4_ = self->priv->_range;
			gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_, NULL, &_tmp5_);
			gee_concurrent_set_tower_iter_destroy (&prev);
			prev = _tmp5_;
			_tmp6_ = self->priv->_range;
			_tmp7_ = _tmp6_->_set;
			_tmp8_ = _tmp7_->priv->_cmp;
			_tmp8__target = _tmp7_->priv->_cmp_target;
			_tmp9_ = element;
			_tmp11_ = gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp8_, _tmp8__target, _tmp9_, &prev, &_tmp10_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
			gee_concurrent_set_tower_iter_destroy (&curr);
			curr = _tmp10_;
			if (!_tmp11_) {
				GeeConcurrentSetTower* _tmp12_;
				GeeConcurrentSetTower* _tmp13_;
				_tmp12_ = prev._iter[0];
				prev._iter[0] = NULL;
				_gee_concurrent_set_tower_unref0 (curr._iter[0]);
				curr._iter[0] = _tmp12_;
				_tmp13_ = curr._iter[0];
			}
			_tmp16_ = curr;
			_tmp17_ = _tmp16_._iter[0];
			if (_tmp17_ == NULL) {
				_tmp15_ = TRUE;
			} else {
				GeeConcurrentSetTowerIter _tmp18_;
				GeeConcurrentSetTower* _tmp19_;
				gboolean _tmp20_ = FALSE;
				_tmp18_ = curr;
				_tmp19_ = _tmp18_._iter[0];
				_tmp20_ = gee_concurrent_set_tower_is_head (_tmp19_);
				_tmp15_ = _tmp20_;
			}
			_tmp21_ = _tmp15_;
			if (_tmp21_) {
				_tmp14_ = TRUE;
			} else {
				GeeConcurrentSetRange* _tmp22_;
				GeeConcurrentSetTowerIter _tmp23_;
				GeeConcurrentSetTower* _tmp24_;
				gconstpointer _tmp25_;
				gboolean _tmp26_ = FALSE;
				_tmp22_ = self->priv->_range;
				_tmp23_ = curr;
				_tmp24_ = _tmp23_._iter[0];
				_tmp25_ = _tmp24_->_data;
				_tmp26_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp22_, _tmp25_);
				_tmp14_ = !_tmp26_;
			}
			_tmp27_ = _tmp14_;
			if (_tmp27_) {
				result = NULL;
				gee_concurrent_set_tower_iter_destroy (&prev);
				gee_concurrent_set_tower_iter_destroy (&curr);
				_gee_hazard_pointer_context_free0 (ctx);
				return result;
			}
			_tmp28_ = curr;
			_tmp29_ = _tmp28_._iter[0];
			_tmp30_ = _tmp29_->_data;
			_tmp31_ = ((_tmp30_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp30_) : ((gpointer) _tmp30_);
			result = _tmp31_;
			gee_concurrent_set_tower_iter_destroy (&prev);
			gee_concurrent_set_tower_iter_destroy (&curr);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_AFTER:
		{
			gpointer _tmp32_ = NULL;
			_tmp32_ = gee_abstract_sorted_set_last ((GeeAbstractSortedSet*) self);
			result = _tmp32_;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_sub_set_real_ceil (GeeAbstractSortedSet* base, gconstpointer element) {
	GeeConcurrentSetSubSet * self;
	gpointer result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetRange* _tmp1_;
	gconstpointer _tmp2_;
	gint _tmp3_ = 0;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	_tmp2_ = element;
	_tmp3_ = gee_concurrent_set_range_cmp (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, _tmp2_);
	switch (_tmp3_) {
		case GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE:
		{
			gpointer _tmp4_ = NULL;
			_tmp4_ = gee_abstract_sorted_set_first ((GeeAbstractSortedSet*) self);
			result = _tmp4_;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE:
		{
			GeeConcurrentSetTowerIter curr = {0};
			GeeConcurrentSetTowerIter prev = {0};
			GeeConcurrentSetRange* _tmp5_;
			GeeConcurrentSetTowerIter _tmp6_ = {0};
			GeeConcurrentSetRange* _tmp7_;
			GeeConcurrentSet* _tmp8_;
			GCompareDataFunc _tmp9_;
			void* _tmp9__target;
			gconstpointer _tmp10_;
			GeeConcurrentSetTowerIter _tmp11_ = {0};
			gboolean _tmp12_ = FALSE;
			GeeConcurrentSetTowerIter _tmp13_;
			GeeConcurrentSetTower* _tmp14_;
			gboolean _tmp20_;
			GeeConcurrentSetTowerIter _tmp21_;
			GeeConcurrentSetTower* _tmp22_;
			gconstpointer _tmp23_;
			gpointer _tmp24_;
			_tmp5_ = self->priv->_range;
			gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp5_, NULL, &_tmp6_);
			gee_concurrent_set_tower_iter_destroy (&prev);
			prev = _tmp6_;
			_tmp7_ = self->priv->_range;
			_tmp8_ = _tmp7_->_set;
			_tmp9_ = _tmp8_->priv->_cmp;
			_tmp9__target = _tmp8_->priv->_cmp_target;
			_tmp10_ = element;
			gee_concurrent_set_tower_search_from_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp9_, _tmp9__target, _tmp10_, &prev, &_tmp11_, (guint8) 0, (guint8) (((guint8) GEE_CONCURRENT_SET__MAX_HEIGHT) - 1));
			gee_concurrent_set_tower_iter_destroy (&curr);
			curr = _tmp11_;
			_tmp13_ = curr;
			_tmp14_ = _tmp13_._iter[0];
			if (_tmp14_ == NULL) {
				_tmp12_ = TRUE;
			} else {
				GeeConcurrentSetRange* _tmp15_;
				GeeConcurrentSetTowerIter _tmp16_;
				GeeConcurrentSetTower* _tmp17_;
				gconstpointer _tmp18_;
				gboolean _tmp19_ = FALSE;
				_tmp15_ = self->priv->_range;
				_tmp16_ = curr;
				_tmp17_ = _tmp16_._iter[0];
				_tmp18_ = _tmp17_->_data;
				_tmp19_ = gee_concurrent_set_range_inside (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp15_, _tmp18_);
				_tmp12_ = !_tmp19_;
			}
			_tmp20_ = _tmp12_;
			if (_tmp20_) {
				result = NULL;
				gee_concurrent_set_tower_iter_destroy (&prev);
				gee_concurrent_set_tower_iter_destroy (&curr);
				_gee_hazard_pointer_context_free0 (ctx);
				return result;
			}
			_tmp21_ = curr;
			_tmp22_ = _tmp21_._iter[0];
			_tmp23_ = _tmp22_->_data;
			_tmp24_ = ((_tmp23_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp23_) : ((gpointer) _tmp23_);
			result = _tmp24_;
			gee_concurrent_set_tower_iter_destroy (&prev);
			gee_concurrent_set_tower_iter_destroy (&curr);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_POSITION_AFTER:
		case GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY:
		{
			result = NULL;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_gee_hazard_pointer_context_free0 (ctx);
}


static GeeSortedSet* gee_concurrent_set_sub_set_real_head_set (GeeAbstractSortedSet* base, gconstpointer before) {
	GeeConcurrentSetSubSet * self;
	GeeSortedSet* result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetRange* _tmp1_;
	gconstpointer _tmp2_;
	GeeConcurrentSetRange* _tmp3_ = NULL;
	GeeConcurrentSetRange* _tmp4_;
	GeeConcurrentSetSubSet* _tmp5_;
	GeeSortedSet* _tmp6_;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	_tmp2_ = before;
	_tmp3_ = gee_concurrent_set_range_cut_tail (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_);
	_tmp6_ = (GeeSortedSet*) _tmp5_;
	_gee_concurrent_set_range_unref0 (_tmp4_);
	result = _tmp6_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeSortedSet* gee_concurrent_set_sub_set_real_tail_set (GeeAbstractSortedSet* base, gconstpointer after) {
	GeeConcurrentSetSubSet * self;
	GeeSortedSet* result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetRange* _tmp1_;
	gconstpointer _tmp2_;
	GeeConcurrentSetRange* _tmp3_ = NULL;
	GeeConcurrentSetRange* _tmp4_;
	GeeConcurrentSetSubSet* _tmp5_;
	GeeSortedSet* _tmp6_;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	_tmp2_ = after;
	_tmp3_ = gee_concurrent_set_range_cut_head (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, _tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp4_);
	_tmp6_ = (GeeSortedSet*) _tmp5_;
	_gee_concurrent_set_range_unref0 (_tmp4_);
	result = _tmp6_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static GeeSortedSet* gee_concurrent_set_sub_set_real_sub_set (GeeAbstractSortedSet* base, gconstpointer from, gconstpointer to) {
	GeeConcurrentSetSubSet * self;
	GeeSortedSet* result = NULL;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetRange* _tmp1_;
	gconstpointer _tmp2_;
	gconstpointer _tmp3_;
	GeeConcurrentSetRange* _tmp4_ = NULL;
	GeeConcurrentSetRange* _tmp5_;
	GeeConcurrentSetSubSet* _tmp6_;
	GeeSortedSet* _tmp7_;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	_tmp2_ = from;
	_tmp3_ = to;
	_tmp4_ = gee_concurrent_set_range_cut (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, _tmp2_, _tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = gee_concurrent_set_sub_set_new (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp5_);
	_tmp7_ = (GeeSortedSet*) _tmp6_;
	_gee_concurrent_set_range_unref0 (_tmp5_);
	result = _tmp7_;
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gint gee_concurrent_set_sub_set_real_get_size (GeeAbstractCollection* base) {
	gint result;
	GeeConcurrentSetSubSet* self;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_;
	self = (GeeConcurrentSetSubSet*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, &_tmp2_, NULL);
	_gee_concurrent_set_tower_unref0 (curr);
	curr = _tmp2_;
	_tmp3_ = curr;
	if (_tmp3_ != NULL) {
		gint acc;
		GeeConcurrentSetRange* _tmp4_;
		gpointer _tmp5_ = NULL;
		GeeConcurrentSetTower* prev;
		gint _tmp9_;
		acc = 1;
		_tmp4_ = self->priv->_range;
		_tmp5_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp4_->_bookmark._iter[0], (gsize) 0, NULL);
		prev = (GeeConcurrentSetTower*) _tmp5_;
		while (TRUE) {
			GeeConcurrentSetRange* _tmp6_;
			gboolean _tmp7_ = FALSE;
			gint _tmp8_;
			_tmp6_ = self->priv->_range;
			_tmp7_ = gee_concurrent_set_range_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp6_, &prev, &curr, (guint8) 0);
			if (!_tmp7_) {
				break;
			}
			_tmp8_ = acc;
			acc = _tmp8_ + 1;
		}
		_tmp9_ = acc;
		result = _tmp9_;
		_gee_concurrent_set_tower_unref0 (prev);
		_gee_concurrent_set_tower_unref0 (curr);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	} else {
		result = 0;
		_gee_concurrent_set_tower_unref0 (curr);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_gee_concurrent_set_tower_unref0 (curr);
	_gee_hazard_pointer_context_free0 (ctx);
}


static gboolean gee_concurrent_set_sub_set_get_is_empty (GeeConcurrentSetSubSet* self) {
	gboolean result;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTower* curr = NULL;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp1_, &_tmp2_, NULL);
	_gee_concurrent_set_tower_unref0 (curr);
	curr = _tmp2_;
	result = curr != NULL;
	_gee_concurrent_set_tower_unref0 (curr);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_sub_set_real_get_read_only (GeeAbstractCollection* base) {
	gboolean result;
	GeeConcurrentSetSubSet* self;
	self = (GeeConcurrentSetSubSet*) base;
	result = FALSE;
	return result;
}


static void gee_concurrent_set_sub_set_class_init (GeeConcurrentSetSubSetClass * klass) {
	gee_concurrent_set_sub_set_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeConcurrentSetSubSetPrivate));
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->iterator = gee_concurrent_set_sub_set_real_iterator;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->contains = gee_concurrent_set_sub_set_real_contains;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->add = gee_concurrent_set_sub_set_real_add;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->remove = gee_concurrent_set_sub_set_real_remove;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->clear = gee_concurrent_set_sub_set_real_clear;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->first = gee_concurrent_set_sub_set_real_first;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->last = gee_concurrent_set_sub_set_real_last;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->iterator_at = gee_concurrent_set_sub_set_real_iterator_at;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->lower = gee_concurrent_set_sub_set_real_lower;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->higher = gee_concurrent_set_sub_set_real_higher;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->floor = gee_concurrent_set_sub_set_real_floor;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->ceil = gee_concurrent_set_sub_set_real_ceil;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->head_set = gee_concurrent_set_sub_set_real_head_set;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->tail_set = gee_concurrent_set_sub_set_real_tail_set;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->sub_set = gee_concurrent_set_sub_set_real_sub_set;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_size = gee_concurrent_set_sub_set_real_get_size;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_read_only = gee_concurrent_set_sub_set_real_get_read_only;
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_concurrent_set_sub_set_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_concurrent_set_sub_set_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_concurrent_set_sub_set_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_G_TYPE, g_param_spec_gtype ("g-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_G_DUP_FUNC, g_param_spec_pointer ("g-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_G_DESTROY_FUNC, g_param_spec_pointer ("g-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_SIZE, g_param_spec_int ("size", "size", "size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_IS_EMPTY, g_param_spec_boolean ("is-empty", "is-empty", "is-empty", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_SET_READ_ONLY, g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void gee_concurrent_set_sub_set_instance_init (GeeConcurrentSetSubSet * self) {
	self->priv = GEE_CONCURRENT_SET_SUB_SET_GET_PRIVATE (self);
}


static void gee_concurrent_set_sub_set_finalize (GObject* obj) {
	GeeConcurrentSetSubSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSet);
	_gee_concurrent_set_range_unref0 (self->priv->_range);
	G_OBJECT_CLASS (gee_concurrent_set_sub_set_parent_class)->finalize (obj);
}


static GType gee_concurrent_set_sub_set_get_type (void) {
	static volatile gsize gee_concurrent_set_sub_set_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_sub_set_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetSubSetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_sub_set_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSetSubSet), 0, (GInstanceInitFunc) gee_concurrent_set_sub_set_instance_init, NULL };
		GType gee_concurrent_set_sub_set_type_id;
		gee_concurrent_set_sub_set_type_id = g_type_register_static (GEE_TYPE_ABSTRACT_SORTED_SET, "GeeConcurrentSetSubSet", &g_define_type_info, 0);
		g_once_init_leave (&gee_concurrent_set_sub_set_type_id__volatile, gee_concurrent_set_sub_set_type_id);
	}
	return gee_concurrent_set_sub_set_type_id__volatile;
}


static void _vala_gee_concurrent_set_sub_set_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeConcurrentSetSubSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSet);
	switch (property_id) {
		case GEE_CONCURRENT_SET_SUB_SET_SIZE:
		g_value_set_int (value, gee_abstract_collection_get_size ((GeeAbstractCollection*) self));
		break;
		case GEE_CONCURRENT_SET_SUB_SET_IS_EMPTY:
		g_value_set_boolean (value, gee_concurrent_set_sub_set_get_is_empty (self));
		break;
		case GEE_CONCURRENT_SET_SUB_SET_READ_ONLY:
		g_value_set_boolean (value, gee_abstract_collection_get_read_only ((GeeAbstractCollection*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_concurrent_set_sub_set_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeConcurrentSetSubSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_SUB_SET, GeeConcurrentSetSubSet);
	switch (property_id) {
		case GEE_CONCURRENT_SET_SUB_SET_G_TYPE:
		self->priv->g_type = g_value_get_gtype (value);
		break;
		case GEE_CONCURRENT_SET_SUB_SET_G_DUP_FUNC:
		self->priv->g_dup_func = g_value_get_pointer (value);
		break;
		case GEE_CONCURRENT_SET_SUB_SET_G_DESTROY_FUNC:
		self->priv->g_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range) {
	GeeConcurrentSetSubIterator * self = NULL;
	GeeConcurrentSetRange* _tmp0_;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	g_return_val_if_fail (range != NULL, NULL);
	self = (GeeConcurrentSetSubIterator*) g_object_new (object_type, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = range;
	gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp0_, NULL, NULL);
	_tmp1_ = range;
	_tmp2_ = _gee_concurrent_set_range_ref0 (_tmp1_);
	_gee_concurrent_set_range_unref0 (self->priv->_range);
	self->priv->_range = _tmp2_;
	return self;
}


static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range) {
	return gee_concurrent_set_sub_iterator_construct (GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, g_type, g_dup_func, g_destroy_func, range);
}


static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_construct_point_at (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr) {
	GeeConcurrentSetSubIterator * self = NULL;
	GeeConcurrentSetRange* _tmp0_;
	GeeConcurrentSetRange* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetTowerIter _tmp3_;
	GeeConcurrentSetTowerIter _tmp4_ = {0};
	GeeConcurrentSetTower* _tmp5_;
	GeeConcurrentSetTower* _tmp6_;
	g_return_val_if_fail (range != NULL, NULL);
	g_return_val_if_fail (prev != NULL, NULL);
	g_return_val_if_fail (curr != NULL, NULL);
	self = (GeeConcurrentSetSubIterator*) g_object_new (object_type, NULL);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = range;
	gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp0_, NULL, NULL);
	_tmp1_ = range;
	_tmp2_ = _gee_concurrent_set_range_ref0 (_tmp1_);
	_gee_concurrent_set_range_unref0 (self->priv->_range);
	self->priv->_range = _tmp2_;
	_tmp3_ = *prev;
	gee_concurrent_set_tower_iter_copy (&_tmp3_, &_tmp4_);
	gee_concurrent_set_tower_iter_destroy (&self->priv->_prev);
	self->priv->_prev = _tmp4_;
	_tmp5_ = curr;
	_tmp6_ = _gee_concurrent_set_tower_ref0 (_tmp5_);
	_gee_concurrent_set_tower_unref0 (self->priv->_curr);
	self->priv->_curr = _tmp6_;
	_gee_concurrent_set_tower_unref0 (curr);
	return self;
}


static GeeConcurrentSetSubIterator* gee_concurrent_set_sub_iterator_new_point_at (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr) {
	return gee_concurrent_set_sub_iterator_construct_point_at (GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, g_type, g_dup_func, g_destroy_func, range, prev, curr);
}


static gboolean gee_concurrent_set_sub_iterator_real_foreach (GeeTraversable* base, GeeForallFunc f, void* f_target) {
	GeeConcurrentSetSubIterator * self;
	gboolean result = FALSE;
	GeeConcurrentSetTower* _tmp0_;
	GeeHazardPointerContext* _tmp1_;
	GeeHazardPointerContext* ctx;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	GeeConcurrentSetTowerIter _tmp4_;
	GeeConcurrentSetTower* _tmp5_;
	gboolean _tmp7_;
	GeeConcurrentSetTowerIter _tmp14_;
	GeeConcurrentSetTower* _tmp15_;
	GeeConcurrentSetTower* _tmp16_;
	GeeConcurrentSetTower* new_prev;
	GeeConcurrentSetTower* _tmp17_;
	GeeConcurrentSetTower* _tmp18_;
	GeeConcurrentSetTower* new_curr;
	GeeConcurrentSetTower* _tmp45_;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = self->priv->_curr;
	_vala_assert (_tmp0_ != NULL, "_curr != null");
	_tmp1_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp1_;
	_tmp2_ = gee_concurrent_set_sub_iterator_begin (self);
	if (!_tmp2_) {
		result = TRUE;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_tmp4_ = self->priv->_prev;
	_tmp5_ = _tmp4_._iter[0];
	if (_tmp5_ != NULL) {
		gboolean _tmp6_;
		_tmp6_ = self->priv->_removed;
		_tmp3_ = !_tmp6_;
	} else {
		_tmp3_ = FALSE;
	}
	_tmp7_ = _tmp3_;
	if (_tmp7_) {
		GeeForallFunc _tmp8_;
		void* _tmp8__target;
		GeeConcurrentSetTower* _tmp9_;
		gconstpointer _tmp10_;
		gpointer _tmp11_;
		gboolean _tmp12_ = FALSE;
		_tmp8_ = f;
		_tmp8__target = f_target;
		_tmp9_ = self->priv->_curr;
		_tmp10_ = _tmp9_->_data;
		_tmp11_ = ((_tmp10_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp10_) : ((gpointer) _tmp10_);
		_tmp12_ = _tmp8_ (_tmp11_, _tmp8__target);
		if (!_tmp12_) {
			GeeConcurrentSetTower* _tmp13_;
			_tmp13_ = self->priv->_curr;
			_vala_assert (_tmp13_ != NULL, "_curr != null");
			result = FALSE;
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
	}
	_tmp14_ = self->priv->_prev;
	_tmp15_ = _tmp14_._iter[0];
	_tmp16_ = _gee_concurrent_set_tower_ref0 (_tmp15_);
	new_prev = _tmp16_;
	_tmp17_ = self->priv->_curr;
	_tmp18_ = _gee_concurrent_set_tower_ref0 (_tmp17_);
	new_curr = _tmp18_;
	while (TRUE) {
		GeeConcurrentSetRange* _tmp19_;
		gboolean _tmp20_ = FALSE;
		GeeConcurrentSetTower* _tmp21_;
		GeeForallFunc _tmp22_;
		void* _tmp22__target;
		GeeConcurrentSetTower* _tmp23_;
		gconstpointer _tmp24_;
		gpointer _tmp25_;
		gboolean _tmp26_ = FALSE;
		gboolean _tmp28_;
		GeeConcurrentSetTower* _tmp44_;
		_tmp19_ = self->priv->_range;
		_tmp20_ = gee_concurrent_set_range_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp19_, &new_prev, &new_curr, (guint8) 0);
		if (!_tmp20_) {
			break;
		}
		_tmp21_ = self->priv->_curr;
		_vala_assert (_tmp21_ != NULL, "_curr != null");
		_tmp22_ = f;
		_tmp22__target = f_target;
		_tmp23_ = self->priv->_curr;
		_tmp24_ = _tmp23_->_data;
		_tmp25_ = ((_tmp24_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp24_) : ((gpointer) _tmp24_);
		_tmp26_ = _tmp22_ (_tmp25_, _tmp22__target);
		if (!_tmp26_) {
			GeeConcurrentSetTower* _tmp27_;
			_tmp27_ = self->priv->_curr;
			_vala_assert (_tmp27_ != NULL, "_curr != null");
			result = FALSE;
			_gee_concurrent_set_tower_unref0 (new_curr);
			_gee_concurrent_set_tower_unref0 (new_prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		_tmp28_ = self->priv->_removed;
		if (!_tmp28_) {
			GeeConcurrentSetTower* _tmp29_;
			GeeConcurrentSetTower* _tmp30_;
			GeeConcurrentSetTowerIter _tmp31_;
			GeeConcurrentSetTower* _tmp32_;
			gint _tmp33_ = 0;
			gint prev_height;
			_tmp29_ = new_prev;
			new_prev = NULL;
			_gee_concurrent_set_tower_unref0 (self->priv->_prev._iter[0]);
			self->priv->_prev._iter[0] = _tmp29_;
			_tmp30_ = self->priv->_prev._iter[0];
			_tmp31_ = self->priv->_prev;
			_tmp32_ = _tmp31_._iter[0];
			_tmp33_ = gee_concurrent_set_tower_get_height (_tmp32_);
			prev_height = _tmp33_;
			{
				gint i;
				i = 1;
				{
					gboolean _tmp34_;
					_tmp34_ = TRUE;
					while (TRUE) {
						gboolean _tmp35_;
						gint _tmp37_;
						gint _tmp38_;
						gint _tmp39_;
						GeeConcurrentSetTowerIter _tmp40_;
						GeeConcurrentSetTower* _tmp41_;
						GeeConcurrentSetTower* _tmp42_;
						GeeConcurrentSetTower* _tmp43_;
						_tmp35_ = _tmp34_;
						if (!_tmp35_) {
							gint _tmp36_;
							_tmp36_ = i;
							i = _tmp36_ + 1;
						}
						_tmp34_ = FALSE;
						_tmp37_ = i;
						_tmp38_ = prev_height;
						if (!(_tmp37_ < _tmp38_)) {
							break;
						}
						_tmp39_ = i;
						_tmp40_ = self->priv->_prev;
						_tmp41_ = _tmp40_._iter[0];
						_tmp42_ = _gee_concurrent_set_tower_ref0 (_tmp41_);
						_gee_concurrent_set_tower_unref0 (self->priv->_prev._iter[_tmp39_]);
						self->priv->_prev._iter[_tmp39_] = _tmp42_;
						_tmp43_ = self->priv->_prev._iter[_tmp39_];
					}
				}
			}
		}
		_tmp44_ = new_curr;
		new_curr = NULL;
		_gee_concurrent_set_tower_unref0 (self->priv->_curr);
		self->priv->_curr = _tmp44_;
		self->priv->_removed = FALSE;
	}
	_tmp45_ = self->priv->_curr;
	_vala_assert (_tmp45_ != NULL, "_curr != null");
	result = TRUE;
	_gee_concurrent_set_tower_unref0 (new_curr);
	_gee_concurrent_set_tower_unref0 (new_prev);
	_gee_hazard_pointer_context_free0 (ctx);
	return result;
}


static gboolean gee_concurrent_set_sub_iterator_real_next (GeeIterator* base) {
	GeeConcurrentSetSubIterator * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTowerIter _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_prev;
	_tmp2_ = _tmp1_._iter[0];
	if (_tmp2_ == NULL) {
		gboolean _tmp3_ = FALSE;
		_tmp3_ = gee_concurrent_set_sub_iterator_begin (self);
		result = _tmp3_;
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	} else {
		GeeConcurrentSetTowerIter _tmp4_;
		GeeConcurrentSetTower* _tmp5_;
		GeeConcurrentSetTower* _tmp6_;
		GeeConcurrentSetTower* new_prev;
		GeeConcurrentSetTower* _tmp7_;
		GeeConcurrentSetTower* _tmp8_;
		GeeConcurrentSetTower* new_curr;
		GeeConcurrentSetRange* _tmp9_;
		gboolean _tmp10_ = FALSE;
		_tmp4_ = self->priv->_prev;
		_tmp5_ = _tmp4_._iter[0];
		_tmp6_ = _gee_concurrent_set_tower_ref0 (_tmp5_);
		new_prev = _tmp6_;
		_tmp7_ = self->priv->_curr;
		_tmp8_ = _gee_concurrent_set_tower_ref0 (_tmp7_);
		new_curr = _tmp8_;
		_tmp9_ = self->priv->_range;
		_tmp10_ = gee_concurrent_set_range_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp9_, &new_prev, &new_curr, (guint8) 0);
		if (_tmp10_) {
			gboolean _tmp11_;
			GeeConcurrentSetTower* _tmp27_;
			_tmp11_ = self->priv->_removed;
			if (!_tmp11_) {
				GeeConcurrentSetTower* _tmp12_;
				GeeConcurrentSetTower* _tmp13_;
				GeeConcurrentSetTowerIter _tmp14_;
				GeeConcurrentSetTower* _tmp15_;
				gint _tmp16_ = 0;
				gint prev_height;
				_tmp12_ = new_prev;
				new_prev = NULL;
				_gee_concurrent_set_tower_unref0 (self->priv->_prev._iter[0]);
				self->priv->_prev._iter[0] = _tmp12_;
				_tmp13_ = self->priv->_prev._iter[0];
				_tmp14_ = self->priv->_prev;
				_tmp15_ = _tmp14_._iter[0];
				_tmp16_ = gee_concurrent_set_tower_get_height (_tmp15_);
				prev_height = _tmp16_;
				{
					gint i;
					i = 1;
					{
						gboolean _tmp17_;
						_tmp17_ = TRUE;
						while (TRUE) {
							gboolean _tmp18_;
							gint _tmp20_;
							gint _tmp21_;
							gint _tmp22_;
							GeeConcurrentSetTowerIter _tmp23_;
							GeeConcurrentSetTower* _tmp24_;
							GeeConcurrentSetTower* _tmp25_;
							GeeConcurrentSetTower* _tmp26_;
							_tmp18_ = _tmp17_;
							if (!_tmp18_) {
								gint _tmp19_;
								_tmp19_ = i;
								i = _tmp19_ + 1;
							}
							_tmp17_ = FALSE;
							_tmp20_ = i;
							_tmp21_ = prev_height;
							if (!(_tmp20_ < _tmp21_)) {
								break;
							}
							_tmp22_ = i;
							_tmp23_ = self->priv->_prev;
							_tmp24_ = _tmp23_._iter[0];
							_tmp25_ = _gee_concurrent_set_tower_ref0 (_tmp24_);
							_gee_concurrent_set_tower_unref0 (self->priv->_prev._iter[_tmp22_]);
							self->priv->_prev._iter[_tmp22_] = _tmp25_;
							_tmp26_ = self->priv->_prev._iter[_tmp22_];
						}
					}
				}
			}
			_tmp27_ = new_curr;
			new_curr = NULL;
			_gee_concurrent_set_tower_unref0 (self->priv->_curr);
			self->priv->_curr = _tmp27_;
			self->priv->_removed = FALSE;
			result = TRUE;
			_gee_concurrent_set_tower_unref0 (new_curr);
			_gee_concurrent_set_tower_unref0 (new_prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		} else {
			result = FALSE;
			_gee_concurrent_set_tower_unref0 (new_curr);
			_gee_concurrent_set_tower_unref0 (new_prev);
			_gee_hazard_pointer_context_free0 (ctx);
			return result;
		}
		_gee_concurrent_set_tower_unref0 (new_curr);
		_gee_concurrent_set_tower_unref0 (new_prev);
	}
	_gee_hazard_pointer_context_free0 (ctx);
}


static gboolean gee_concurrent_set_sub_iterator_real_has_next (GeeIterator* base) {
	GeeConcurrentSetSubIterator * self;
	gboolean result = FALSE;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	GeeConcurrentSetTowerIter _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = self->priv->_prev;
	_tmp2_ = _tmp1_._iter[0];
	if (_tmp2_ == NULL) {
		GeeConcurrentSetTower* next = NULL;
		GeeConcurrentSetRange* _tmp3_;
		GeeConcurrentSetTower* _tmp4_ = NULL;
		gboolean _tmp5_ = FALSE;
		GeeConcurrentSetTower* _tmp6_;
		gboolean _tmp10_;
		GeeConcurrentSetTower* _tmp11_;
		_tmp3_ = self->priv->_range;
		gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp3_, &_tmp4_, NULL);
		_gee_concurrent_set_tower_unref0 (next);
		next = _tmp4_;
		_tmp6_ = next;
		if (_tmp6_ != NULL) {
			GeeConcurrentSetRange* _tmp7_;
			GeeConcurrentSetTower* _tmp8_;
			gboolean _tmp9_ = FALSE;
			_tmp7_ = self->priv->_range;
			_tmp8_ = next;
			_tmp9_ = gee_concurrent_set_range_beyond (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp7_, _tmp8_);
			_tmp5_ = _tmp9_;
		} else {
			_tmp5_ = FALSE;
		}
		_tmp10_ = _tmp5_;
		if (_tmp10_) {
			_gee_concurrent_set_tower_unref0 (next);
			next = NULL;
		}
		_tmp11_ = next;
		result = _tmp11_ != NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	} else {
		GeeConcurrentSetTowerIter _tmp12_;
		GeeConcurrentSetTower* _tmp13_;
		GeeConcurrentSetTower* _tmp14_;
		GeeConcurrentSetTower* new_prev;
		GeeConcurrentSetTower* _tmp15_;
		GeeConcurrentSetTower* _tmp16_;
		GeeConcurrentSetTower* new_curr;
		GeeConcurrentSetRange* _tmp17_;
		gboolean _tmp18_ = FALSE;
		_tmp12_ = self->priv->_prev;
		_tmp13_ = _tmp12_._iter[0];
		_tmp14_ = _gee_concurrent_set_tower_ref0 (_tmp13_);
		new_prev = _tmp14_;
		_tmp15_ = self->priv->_curr;
		_tmp16_ = _gee_concurrent_set_tower_ref0 (_tmp15_);
		new_curr = _tmp16_;
		_tmp17_ = self->priv->_range;
		_tmp18_ = gee_concurrent_set_range_proceed (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp17_, &new_prev, &new_curr, (guint8) 0);
		result = _tmp18_;
		_gee_concurrent_set_tower_unref0 (new_curr);
		_gee_concurrent_set_tower_unref0 (new_prev);
		_gee_hazard_pointer_context_free0 (ctx);
		return result;
	}
	_gee_hazard_pointer_context_free0 (ctx);
}


static gpointer gee_concurrent_set_sub_iterator_real_get (GeeIterator* base) {
	GeeConcurrentSetSubIterator * self;
	gpointer result = NULL;
	gboolean _tmp0_;
	gboolean _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	gconstpointer _tmp3_;
	gpointer _tmp4_;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = gee_iterator_get_valid ((GeeIterator*) self);
	_tmp1_ = _tmp0_;
	_vala_assert (_tmp1_, "valid");
	_tmp2_ = self->priv->_curr;
	_tmp3_ = _tmp2_->_data;
	_tmp4_ = ((_tmp3_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp3_) : ((gpointer) _tmp3_);
	result = _tmp4_;
	return result;
}


static void gee_concurrent_set_sub_iterator_real_remove (GeeIterator* base) {
	GeeConcurrentSetSubIterator * self;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	gboolean _tmp1_;
	gboolean _tmp2_;
	GeeConcurrentSetRange* _tmp3_;
	GeeConcurrentSet* _tmp4_;
	GCompareDataFunc _tmp5_;
	void* _tmp5__target;
	GeeConcurrentSetTower* _tmp6_;
	gboolean _tmp7_ = FALSE;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_tmp1_ = gee_iterator_get_valid ((GeeIterator*) self);
	_tmp2_ = _tmp1_;
	_vala_assert (_tmp2_, "valid");
	_tmp3_ = self->priv->_range;
	_tmp4_ = _tmp3_->_set;
	_tmp5_ = _tmp4_->priv->_cmp;
	_tmp5__target = _tmp4_->priv->_cmp_target;
	_tmp6_ = self->priv->_curr;
	_tmp7_ = gee_concurrent_set_tower_remove (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp5_, _tmp5__target, &self->priv->_prev, _tmp6_);
	if (_tmp7_) {
		GeeConcurrentSetRange* _tmp8_;
		GeeConcurrentSet* _tmp9_;
		_tmp8_ = self->priv->_range;
		_tmp9_ = _tmp8_->_set;
		g_atomic_int_dec_and_test ((volatile gint *) (&_tmp9_->priv->_size));
	}
	self->priv->_removed = TRUE;
	_gee_hazard_pointer_context_free0 (ctx);
}


static gboolean gee_concurrent_set_sub_iterator_begin (GeeConcurrentSetSubIterator* self) {
	gboolean result = FALSE;
	GeeConcurrentSetTowerIter _tmp0_;
	GeeConcurrentSetTower* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetTower* _tmp3_ = NULL;
	GeeConcurrentSetTowerIter _tmp4_ = {0};
	GeeConcurrentSetTower* _tmp5_;
	GeeConcurrentSetTower* _tmp12_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_prev;
	_tmp1_ = _tmp0_._iter[0];
	if (_tmp1_ != NULL) {
		result = TRUE;
		return result;
	}
	_tmp2_ = self->priv->_range;
	gee_concurrent_set_range_improve_bookmark (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp2_, &_tmp3_, &_tmp4_);
	_gee_concurrent_set_tower_unref0 (self->priv->_curr);
	self->priv->_curr = _tmp3_;
	gee_concurrent_set_tower_iter_destroy (&self->priv->_prev);
	self->priv->_prev = _tmp4_;
	_tmp5_ = self->priv->_curr;
	if (_tmp5_ == NULL) {
		{
			gint i;
			i = 0;
			{
				gboolean _tmp6_;
				_tmp6_ = TRUE;
				while (TRUE) {
					gboolean _tmp7_;
					gint _tmp9_;
					gint _tmp10_;
					GeeConcurrentSetTower* _tmp11_;
					_tmp7_ = _tmp6_;
					if (!_tmp7_) {
						gint _tmp8_;
						_tmp8_ = i;
						i = _tmp8_ + 1;
					}
					_tmp6_ = FALSE;
					_tmp9_ = i;
					if (!(_tmp9_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
						break;
					}
					_tmp10_ = i;
					_gee_concurrent_set_tower_unref0 (self->priv->_prev._iter[_tmp10_]);
					self->priv->_prev._iter[_tmp10_] = NULL;
					_tmp11_ = self->priv->_prev._iter[_tmp10_];
				}
			}
		}
	}
	_tmp12_ = self->priv->_curr;
	result = _tmp12_ != NULL;
	return result;
}


static gboolean gee_concurrent_set_sub_iterator_real_get_valid (GeeIterator* base) {
	gboolean result;
	GeeConcurrentSetSubIterator* self;
	gboolean _tmp0_ = FALSE;
	GeeConcurrentSetTowerIter _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	gboolean _tmp4_;
	gboolean is_valid;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_;
	gboolean _tmp8_;
	gboolean _tmp9_;
	self = (GeeConcurrentSetSubIterator*) base;
	_tmp1_ = self->priv->_prev;
	_tmp2_ = _tmp1_._iter[0];
	if (_tmp2_ != NULL) {
		gboolean _tmp3_;
		_tmp3_ = self->priv->_removed;
		_tmp0_ = !_tmp3_;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp4_ = _tmp0_;
	is_valid = _tmp4_;
	_tmp6_ = is_valid;
	if (!_tmp6_) {
		_tmp5_ = TRUE;
	} else {
		GeeConcurrentSetTower* _tmp7_;
		_tmp7_ = self->priv->_curr;
		_tmp5_ = _tmp7_ != NULL;
	}
	_tmp8_ = _tmp5_;
	_vala_assert (_tmp8_, "!is_valid || _curr != null");
	_tmp9_ = is_valid;
	result = _tmp9_;
	return result;
}


static gboolean gee_concurrent_set_sub_iterator_real_get_read_only (GeeIterator* base) {
	gboolean result;
	GeeConcurrentSetSubIterator* self;
	self = (GeeConcurrentSetSubIterator*) base;
	result = FALSE;
	return result;
}


static void gee_concurrent_set_sub_iterator_class_init (GeeConcurrentSetSubIteratorClass * klass) {
	gee_concurrent_set_sub_iterator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeConcurrentSetSubIteratorPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_concurrent_set_sub_iterator_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_concurrent_set_sub_iterator_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_concurrent_set_sub_iterator_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_ITERATOR_G_TYPE, g_param_spec_gtype ("g-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_ITERATOR_G_DUP_FUNC, g_param_spec_pointer ("g-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_ITERATOR_G_DESTROY_FUNC, g_param_spec_pointer ("g-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_ITERATOR_VALID, g_param_spec_boolean ("valid", "valid", "valid", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SUB_ITERATOR_READ_ONLY, g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static GType gee_concurrent_set_sub_iterator_gee_traversable_get_g_type (GeeConcurrentSetSubIterator* self) {
	return self->priv->g_type;
}


static GBoxedCopyFunc gee_concurrent_set_sub_iterator_gee_traversable_get_g_dup_func (GeeConcurrentSetSubIterator* self) {
	return self->priv->g_dup_func;
}


static GDestroyNotify gee_concurrent_set_sub_iterator_gee_traversable_get_g_destroy_func (GeeConcurrentSetSubIterator* self) {
	return self->priv->g_destroy_func;
}


static void gee_concurrent_set_sub_iterator_gee_traversable_interface_init (GeeTraversableIface * iface) {
	gee_concurrent_set_sub_iterator_gee_traversable_parent_iface = g_type_interface_peek_parent (iface);
	iface->foreach = (gboolean (*)(GeeTraversable*, GeeForallFunc, void*)) gee_concurrent_set_sub_iterator_real_foreach;
	iface->get_g_type = (GType(*)(GeeTraversable*)) gee_concurrent_set_sub_iterator_gee_traversable_get_g_type;
	iface->get_g_dup_func = (GBoxedCopyFunc(*)(GeeTraversable*)) gee_concurrent_set_sub_iterator_gee_traversable_get_g_dup_func;
	iface->get_g_destroy_func = (GDestroyNotify(*)(GeeTraversable*)) gee_concurrent_set_sub_iterator_gee_traversable_get_g_destroy_func;
}


static void gee_concurrent_set_sub_iterator_gee_iterator_interface_init (GeeIteratorIface * iface) {
	gee_concurrent_set_sub_iterator_gee_iterator_parent_iface = g_type_interface_peek_parent (iface);
	iface->next = (gboolean (*)(GeeIterator*)) gee_concurrent_set_sub_iterator_real_next;
	iface->has_next = (gboolean (*)(GeeIterator*)) gee_concurrent_set_sub_iterator_real_has_next;
	iface->get = (gpointer (*)(GeeIterator*)) gee_concurrent_set_sub_iterator_real_get;
	iface->remove = (void (*)(GeeIterator*)) gee_concurrent_set_sub_iterator_real_remove;
	iface->get_valid = gee_concurrent_set_sub_iterator_real_get_valid;
	iface->get_read_only = gee_concurrent_set_sub_iterator_real_get_read_only;
}


static void gee_concurrent_set_sub_iterator_instance_init (GeeConcurrentSetSubIterator * self) {
	self->priv = GEE_CONCURRENT_SET_SUB_ITERATOR_GET_PRIVATE (self);
	self->priv->_curr = NULL;
	self->priv->_removed = FALSE;
}


static void gee_concurrent_set_sub_iterator_finalize (GObject* obj) {
	GeeConcurrentSetSubIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIterator);
	_gee_concurrent_set_range_unref0 (self->priv->_range);
	gee_concurrent_set_tower_iter_destroy (&self->priv->_prev);
	_gee_concurrent_set_tower_unref0 (self->priv->_curr);
	G_OBJECT_CLASS (gee_concurrent_set_sub_iterator_parent_class)->finalize (obj);
}


static GType gee_concurrent_set_sub_iterator_get_type (void) {
	static volatile gsize gee_concurrent_set_sub_iterator_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_sub_iterator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetSubIteratorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_sub_iterator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSetSubIterator), 0, (GInstanceInitFunc) gee_concurrent_set_sub_iterator_instance_init, NULL };
		static const GInterfaceInfo gee_traversable_info = { (GInterfaceInitFunc) gee_concurrent_set_sub_iterator_gee_traversable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		static const GInterfaceInfo gee_iterator_info = { (GInterfaceInitFunc) gee_concurrent_set_sub_iterator_gee_iterator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType gee_concurrent_set_sub_iterator_type_id;
		gee_concurrent_set_sub_iterator_type_id = g_type_register_static (G_TYPE_OBJECT, "GeeConcurrentSetSubIterator", &g_define_type_info, 0);
		g_type_add_interface_static (gee_concurrent_set_sub_iterator_type_id, GEE_TYPE_TRAVERSABLE, &gee_traversable_info);
		g_type_add_interface_static (gee_concurrent_set_sub_iterator_type_id, GEE_TYPE_ITERATOR, &gee_iterator_info);
		g_once_init_leave (&gee_concurrent_set_sub_iterator_type_id__volatile, gee_concurrent_set_sub_iterator_type_id);
	}
	return gee_concurrent_set_sub_iterator_type_id__volatile;
}


static void _vala_gee_concurrent_set_sub_iterator_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeConcurrentSetSubIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIterator);
	switch (property_id) {
		case GEE_CONCURRENT_SET_SUB_ITERATOR_VALID:
		g_value_set_boolean (value, gee_iterator_get_valid ((GeeIterator*) self));
		break;
		case GEE_CONCURRENT_SET_SUB_ITERATOR_READ_ONLY:
		g_value_set_boolean (value, gee_iterator_get_read_only ((GeeIterator*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_concurrent_set_sub_iterator_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeConcurrentSetSubIterator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_CONCURRENT_SET_TYPE_SUB_ITERATOR, GeeConcurrentSetSubIterator);
	switch (property_id) {
		case GEE_CONCURRENT_SET_SUB_ITERATOR_G_TYPE:
		self->priv->g_type = g_value_get_gtype (value);
		break;
		case GEE_CONCURRENT_SET_SUB_ITERATOR_G_DUP_FUNC:
		self->priv->g_dup_func = g_value_get_pointer (value);
		break;
		case GEE_CONCURRENT_SET_SUB_ITERATOR_G_DESTROY_FUNC:
		self->priv->g_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static GType gee_concurrent_set_range_position_get_type (void) {
	static volatile gsize gee_concurrent_set_range_position_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_range_position_type_id__volatile)) {
		static const GEnumValue values[] = {{GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE, "GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE", "before"}, {GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE, "GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE", "inside"}, {GEE_CONCURRENT_SET_RANGE_POSITION_AFTER, "GEE_CONCURRENT_SET_RANGE_POSITION_AFTER", "after"}, {GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY, "GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY", "empty"}, {0, NULL, NULL}};
		GType gee_concurrent_set_range_position_type_id;
		gee_concurrent_set_range_position_type_id = g_enum_register_static ("GeeConcurrentSetRangePosition", values);
		g_once_init_leave (&gee_concurrent_set_range_position_type_id__volatile, gee_concurrent_set_range_position_type_id);
	}
	return gee_concurrent_set_range_position_type_id__volatile;
}


static GeeConcurrentSetRange* gee_concurrent_set_range_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start, gconstpointer end) {
	GeeConcurrentSetRange* self = NULL;
	gconstpointer _tmp0_;
	gpointer _tmp1_;
	gconstpointer _tmp2_;
	gpointer _tmp3_;
	GeeConcurrentSet* _tmp4_;
	GCompareDataFunc _tmp5_;
	void* _tmp5__target;
	gconstpointer _tmp6_;
	gconstpointer _tmp7_;
	gint _tmp8_ = 0;
	GeeConcurrentSet* _tmp18_;
	GeeConcurrentSet* _tmp19_;
	g_return_val_if_fail (cset != NULL, NULL);
	self = (GeeConcurrentSetRange*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = start;
	_tmp1_ = ((_tmp0_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp0_) : ((gpointer) _tmp0_);
	_g_destroy_func0 (self->_start);
	self->_start = _tmp1_;
	_tmp2_ = end;
	_tmp3_ = ((_tmp2_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp2_) : ((gpointer) _tmp2_);
	_g_destroy_func0 (self->_end);
	self->_end = _tmp3_;
	_tmp4_ = cset;
	_tmp5_ = _tmp4_->priv->_cmp;
	_tmp5__target = _tmp4_->priv->_cmp_target;
	_tmp6_ = start;
	_tmp7_ = end;
	_tmp8_ = _tmp5_ (_tmp6_, _tmp7_, _tmp5__target);
	if (_tmp8_ < 0) {
		self->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
		{
			gint i;
			i = 0;
			{
				gboolean _tmp9_;
				_tmp9_ = TRUE;
				while (TRUE) {
					gboolean _tmp10_;
					gint _tmp12_;
					gint _tmp13_;
					GeeConcurrentSet* _tmp14_;
					GeeConcurrentSetTower* _tmp15_;
					GeeConcurrentSetTower* _tmp16_;
					GeeConcurrentSetTower* _tmp17_;
					_tmp10_ = _tmp9_;
					if (!_tmp10_) {
						gint _tmp11_;
						_tmp11_ = i;
						i = _tmp11_ + 1;
					}
					_tmp9_ = FALSE;
					_tmp12_ = i;
					if (!(_tmp12_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
						break;
					}
					_tmp13_ = i;
					_tmp14_ = cset;
					_tmp15_ = _tmp14_->priv->_head;
					_tmp16_ = _gee_concurrent_set_tower_ref0 (_tmp15_);
					_gee_concurrent_set_tower_unref0 (self->_bookmark._iter[_tmp13_]);
					self->_bookmark._iter[_tmp13_] = _tmp16_;
					_tmp17_ = self->_bookmark._iter[_tmp13_];
				}
			}
		}
	} else {
		self->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
	}
	_tmp18_ = cset;
	_tmp19_ = _g_object_ref0 (_tmp18_);
	_g_object_unref0 (self->_set);
	self->_set = _tmp19_;
	return self;
}


static GeeConcurrentSetRange* gee_concurrent_set_range_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start, gconstpointer end) {
	return gee_concurrent_set_range_construct (GEE_CONCURRENT_SET_TYPE_RANGE, g_type, g_dup_func, g_destroy_func, cset, start, end);
}


static GeeConcurrentSetRange* gee_concurrent_set_range_construct_head (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer end) {
	GeeConcurrentSetRange* self = NULL;
	gconstpointer _tmp0_;
	gpointer _tmp1_;
	GeeConcurrentSet* _tmp11_;
	GeeConcurrentSet* _tmp12_;
	g_return_val_if_fail (cset != NULL, NULL);
	self = (GeeConcurrentSetRange*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = end;
	_tmp1_ = ((_tmp0_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp0_) : ((gpointer) _tmp0_);
	_g_destroy_func0 (self->_end);
	self->_end = _tmp1_;
	self->_type = GEE_CONCURRENT_SET_RANGE_TYPE_HEAD;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				gboolean _tmp3_;
				gint _tmp5_;
				gint _tmp6_;
				GeeConcurrentSet* _tmp7_;
				GeeConcurrentSetTower* _tmp8_;
				GeeConcurrentSetTower* _tmp9_;
				GeeConcurrentSetTower* _tmp10_;
				_tmp3_ = _tmp2_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp5_ = i;
				if (!(_tmp5_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp6_ = i;
				_tmp7_ = cset;
				_tmp8_ = _tmp7_->priv->_head;
				_tmp9_ = _gee_concurrent_set_tower_ref0 (_tmp8_);
				_gee_concurrent_set_tower_unref0 (self->_bookmark._iter[_tmp6_]);
				self->_bookmark._iter[_tmp6_] = _tmp9_;
				_tmp10_ = self->_bookmark._iter[_tmp6_];
			}
		}
	}
	_tmp11_ = cset;
	_tmp12_ = _g_object_ref0 (_tmp11_);
	_g_object_unref0 (self->_set);
	self->_set = _tmp12_;
	return self;
}


static GeeConcurrentSetRange* gee_concurrent_set_range_new_head (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer end) {
	return gee_concurrent_set_range_construct_head (GEE_CONCURRENT_SET_TYPE_RANGE, g_type, g_dup_func, g_destroy_func, cset, end);
}


static GeeConcurrentSetRange* gee_concurrent_set_range_construct_tail (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start) {
	GeeConcurrentSetRange* self = NULL;
	gconstpointer _tmp0_;
	gpointer _tmp1_;
	GeeConcurrentSet* _tmp11_;
	GeeConcurrentSet* _tmp12_;
	g_return_val_if_fail (cset != NULL, NULL);
	self = (GeeConcurrentSetRange*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = start;
	_tmp1_ = ((_tmp0_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp0_) : ((gpointer) _tmp0_);
	_g_destroy_func0 (self->_start);
	self->_start = _tmp1_;
	self->_type = GEE_CONCURRENT_SET_RANGE_TYPE_TAIL;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				gboolean _tmp3_;
				gint _tmp5_;
				gint _tmp6_;
				GeeConcurrentSet* _tmp7_;
				GeeConcurrentSetTower* _tmp8_;
				GeeConcurrentSetTower* _tmp9_;
				GeeConcurrentSetTower* _tmp10_;
				_tmp3_ = _tmp2_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp5_ = i;
				if (!(_tmp5_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp6_ = i;
				_tmp7_ = cset;
				_tmp8_ = _tmp7_->priv->_head;
				_tmp9_ = _gee_concurrent_set_tower_ref0 (_tmp8_);
				_gee_concurrent_set_tower_unref0 (self->_bookmark._iter[_tmp6_]);
				self->_bookmark._iter[_tmp6_] = _tmp9_;
				_tmp10_ = self->_bookmark._iter[_tmp6_];
			}
		}
	}
	_tmp11_ = cset;
	_tmp12_ = _g_object_ref0 (_tmp11_);
	_g_object_unref0 (self->_set);
	self->_set = _tmp12_;
	return self;
}


static GeeConcurrentSetRange* gee_concurrent_set_range_new_tail (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset, gconstpointer start) {
	return gee_concurrent_set_range_construct_tail (GEE_CONCURRENT_SET_TYPE_RANGE, g_type, g_dup_func, g_destroy_func, cset, start);
}


static GeeConcurrentSetRange* gee_concurrent_set_range_construct_empty (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset) {
	GeeConcurrentSetRange* self = NULL;
	GeeConcurrentSet* _tmp0_;
	GeeConcurrentSet* _tmp1_;
	g_return_val_if_fail (cset != NULL, NULL);
	self = (GeeConcurrentSetRange*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	self->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
	_tmp0_ = cset;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->_set);
	self->_set = _tmp1_;
	return self;
}


static GeeConcurrentSetRange* gee_concurrent_set_range_new_empty (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSet* cset) {
	return gee_concurrent_set_range_construct_empty (GEE_CONCURRENT_SET_TYPE_RANGE, g_type, g_dup_func, g_destroy_func, cset);
}


static void gee_concurrent_set_range_copy_bookmark (GeeConcurrentSetRange* self, GeeConcurrentSetRange* range) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (range != NULL);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_;
				gint _tmp3_;
				gint _tmp4_;
				GeeConcurrentSetRange* _tmp5_;
				gint _tmp6_;
				gpointer _tmp7_ = NULL;
				GeeConcurrentSetTower* _tmp8_;
				_tmp1_ = _tmp0_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp3_ = i;
				if (!(_tmp3_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp4_ = i;
				_tmp5_ = range;
				_tmp6_ = i;
				_tmp7_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp5_->_bookmark._iter[_tmp6_], (gsize) 0, NULL);
				_gee_concurrent_set_tower_unref0 (self->_bookmark._iter[_tmp4_]);
				self->_bookmark._iter[_tmp4_] = (GeeConcurrentSetTower*) _tmp7_;
				_tmp8_ = self->_bookmark._iter[_tmp4_];
			}
		}
	}
}


static GeeConcurrentSetRange* gee_concurrent_set_range_cut_head (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* from, gconstpointer start) {
	GeeConcurrentSetRange* result = NULL;
	GeeConcurrentSetRange* _tmp0_;
	GeeConcurrentSet* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetRange* _result_;
	GeeConcurrentSetRange* _tmp3_;
	GeeConcurrentSetRangeType _tmp4_;
	GeeConcurrentSetRange* _tmp52_;
	GeeConcurrentSetRangeType _tmp53_;
	g_return_val_if_fail (from != NULL, NULL);
	_tmp0_ = from;
	_tmp1_ = _tmp0_->_set;
	_tmp2_ = gee_concurrent_set_range_new_empty (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = from;
	_tmp4_ = _tmp3_->_type;
	switch (_tmp4_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			GeeConcurrentSetRange* _tmp5_;
			GeeConcurrentSet* _tmp6_;
			GCompareDataFunc _tmp7_;
			void* _tmp7__target;
			gconstpointer _tmp8_;
			GeeConcurrentSetRange* _tmp9_;
			gconstpointer _tmp10_;
			gint _tmp11_ = 0;
			_tmp5_ = from;
			_tmp6_ = _tmp5_->_set;
			_tmp7_ = _tmp6_->priv->_cmp;
			_tmp7__target = _tmp6_->priv->_cmp_target;
			_tmp8_ = start;
			_tmp9_ = from;
			_tmp10_ = _tmp9_->_end;
			_tmp11_ = _tmp7_ (_tmp8_, _tmp10_, _tmp7__target);
			if (_tmp11_ < 0) {
				GeeConcurrentSetRange* _tmp12_;
				gconstpointer _tmp13_;
				gpointer _tmp14_;
				GeeConcurrentSetRange* _tmp15_;
				GeeConcurrentSetRange* _tmp16_;
				gconstpointer _tmp17_;
				gpointer _tmp18_;
				GeeConcurrentSetRange* _tmp19_;
				_tmp12_ = _result_;
				_tmp13_ = start;
				_tmp14_ = ((_tmp13_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp13_) : ((gpointer) _tmp13_);
				_g_destroy_func0 (_tmp12_->_start);
				_tmp12_->_start = _tmp14_;
				_tmp15_ = _result_;
				_tmp16_ = from;
				_tmp17_ = _tmp16_->_end;
				_tmp18_ = ((_tmp17_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp17_) : ((gpointer) _tmp17_);
				_g_destroy_func0 (_tmp15_->_end);
				_tmp15_->_end = _tmp18_;
				_tmp19_ = _result_;
				_tmp19_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
			} else {
				GeeConcurrentSetRange* _tmp20_;
				_tmp20_ = _result_;
				_tmp20_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			}
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSetRange* _tmp21_;
			GeeConcurrentSetRange* _tmp22_;
			GeeConcurrentSet* _tmp23_;
			GeeConcurrentSetRange* _tmp24_;
			gconstpointer _tmp25_;
			gconstpointer _tmp26_;
			gconstpointer _tmp27_ = NULL;
			gpointer _tmp28_;
			GeeConcurrentSetRange* _tmp29_;
			_tmp21_ = _result_;
			_tmp22_ = from;
			_tmp23_ = _tmp22_->_set;
			_tmp24_ = from;
			_tmp25_ = _tmp24_->_start;
			_tmp26_ = start;
			_tmp27_ = gee_concurrent_set_max (_tmp23_, _tmp25_, _tmp26_, NULL);
			_tmp28_ = ((_tmp27_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp27_) : ((gpointer) _tmp27_);
			_g_destroy_func0 (_tmp21_->_start);
			_tmp21_->_start = _tmp28_;
			_tmp29_ = _result_;
			_tmp29_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_TAIL;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetRange* _tmp30_;
			GeeConcurrentSet* _tmp31_;
			GCompareDataFunc _tmp32_;
			void* _tmp32__target;
			GeeConcurrentSetRange* _tmp33_;
			gconstpointer _tmp34_;
			gconstpointer _tmp35_;
			gint _tmp36_ = 0;
			_tmp30_ = from;
			_tmp31_ = _tmp30_->_set;
			_tmp32_ = _tmp31_->priv->_cmp;
			_tmp32__target = _tmp31_->priv->_cmp_target;
			_tmp33_ = from;
			_tmp34_ = _tmp33_->_start;
			_tmp35_ = start;
			_tmp36_ = _tmp32_ (_tmp34_, _tmp35_, _tmp32__target);
			if (_tmp36_ < 0) {
				GeeConcurrentSetRange* _tmp37_;
				GeeConcurrentSetRange* _tmp38_;
				GeeConcurrentSet* _tmp39_;
				GeeConcurrentSetRange* _tmp40_;
				gconstpointer _tmp41_;
				gconstpointer _tmp42_;
				gconstpointer _tmp43_ = NULL;
				gpointer _tmp44_;
				GeeConcurrentSetRange* _tmp45_;
				GeeConcurrentSetRange* _tmp46_;
				gconstpointer _tmp47_;
				gpointer _tmp48_;
				GeeConcurrentSetRange* _tmp49_;
				_tmp37_ = _result_;
				_tmp38_ = from;
				_tmp39_ = _tmp38_->_set;
				_tmp40_ = from;
				_tmp41_ = _tmp40_->_start;
				_tmp42_ = start;
				_tmp43_ = gee_concurrent_set_max (_tmp39_, _tmp41_, _tmp42_, NULL);
				_tmp44_ = ((_tmp43_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp43_) : ((gpointer) _tmp43_);
				_g_destroy_func0 (_tmp37_->_start);
				_tmp37_->_start = _tmp44_;
				_tmp45_ = _result_;
				_tmp46_ = from;
				_tmp47_ = _tmp46_->_end;
				_tmp48_ = ((_tmp47_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp47_) : ((gpointer) _tmp47_);
				_g_destroy_func0 (_tmp45_->_end);
				_tmp45_->_end = _tmp48_;
				_tmp49_ = _result_;
				_tmp49_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
			} else {
				GeeConcurrentSetRange* _tmp50_;
				_tmp50_ = _result_;
				_tmp50_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			}
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			GeeConcurrentSetRange* _tmp51_;
			_tmp51_ = _result_;
			_tmp51_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			break;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_tmp52_ = _result_;
	_tmp53_ = _tmp52_->_type;
	if (_tmp53_ != GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY) {
		GeeConcurrentSetRange* _tmp54_;
		GeeConcurrentSetRange* _tmp55_;
		GeeConcurrentSetRange* _tmp56_;
		GeeConcurrentSetRange* _tmp57_;
		_tmp54_ = from;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp54_, NULL, NULL);
		_tmp55_ = _result_;
		_tmp56_ = from;
		gee_concurrent_set_range_copy_bookmark (_tmp55_, _tmp56_);
		_tmp57_ = _result_;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp57_, NULL, NULL);
	}
	result = _result_;
	return result;
}


static GeeConcurrentSetRange* gee_concurrent_set_range_cut_tail (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* from, gconstpointer end) {
	GeeConcurrentSetRange* result = NULL;
	GeeConcurrentSetRange* _tmp0_;
	GeeConcurrentSet* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetRange* _result_;
	GeeConcurrentSetRange* _tmp3_;
	GeeConcurrentSetRangeType _tmp4_;
	GeeConcurrentSetRange* _tmp52_;
	GeeConcurrentSetRangeType _tmp53_;
	g_return_val_if_fail (from != NULL, NULL);
	_tmp0_ = from;
	_tmp1_ = _tmp0_->_set;
	_tmp2_ = gee_concurrent_set_range_new_empty (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = from;
	_tmp4_ = _tmp3_->_type;
	switch (_tmp4_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			GeeConcurrentSetRange* _tmp5_;
			GeeConcurrentSetRange* _tmp6_;
			GeeConcurrentSet* _tmp7_;
			GeeConcurrentSetRange* _tmp8_;
			gconstpointer _tmp9_;
			gconstpointer _tmp10_;
			gconstpointer _tmp11_ = NULL;
			gpointer _tmp12_;
			GeeConcurrentSetRange* _tmp13_;
			_tmp5_ = _result_;
			_tmp6_ = from;
			_tmp7_ = _tmp6_->_set;
			_tmp8_ = from;
			_tmp9_ = _tmp8_->_end;
			_tmp10_ = end;
			_tmp11_ = gee_concurrent_set_min (_tmp7_, _tmp9_, _tmp10_, NULL);
			_tmp12_ = ((_tmp11_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp11_) : ((gpointer) _tmp11_);
			_g_destroy_func0 (_tmp5_->_end);
			_tmp5_->_end = _tmp12_;
			_tmp13_ = _result_;
			_tmp13_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_HEAD;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSetRange* _tmp14_;
			GeeConcurrentSet* _tmp15_;
			GCompareDataFunc _tmp16_;
			void* _tmp16__target;
			GeeConcurrentSetRange* _tmp17_;
			gconstpointer _tmp18_;
			gconstpointer _tmp19_;
			gint _tmp20_ = 0;
			_tmp14_ = from;
			_tmp15_ = _tmp14_->_set;
			_tmp16_ = _tmp15_->priv->_cmp;
			_tmp16__target = _tmp15_->priv->_cmp_target;
			_tmp17_ = from;
			_tmp18_ = _tmp17_->_start;
			_tmp19_ = end;
			_tmp20_ = _tmp16_ (_tmp18_, _tmp19_, _tmp16__target);
			if (_tmp20_ < 0) {
				GeeConcurrentSetRange* _tmp21_;
				GeeConcurrentSetRange* _tmp22_;
				gconstpointer _tmp23_;
				gpointer _tmp24_;
				GeeConcurrentSetRange* _tmp25_;
				gconstpointer _tmp26_;
				gpointer _tmp27_;
				GeeConcurrentSetRange* _tmp28_;
				_tmp21_ = _result_;
				_tmp22_ = from;
				_tmp23_ = _tmp22_->_start;
				_tmp24_ = ((_tmp23_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp23_) : ((gpointer) _tmp23_);
				_g_destroy_func0 (_tmp21_->_start);
				_tmp21_->_start = _tmp24_;
				_tmp25_ = _result_;
				_tmp26_ = end;
				_tmp27_ = ((_tmp26_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp26_) : ((gpointer) _tmp26_);
				_g_destroy_func0 (_tmp25_->_end);
				_tmp25_->_end = _tmp27_;
				_tmp28_ = _result_;
				_tmp28_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
			} else {
				GeeConcurrentSetRange* _tmp29_;
				_tmp29_ = _result_;
				_tmp29_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			}
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetRange* _tmp30_;
			GeeConcurrentSet* _tmp31_;
			GCompareDataFunc _tmp32_;
			void* _tmp32__target;
			GeeConcurrentSetRange* _tmp33_;
			gconstpointer _tmp34_;
			gconstpointer _tmp35_;
			gint _tmp36_ = 0;
			_tmp30_ = from;
			_tmp31_ = _tmp30_->_set;
			_tmp32_ = _tmp31_->priv->_cmp;
			_tmp32__target = _tmp31_->priv->_cmp_target;
			_tmp33_ = from;
			_tmp34_ = _tmp33_->_start;
			_tmp35_ = end;
			_tmp36_ = _tmp32_ (_tmp34_, _tmp35_, _tmp32__target);
			if (_tmp36_ < 0) {
				GeeConcurrentSetRange* _tmp37_;
				GeeConcurrentSetRange* _tmp38_;
				gconstpointer _tmp39_;
				gpointer _tmp40_;
				GeeConcurrentSetRange* _tmp41_;
				GeeConcurrentSetRange* _tmp42_;
				GeeConcurrentSet* _tmp43_;
				GeeConcurrentSetRange* _tmp44_;
				gconstpointer _tmp45_;
				gconstpointer _tmp46_;
				gconstpointer _tmp47_ = NULL;
				gpointer _tmp48_;
				GeeConcurrentSetRange* _tmp49_;
				_tmp37_ = _result_;
				_tmp38_ = from;
				_tmp39_ = _tmp38_->_start;
				_tmp40_ = ((_tmp39_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp39_) : ((gpointer) _tmp39_);
				_g_destroy_func0 (_tmp37_->_start);
				_tmp37_->_start = _tmp40_;
				_tmp41_ = _result_;
				_tmp42_ = from;
				_tmp43_ = _tmp42_->_set;
				_tmp44_ = from;
				_tmp45_ = _tmp44_->_end;
				_tmp46_ = end;
				_tmp47_ = gee_concurrent_set_min (_tmp43_, _tmp45_, _tmp46_, NULL);
				_tmp48_ = ((_tmp47_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp47_) : ((gpointer) _tmp47_);
				_g_destroy_func0 (_tmp41_->_end);
				_tmp41_->_end = _tmp48_;
				_tmp49_ = _result_;
				_tmp49_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
			} else {
				GeeConcurrentSetRange* _tmp50_;
				_tmp50_ = _result_;
				_tmp50_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			}
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			GeeConcurrentSetRange* _tmp51_;
			_tmp51_ = _result_;
			_tmp51_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			break;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_tmp52_ = _result_;
	_tmp53_ = _tmp52_->_type;
	if (_tmp53_ != GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY) {
		GeeConcurrentSetRange* _tmp54_;
		GeeConcurrentSetRange* _tmp55_;
		GeeConcurrentSetRange* _tmp56_;
		GeeConcurrentSetRange* _tmp57_;
		_tmp54_ = from;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp54_, NULL, NULL);
		_tmp55_ = _result_;
		_tmp56_ = from;
		gee_concurrent_set_range_copy_bookmark (_tmp55_, _tmp56_);
		_tmp57_ = _result_;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp57_, NULL, NULL);
	}
	result = _result_;
	return result;
}


static GeeConcurrentSetRange* gee_concurrent_set_range_cut (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* from, gconstpointer start, gconstpointer end) {
	GeeConcurrentSetRange* result = NULL;
	GeeConcurrentSetRange* _tmp0_;
	GeeConcurrentSet* _tmp1_;
	GeeConcurrentSetRange* _tmp2_;
	GeeConcurrentSetRange* _result_;
	GeeConcurrentSetRange* _tmp3_;
	GeeConcurrentSetRange* _tmp4_;
	GeeConcurrentSetRangeType _tmp5_;
	gboolean _tmp31_ = FALSE;
	GeeConcurrentSetRange* _tmp32_;
	GeeConcurrentSetRangeType _tmp33_;
	gboolean _tmp40_;
	GeeConcurrentSetRange* _tmp49_;
	GeeConcurrentSetRangeType _tmp50_;
	g_return_val_if_fail (from != NULL, NULL);
	_tmp0_ = from;
	_tmp1_ = _tmp0_->_set;
	_tmp2_ = gee_concurrent_set_range_new_empty (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	_tmp3_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
	_tmp4_ = from;
	_tmp5_ = _tmp4_->_type;
	switch (_tmp5_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			GeeConcurrentSetRange* _tmp6_;
			GeeConcurrentSet* _tmp7_;
			GeeConcurrentSetRange* _tmp8_;
			gconstpointer _tmp9_;
			gconstpointer _tmp10_;
			gconstpointer _tmp11_ = NULL;
			_tmp6_ = from;
			_tmp7_ = _tmp6_->_set;
			_tmp8_ = from;
			_tmp9_ = _tmp8_->_end;
			_tmp10_ = end;
			_tmp11_ = gee_concurrent_set_min (_tmp7_, _tmp9_, _tmp10_, NULL);
			end = _tmp11_;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSetRange* _tmp12_;
			GeeConcurrentSet* _tmp13_;
			GeeConcurrentSetRange* _tmp14_;
			gconstpointer _tmp15_;
			gconstpointer _tmp16_;
			gconstpointer _tmp17_ = NULL;
			_tmp12_ = from;
			_tmp13_ = _tmp12_->_set;
			_tmp14_ = from;
			_tmp15_ = _tmp14_->_start;
			_tmp16_ = start;
			_tmp17_ = gee_concurrent_set_max (_tmp13_, _tmp15_, _tmp16_, NULL);
			start = _tmp17_;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetRange* _tmp18_;
			GeeConcurrentSet* _tmp19_;
			GeeConcurrentSetRange* _tmp20_;
			gconstpointer _tmp21_;
			gconstpointer _tmp22_;
			gconstpointer _tmp23_ = NULL;
			GeeConcurrentSetRange* _tmp24_;
			GeeConcurrentSet* _tmp25_;
			GeeConcurrentSetRange* _tmp26_;
			gconstpointer _tmp27_;
			gconstpointer _tmp28_;
			gconstpointer _tmp29_ = NULL;
			_tmp18_ = from;
			_tmp19_ = _tmp18_->_set;
			_tmp20_ = from;
			_tmp21_ = _tmp20_->_start;
			_tmp22_ = start;
			_tmp23_ = gee_concurrent_set_max (_tmp19_, _tmp21_, _tmp22_, NULL);
			start = _tmp23_;
			_tmp24_ = from;
			_tmp25_ = _tmp24_->_set;
			_tmp26_ = from;
			_tmp27_ = _tmp26_->_end;
			_tmp28_ = end;
			_tmp29_ = gee_concurrent_set_min (_tmp25_, _tmp27_, _tmp28_, NULL);
			end = _tmp29_;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			GeeConcurrentSetRange* _tmp30_;
			_tmp30_ = _result_;
			_tmp30_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
			break;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	_tmp32_ = _result_;
	_tmp33_ = _tmp32_->_type;
	if (_tmp33_ != GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY) {
		GeeConcurrentSetRange* _tmp34_;
		GeeConcurrentSet* _tmp35_;
		GCompareDataFunc _tmp36_;
		void* _tmp36__target;
		gconstpointer _tmp37_;
		gconstpointer _tmp38_;
		gint _tmp39_ = 0;
		_tmp34_ = from;
		_tmp35_ = _tmp34_->_set;
		_tmp36_ = _tmp35_->priv->_cmp;
		_tmp36__target = _tmp35_->priv->_cmp_target;
		_tmp37_ = start;
		_tmp38_ = end;
		_tmp39_ = _tmp36_ (_tmp37_, _tmp38_, _tmp36__target);
		_tmp31_ = _tmp39_ < 0;
	} else {
		_tmp31_ = FALSE;
	}
	_tmp40_ = _tmp31_;
	if (_tmp40_) {
		GeeConcurrentSetRange* _tmp41_;
		gconstpointer _tmp42_;
		gpointer _tmp43_;
		GeeConcurrentSetRange* _tmp44_;
		gconstpointer _tmp45_;
		gpointer _tmp46_;
		GeeConcurrentSetRange* _tmp47_;
		_tmp41_ = _result_;
		_tmp42_ = start;
		_tmp43_ = ((_tmp42_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp42_) : ((gpointer) _tmp42_);
		_g_destroy_func0 (_tmp41_->_start);
		_tmp41_->_start = _tmp43_;
		_tmp44_ = _result_;
		_tmp45_ = end;
		_tmp46_ = ((_tmp45_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp45_) : ((gpointer) _tmp45_);
		_g_destroy_func0 (_tmp44_->_end);
		_tmp44_->_end = _tmp46_;
		_tmp47_ = _result_;
		_tmp47_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED;
	} else {
		GeeConcurrentSetRange* _tmp48_;
		_tmp48_ = _result_;
		_tmp48_->_type = GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY;
	}
	_tmp49_ = _result_;
	_tmp50_ = _tmp49_->_type;
	if (_tmp50_ != GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY) {
		GeeConcurrentSetRange* _tmp51_;
		GeeConcurrentSetRange* _tmp52_;
		GeeConcurrentSetRange* _tmp53_;
		GeeConcurrentSetRange* _tmp54_;
		_tmp51_ = from;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp51_, NULL, NULL);
		_tmp52_ = _result_;
		_tmp53_ = from;
		gee_concurrent_set_range_copy_bookmark (_tmp52_, _tmp53_);
		_tmp54_ = _result_;
		gee_concurrent_set_range_improve_bookmark (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp54_, NULL, NULL);
	}
	result = _result_;
	return result;
}


static void gee_concurrent_set_range_improve_bookmark (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTower** out_curr, GeeConcurrentSetTowerIter* prev) {
	GeeConcurrentSetTower* _vala_out_curr = NULL;
	GeeConcurrentSetTowerIter _vala_prev = {0};
	GeeConcurrentSetRange* _tmp0_;
	GeeConcurrentSetRangeType _tmp1_;
	gboolean _tmp112_ = FALSE;
	gboolean _tmp113_ = FALSE;
	gboolean _tmp115_;
	gboolean _tmp119_;
	g_return_if_fail (range != NULL);
	gee_concurrent_set_tower_iter_destroy (&_vala_prev);
	memset (&_vala_prev, 0, sizeof (GeeConcurrentSetTowerIter));
	_tmp0_ = range;
	_tmp1_ = _tmp0_->_type;
	switch (_tmp1_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			if ((&_vala_out_curr) != NULL) {
				GeeConcurrentSetRange* _tmp2_;
				gpointer _tmp3_ = NULL;
				_tmp2_ = range;
				_tmp3_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp2_->_bookmark._iter[0], (gsize) 0, NULL);
				_gee_concurrent_set_tower_unref0 (_vala_out_curr);
				_vala_out_curr = (GeeConcurrentSetTower*) _tmp3_;
				if ((&_vala_prev) != NULL) {
					GeeConcurrentSetTower* _tmp4_;
					GeeConcurrentSetTower* _tmp5_;
					GeeConcurrentSetTowerIter _tmp6_;
					GeeConcurrentSetTower* _tmp7_;
					GeeConcurrentSetTower* _tmp8_ = NULL;
					_tmp4_ = _vala_out_curr;
					_vala_out_curr = NULL;
					_gee_concurrent_set_tower_unref0 (_vala_prev._iter[0]);
					_vala_prev._iter[0] = _tmp4_;
					_tmp5_ = _vala_prev._iter[0];
					_tmp6_ = _vala_prev;
					_tmp7_ = _tmp6_._iter[0];
					_tmp8_ = gee_concurrent_set_tower_get_next (_tmp7_, (guint8) 0);
					_gee_concurrent_set_tower_unref0 (_vala_out_curr);
					_vala_out_curr = _tmp8_;
				} else {
					GeeConcurrentSetTower* _tmp9_;
					GeeConcurrentSetTower* _tmp10_ = NULL;
					_tmp9_ = _vala_out_curr;
					_tmp10_ = gee_concurrent_set_tower_get_next (_tmp9_, (guint8) 0);
					_gee_concurrent_set_tower_unref0 (_vala_out_curr);
					_vala_out_curr = _tmp10_;
				}
			}
			if ((&_vala_prev) != NULL) {
				{
					gint _tmp11_ = 0;
					gint _tmp12_;
					gint i;
					if ((&_vala_out_curr) != NULL) {
						_tmp11_ = 1;
					} else {
						_tmp11_ = 0;
					}
					_tmp12_ = _tmp11_;
					i = _tmp12_;
					{
						gboolean _tmp13_;
						_tmp13_ = TRUE;
						while (TRUE) {
							gboolean _tmp14_;
							gint _tmp16_;
							gint _tmp17_;
							GeeConcurrentSetRange* _tmp18_;
							gint _tmp19_;
							gpointer _tmp20_ = NULL;
							GeeConcurrentSetTower* _tmp21_;
							_tmp14_ = _tmp13_;
							if (!_tmp14_) {
								gint _tmp15_;
								_tmp15_ = i;
								i = _tmp15_ + 1;
							}
							_tmp13_ = FALSE;
							_tmp16_ = i;
							if (!(_tmp16_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
								break;
							}
							_tmp17_ = i;
							_tmp18_ = range;
							_tmp19_ = i;
							_tmp20_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp18_->_bookmark._iter[_tmp19_], (gsize) 0, NULL);
							_gee_concurrent_set_tower_unref0 (_vala_prev._iter[_tmp17_]);
							_vala_prev._iter[_tmp17_] = (GeeConcurrentSetTower*) _tmp20_;
							_tmp21_ = _vala_prev._iter[_tmp17_];
						}
					}
				}
			}
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			_gee_concurrent_set_tower_unref0 (_vala_out_curr);
			_vala_out_curr = NULL;
			break;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetTower* last_best;
			last_best = NULL;
			{
				gint i;
				i = GEE_CONCURRENT_SET__MAX_HEIGHT - 1;
				{
					gboolean _tmp22_;
					_tmp22_ = TRUE;
					while (TRUE) {
						gboolean _tmp23_;
						gint _tmp25_;
						GeeConcurrentSetRange* _tmp26_;
						gint _tmp27_;
						gpointer _tmp28_ = NULL;
						GeeConcurrentSetTower* curr;
						GeeConcurrentSetTower* _tmp29_;
						GeeConcurrentSetTower* _tmp30_;
						GeeConcurrentSetTower* curr_old;
						GeeConcurrentSetTower* _tmp31_;
						gint _tmp32_;
						gboolean _tmp33_ = FALSE;
						gboolean _tmp34_ = FALSE;
						GeeConcurrentSetTower* _tmp35_;
						gboolean _tmp38_;
						gboolean _tmp45_;
						GeeConcurrentSetTower* _tmp48_;
						GeeConcurrentSetTower* _tmp49_;
						GeeConcurrentSetTower* _tmp59_;
						gint _tmp60_;
						GeeConcurrentSetTower* _tmp61_ = NULL;
						GeeConcurrentSetTower* next;
						gboolean _tmp62_ = FALSE;
						gboolean _tmp64_;
						GeeConcurrentSetTower* _tmp111_;
						_tmp23_ = _tmp22_;
						if (!_tmp23_) {
							gint _tmp24_;
							_tmp24_ = i;
							i = _tmp24_ - 1;
						}
						_tmp22_ = FALSE;
						_tmp25_ = i;
						if (!(_tmp25_ >= 0)) {
							break;
						}
						_tmp26_ = range;
						_tmp27_ = i;
						_tmp28_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp26_->_bookmark._iter[_tmp27_], (gsize) 0, NULL);
						curr = (GeeConcurrentSetTower*) _tmp28_;
						_tmp29_ = curr;
						_tmp30_ = _gee_concurrent_set_tower_ref0 (_tmp29_);
						curr_old = _tmp30_;
						_tmp31_ = curr;
						_vala_assert (_tmp31_ != NULL, "curr != null");
						_tmp32_ = i;
						gee_concurrent_set_tower_backtrace (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, &curr, (guint8) _tmp32_);
						_tmp35_ = last_best;
						if (_tmp35_ != NULL) {
							GeeConcurrentSetTower* _tmp36_;
							GeeConcurrentSetTower* _tmp37_;
							_tmp36_ = last_best;
							_tmp37_ = curr;
							_tmp34_ = _tmp36_ != _tmp37_;
						} else {
							_tmp34_ = FALSE;
						}
						_tmp38_ = _tmp34_;
						if (_tmp38_) {
							GeeConcurrentSetRange* _tmp39_;
							GeeConcurrentSet* _tmp40_;
							GCompareDataFunc _tmp41_;
							void* _tmp41__target;
							GeeConcurrentSetTower* _tmp42_;
							GeeConcurrentSetTower* _tmp43_;
							gint _tmp44_ = 0;
							_tmp39_ = range;
							_tmp40_ = _tmp39_->_set;
							_tmp41_ = _tmp40_->priv->_cmp;
							_tmp41__target = _tmp40_->priv->_cmp_target;
							_tmp42_ = curr;
							_tmp43_ = last_best;
							_tmp44_ = gee_concurrent_set_tower_compare (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp41_, _tmp41__target, _tmp42_, _tmp43_);
							_tmp33_ = _tmp44_ < 0;
						} else {
							_tmp33_ = FALSE;
						}
						_tmp45_ = _tmp33_;
						if (_tmp45_) {
							GeeConcurrentSetTower* _tmp46_;
							GeeConcurrentSetTower* _tmp47_;
							_tmp46_ = last_best;
							_tmp47_ = _gee_concurrent_set_tower_ref0 (_tmp46_);
							_gee_concurrent_set_tower_unref0 (curr);
							curr = _tmp47_;
						}
						_tmp48_ = curr;
						_tmp49_ = curr_old;
						if (_tmp48_ != _tmp49_) {
							GeeConcurrentSetRange* _tmp50_;
							gint _tmp51_;
							GeeConcurrentSetTower* _tmp52_;
							GeeConcurrentSetTower* _tmp53_;
							GeeConcurrentSetTower* _tmp54_;
							gboolean _tmp55_ = FALSE;
							_tmp50_ = range;
							_tmp51_ = i;
							_tmp52_ = curr_old;
							_tmp53_ = curr;
							_tmp54_ = _gee_concurrent_set_tower_ref0 (_tmp53_);
							_tmp55_ = gee_hazard_pointer_compare_and_exchange_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp50_->_bookmark._iter[_tmp51_], _tmp52_, _tmp54_, (gsize) 0, (gsize) 0, (gsize) 0);
							if (!_tmp55_) {
								GeeConcurrentSetRange* _tmp56_;
								gint _tmp57_;
								gpointer _tmp58_ = NULL;
								_tmp56_ = range;
								_tmp57_ = i;
								_tmp58_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp56_->_bookmark._iter[_tmp57_], (gsize) 0, NULL);
								_gee_concurrent_set_tower_unref0 (curr);
								curr = (GeeConcurrentSetTower*) _tmp58_;
							}
						}
						_tmp59_ = curr;
						_tmp60_ = i;
						_tmp61_ = gee_concurrent_set_tower_get_next (_tmp59_, (guint8) _tmp60_);
						next = _tmp61_;
						if ((&_vala_out_curr) != NULL) {
							gint _tmp63_;
							_tmp63_ = i;
							_tmp62_ = _tmp63_ == 0;
						} else {
							_tmp62_ = FALSE;
						}
						_tmp64_ = _tmp62_;
						if (_tmp64_) {
							GeeConcurrentSetTower* _tmp65_;
							GeeConcurrentSetTower* _tmp66_;
							_tmp65_ = next;
							_tmp66_ = _gee_concurrent_set_tower_ref0 (_tmp65_);
							_gee_concurrent_set_tower_unref0 (_vala_out_curr);
							_vala_out_curr = _tmp66_;
						}
						while (TRUE) {
							gboolean _tmp67_ = FALSE;
							GeeConcurrentSetTower* _tmp68_;
							gboolean _tmp76_;
							GeeConcurrentSetRange* _tmp77_;
							GeeConcurrentSet* _tmp78_;
							GCompareDataFunc _tmp79_;
							void* _tmp79__target;
							gint _tmp80_;
							gboolean _tmp81_ = FALSE;
							gboolean _tmp82_ = FALSE;
							gboolean _tmp84_;
							gboolean _tmp86_;
							GeeConcurrentSetRange* _tmp89_;
							GeeConcurrentSet* _tmp90_;
							GCompareDataFunc _tmp91_;
							void* _tmp91__target;
							GeeConcurrentSetTower* _tmp92_;
							GeeConcurrentSetRange* _tmp93_;
							gconstpointer _tmp94_;
							gint _tmp95_ = 0;
							_tmp68_ = next;
							if (_tmp68_ != NULL) {
								GeeConcurrentSetRange* _tmp69_;
								GeeConcurrentSet* _tmp70_;
								GCompareDataFunc _tmp71_;
								void* _tmp71__target;
								GeeConcurrentSetTower* _tmp72_;
								GeeConcurrentSetRange* _tmp73_;
								gconstpointer _tmp74_;
								gint _tmp75_ = 0;
								_tmp69_ = range;
								_tmp70_ = _tmp69_->_set;
								_tmp71_ = _tmp70_->priv->_cmp;
								_tmp71__target = _tmp70_->priv->_cmp_target;
								_tmp72_ = next;
								_tmp73_ = range;
								_tmp74_ = _tmp73_->_start;
								_tmp75_ = gee_concurrent_set_tower_compare_data (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp71_, _tmp71__target, _tmp72_, _tmp74_);
								_tmp67_ = _tmp75_ < 0;
							} else {
								_tmp67_ = FALSE;
							}
							_tmp76_ = _tmp67_;
							if (!_tmp76_) {
								break;
							}
							_tmp77_ = range;
							_tmp78_ = _tmp77_->_set;
							_tmp79_ = _tmp78_->priv->_cmp;
							_tmp79__target = _tmp78_->priv->_cmp_target;
							_tmp80_ = i;
							gee_concurrent_set_tower_proceed (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp79_, _tmp79__target, &curr, &next, (guint8) _tmp80_, TRUE);
							if ((&curr) != NULL) {
								gint _tmp83_;
								_tmp83_ = i;
								_tmp82_ = _tmp83_ == 0;
							} else {
								_tmp82_ = FALSE;
							}
							_tmp84_ = _tmp82_;
							if (_tmp84_) {
								GeeConcurrentSetTower* _tmp85_;
								_tmp85_ = next;
								_tmp81_ = _tmp85_ != NULL;
							} else {
								_tmp81_ = FALSE;
							}
							_tmp86_ = _tmp81_;
							if (_tmp86_) {
								GeeConcurrentSetTower* _tmp87_;
								GeeConcurrentSetTower* _tmp88_;
								_tmp87_ = next;
								_tmp88_ = _gee_concurrent_set_tower_ref0 (_tmp87_);
								_gee_concurrent_set_tower_unref0 (_vala_out_curr);
								_vala_out_curr = _tmp88_;
							}
							_tmp89_ = range;
							_tmp90_ = _tmp89_->_set;
							_tmp91_ = _tmp90_->priv->_cmp;
							_tmp91__target = _tmp90_->priv->_cmp_target;
							_tmp92_ = curr;
							_tmp93_ = range;
							_tmp94_ = _tmp93_->_start;
							_tmp95_ = gee_concurrent_set_tower_compare_data (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp91_, _tmp91__target, _tmp92_, _tmp94_);
							if (_tmp95_ < 0) {
								GeeConcurrentSetRange* _tmp96_;
								gint _tmp97_;
								GeeConcurrentSetTower* _tmp98_;
								GeeConcurrentSetTower* _tmp99_;
								GeeConcurrentSetTower* _tmp100_;
								gboolean _tmp101_ = FALSE;
								GeeConcurrentSetTower* _tmp105_;
								GeeConcurrentSetTower* _tmp106_;
								_tmp96_ = range;
								_tmp97_ = i;
								_tmp98_ = curr_old;
								_tmp99_ = curr;
								_tmp100_ = _gee_concurrent_set_tower_ref0 (_tmp99_);
								_tmp101_ = gee_hazard_pointer_compare_and_exchange_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp96_->_bookmark._iter[_tmp97_], _tmp98_, _tmp100_, (gsize) 0, (gsize) 0, (gsize) 0);
								if (!_tmp101_) {
									GeeConcurrentSetRange* _tmp102_;
									gint _tmp103_;
									gpointer _tmp104_ = NULL;
									_tmp102_ = range;
									_tmp103_ = i;
									_tmp104_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp102_->_bookmark._iter[_tmp103_], (gsize) 0, NULL);
									_gee_concurrent_set_tower_unref0 (curr);
									curr = (GeeConcurrentSetTower*) _tmp104_;
								}
								_tmp105_ = curr;
								_tmp106_ = _gee_concurrent_set_tower_ref0 (_tmp105_);
								_gee_concurrent_set_tower_unref0 (curr_old);
								curr_old = _tmp106_;
							} else {
								break;
							}
						}
						if ((&_vala_prev) != NULL) {
							gint _tmp107_;
							GeeConcurrentSetTower* _tmp108_;
							GeeConcurrentSetTower* _tmp109_;
							GeeConcurrentSetTower* _tmp110_;
							_tmp107_ = i;
							_tmp108_ = curr;
							_tmp109_ = _gee_concurrent_set_tower_ref0 (_tmp108_);
							_gee_concurrent_set_tower_unref0 (_vala_prev._iter[_tmp107_]);
							_vala_prev._iter[_tmp107_] = _tmp109_;
							_tmp110_ = _vala_prev._iter[_tmp107_];
						}
						_tmp111_ = curr;
						curr = NULL;
						_gee_concurrent_set_tower_unref0 (last_best);
						last_best = _tmp111_;
						_gee_concurrent_set_tower_unref0 (next);
						_gee_concurrent_set_tower_unref0 (curr_old);
						_gee_concurrent_set_tower_unref0 (curr);
					}
				}
			}
			_gee_concurrent_set_tower_unref0 (last_best);
			break;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	if ((&_vala_out_curr) != NULL) {
		GeeConcurrentSetTower* _tmp114_;
		_tmp114_ = _vala_out_curr;
		_tmp113_ = _tmp114_ != NULL;
	} else {
		_tmp113_ = FALSE;
	}
	_tmp115_ = _tmp113_;
	if (_tmp115_) {
		GeeConcurrentSetRange* _tmp116_;
		GeeConcurrentSetTower* _tmp117_;
		gboolean _tmp118_ = FALSE;
		_tmp116_ = range;
		_tmp117_ = _vala_out_curr;
		_tmp118_ = gee_concurrent_set_range_beyond (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp116_, _tmp117_);
		_tmp112_ = _tmp118_;
	} else {
		_tmp112_ = FALSE;
	}
	_tmp119_ = _tmp112_;
	if (_tmp119_) {
		_gee_concurrent_set_tower_unref0 (_vala_out_curr);
		_vala_out_curr = NULL;
	}
	if (out_curr) {
		*out_curr = _vala_out_curr;
	} else {
		_gee_concurrent_set_tower_unref0 (_vala_out_curr);
	}
	if (prev) {
		*prev = _vala_prev;
	} else {
		gee_concurrent_set_tower_iter_destroy (&_vala_prev);
	}
}


static gboolean gee_concurrent_set_range_proceed (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTower** prev, GeeConcurrentSetTower** curr, guint8 level) {
	gboolean result = FALSE;
	GeeConcurrentSetRange* _tmp0_;
	GeeConcurrentSetRangeType _tmp1_;
	g_return_val_if_fail (range != NULL, FALSE);
	g_return_val_if_fail (*curr != NULL, FALSE);
	_tmp0_ = range;
	_tmp1_ = _tmp0_->_type;
	switch (_tmp1_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			result = FALSE;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSetRange* _tmp2_;
			GeeConcurrentSet* _tmp3_;
			GCompareDataFunc _tmp4_;
			void* _tmp4__target;
			guint8 _tmp5_;
			gboolean _tmp6_ = FALSE;
			_tmp2_ = range;
			_tmp3_ = _tmp2_->_set;
			_tmp4_ = _tmp3_->priv->_cmp;
			_tmp4__target = _tmp3_->priv->_cmp_target;
			_tmp5_ = level;
			_tmp6_ = gee_concurrent_set_tower_proceed (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp4_, _tmp4__target, prev, curr, _tmp5_, FALSE);
			result = _tmp6_;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetTower* _tmp7_;
			GeeConcurrentSetTower* _tmp8_;
			GeeConcurrentSetTower* tmp_prev;
			GeeConcurrentSetTower* _tmp9_;
			GeeConcurrentSetTower* _tmp10_;
			GeeConcurrentSetTower* tmp_curr;
			GeeConcurrentSetRange* _tmp11_;
			GeeConcurrentSet* _tmp12_;
			GCompareDataFunc _tmp13_;
			void* _tmp13__target;
			guint8 _tmp14_;
			gboolean _tmp15_ = FALSE;
			_tmp7_ = *prev;
			_tmp8_ = _gee_concurrent_set_tower_ref0 (_tmp7_);
			tmp_prev = _tmp8_;
			_tmp9_ = *curr;
			_tmp10_ = _gee_concurrent_set_tower_ref0 (_tmp9_);
			tmp_curr = _tmp10_;
			_tmp11_ = range;
			_tmp12_ = _tmp11_->_set;
			_tmp13_ = _tmp12_->priv->_cmp;
			_tmp13__target = _tmp12_->priv->_cmp_target;
			_tmp14_ = level;
			_tmp15_ = gee_concurrent_set_tower_proceed (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp13_, _tmp13__target, &tmp_prev, &tmp_curr, _tmp14_, FALSE);
			if (!_tmp15_) {
				result = FALSE;
				_gee_concurrent_set_tower_unref0 (tmp_curr);
				_gee_concurrent_set_tower_unref0 (tmp_prev);
				return result;
			} else {
				GeeConcurrentSetRange* _tmp16_;
				GeeConcurrentSet* _tmp17_;
				GCompareDataFunc _tmp18_;
				void* _tmp18__target;
				GeeConcurrentSetTower* _tmp19_;
				GeeConcurrentSetRange* _tmp20_;
				gconstpointer _tmp21_;
				gint _tmp22_ = 0;
				_tmp16_ = range;
				_tmp17_ = _tmp16_->_set;
				_tmp18_ = _tmp17_->priv->_cmp;
				_tmp18__target = _tmp17_->priv->_cmp_target;
				_tmp19_ = tmp_curr;
				_tmp20_ = range;
				_tmp21_ = _tmp20_->_end;
				_tmp22_ = gee_concurrent_set_tower_compare_data (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp18_, _tmp18__target, _tmp19_, _tmp21_);
				if (_tmp22_ >= 0) {
					result = FALSE;
					_gee_concurrent_set_tower_unref0 (tmp_curr);
					_gee_concurrent_set_tower_unref0 (tmp_prev);
					return result;
				} else {
					GeeConcurrentSetTower* _tmp23_;
					GeeConcurrentSetTower* _tmp24_;
					_tmp23_ = tmp_prev;
					tmp_prev = NULL;
					_gee_concurrent_set_tower_unref0 (*prev);
					*prev = _tmp23_;
					_tmp24_ = tmp_curr;
					tmp_curr = NULL;
					_gee_concurrent_set_tower_unref0 (*curr);
					*curr = _tmp24_;
					result = TRUE;
					_gee_concurrent_set_tower_unref0 (tmp_curr);
					_gee_concurrent_set_tower_unref0 (tmp_prev);
					return result;
				}
			}
			_gee_concurrent_set_tower_unref0 (tmp_curr);
			_gee_concurrent_set_tower_unref0 (tmp_prev);
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}


static gboolean gee_concurrent_set_range_inside (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, gconstpointer val) {
	gboolean result = FALSE;
	GeeConcurrentSetRange* _tmp0_;
	GeeConcurrentSetRangeType _tmp1_;
	g_return_val_if_fail (range != NULL, FALSE);
	_tmp0_ = range;
	_tmp1_ = _tmp0_->_type;
	switch (_tmp1_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			GeeConcurrentSetRange* _tmp2_;
			GeeConcurrentSet* _tmp3_;
			GCompareDataFunc _tmp4_;
			void* _tmp4__target;
			gconstpointer _tmp5_;
			GeeConcurrentSetRange* _tmp6_;
			gconstpointer _tmp7_;
			gint _tmp8_ = 0;
			_tmp2_ = range;
			_tmp3_ = _tmp2_->_set;
			_tmp4_ = _tmp3_->priv->_cmp;
			_tmp4__target = _tmp3_->priv->_cmp_target;
			_tmp5_ = val;
			_tmp6_ = range;
			_tmp7_ = _tmp6_->_end;
			_tmp8_ = _tmp4_ (_tmp5_, _tmp7_, _tmp4__target);
			result = _tmp8_ < 0;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSetRange* _tmp9_;
			GeeConcurrentSet* _tmp10_;
			GCompareDataFunc _tmp11_;
			void* _tmp11__target;
			gconstpointer _tmp12_;
			GeeConcurrentSetRange* _tmp13_;
			gconstpointer _tmp14_;
			gint _tmp15_ = 0;
			_tmp9_ = range;
			_tmp10_ = _tmp9_->_set;
			_tmp11_ = _tmp10_->priv->_cmp;
			_tmp11__target = _tmp10_->priv->_cmp_target;
			_tmp12_ = val;
			_tmp13_ = range;
			_tmp14_ = _tmp13_->_start;
			_tmp15_ = _tmp11_ (_tmp12_, _tmp14_, _tmp11__target);
			result = _tmp15_ >= 0;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			gboolean _tmp16_ = FALSE;
			GeeConcurrentSetRange* _tmp17_;
			GeeConcurrentSet* _tmp18_;
			GCompareDataFunc _tmp19_;
			void* _tmp19__target;
			gconstpointer _tmp20_;
			GeeConcurrentSetRange* _tmp21_;
			gconstpointer _tmp22_;
			gint _tmp23_ = 0;
			gboolean _tmp31_;
			_tmp17_ = range;
			_tmp18_ = _tmp17_->_set;
			_tmp19_ = _tmp18_->priv->_cmp;
			_tmp19__target = _tmp18_->priv->_cmp_target;
			_tmp20_ = val;
			_tmp21_ = range;
			_tmp22_ = _tmp21_->_start;
			_tmp23_ = _tmp19_ (_tmp20_, _tmp22_, _tmp19__target);
			if (_tmp23_ >= 0) {
				GeeConcurrentSetRange* _tmp24_;
				GeeConcurrentSet* _tmp25_;
				GCompareDataFunc _tmp26_;
				void* _tmp26__target;
				gconstpointer _tmp27_;
				GeeConcurrentSetRange* _tmp28_;
				gconstpointer _tmp29_;
				gint _tmp30_ = 0;
				_tmp24_ = range;
				_tmp25_ = _tmp24_->_set;
				_tmp26_ = _tmp25_->priv->_cmp;
				_tmp26__target = _tmp25_->priv->_cmp_target;
				_tmp27_ = val;
				_tmp28_ = range;
				_tmp29_ = _tmp28_->_end;
				_tmp30_ = _tmp26_ (_tmp27_, _tmp29_, _tmp26__target);
				_tmp16_ = _tmp30_ < 0;
			} else {
				_tmp16_ = FALSE;
			}
			_tmp31_ = _tmp16_;
			result = _tmp31_;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			result = FALSE;
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}


static gboolean gee_concurrent_set_range_beyond (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, GeeConcurrentSetTower* tw) {
	gboolean result = FALSE;
	GeeConcurrentSetRange* _tmp0_;
	GeeConcurrentSetRangeType _tmp1_;
	g_return_val_if_fail (range != NULL, FALSE);
	g_return_val_if_fail (tw != NULL, FALSE);
	_tmp0_ = range;
	_tmp1_ = _tmp0_->_type;
	switch (_tmp1_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			result = TRUE;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			result = FALSE;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetRange* _tmp2_;
			GeeConcurrentSet* _tmp3_;
			GCompareDataFunc _tmp4_;
			void* _tmp4__target;
			GeeConcurrentSetTower* _tmp5_;
			GeeConcurrentSetRange* _tmp6_;
			gconstpointer _tmp7_;
			gint _tmp8_ = 0;
			_tmp2_ = range;
			_tmp3_ = _tmp2_->_set;
			_tmp4_ = _tmp3_->priv->_cmp;
			_tmp4__target = _tmp3_->priv->_cmp_target;
			_tmp5_ = tw;
			_tmp6_ = range;
			_tmp7_ = _tmp6_->_end;
			_tmp8_ = gee_concurrent_set_tower_compare_data (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp4_, _tmp4__target, _tmp5_, _tmp7_);
			result = _tmp8_ >= 0;
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}


static gint gee_concurrent_set_range_cmp (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetRange* range, gconstpointer val) {
	gint result = 0;
	GeeConcurrentSetRange* _tmp0_;
	GeeConcurrentSetRangeType _tmp1_;
	g_return_val_if_fail (range != NULL, 0);
	_tmp0_ = range;
	_tmp1_ = _tmp0_->_type;
	switch (_tmp1_) {
		case GEE_CONCURRENT_SET_RANGE_TYPE_HEAD:
		{
			GeeConcurrentSetRangePosition _tmp2_ = 0;
			GeeConcurrentSetRange* _tmp3_;
			GeeConcurrentSet* _tmp4_;
			GCompareDataFunc _tmp5_;
			void* _tmp5__target;
			gconstpointer _tmp6_;
			GeeConcurrentSetRange* _tmp7_;
			gconstpointer _tmp8_;
			gint _tmp9_ = 0;
			GeeConcurrentSetRangePosition _tmp10_;
			_tmp3_ = range;
			_tmp4_ = _tmp3_->_set;
			_tmp5_ = _tmp4_->priv->_cmp;
			_tmp5__target = _tmp4_->priv->_cmp_target;
			_tmp6_ = val;
			_tmp7_ = range;
			_tmp8_ = _tmp7_->_end;
			_tmp9_ = _tmp5_ (_tmp6_, _tmp8_, _tmp5__target);
			if (_tmp9_ < 0) {
				_tmp2_ = GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE;
			} else {
				_tmp2_ = GEE_CONCURRENT_SET_RANGE_POSITION_AFTER;
			}
			_tmp10_ = _tmp2_;
			result = (gint) _tmp10_;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_TAIL:
		{
			GeeConcurrentSetRangePosition _tmp11_ = 0;
			GeeConcurrentSetRange* _tmp12_;
			GeeConcurrentSet* _tmp13_;
			GCompareDataFunc _tmp14_;
			void* _tmp14__target;
			gconstpointer _tmp15_;
			GeeConcurrentSetRange* _tmp16_;
			gconstpointer _tmp17_;
			gint _tmp18_ = 0;
			GeeConcurrentSetRangePosition _tmp19_;
			_tmp12_ = range;
			_tmp13_ = _tmp12_->_set;
			_tmp14_ = _tmp13_->priv->_cmp;
			_tmp14__target = _tmp13_->priv->_cmp_target;
			_tmp15_ = val;
			_tmp16_ = range;
			_tmp17_ = _tmp16_->_start;
			_tmp18_ = _tmp14_ (_tmp15_, _tmp17_, _tmp14__target);
			if (_tmp18_ >= 0) {
				_tmp11_ = GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE;
			} else {
				_tmp11_ = GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE;
			}
			_tmp19_ = _tmp11_;
			result = (gint) _tmp19_;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_BOUNDED:
		{
			GeeConcurrentSetRangePosition _tmp20_ = 0;
			GeeConcurrentSetRange* _tmp21_;
			GeeConcurrentSet* _tmp22_;
			GCompareDataFunc _tmp23_;
			void* _tmp23__target;
			gconstpointer _tmp24_;
			GeeConcurrentSetRange* _tmp25_;
			gconstpointer _tmp26_;
			gint _tmp27_ = 0;
			GeeConcurrentSetRangePosition _tmp37_;
			_tmp21_ = range;
			_tmp22_ = _tmp21_->_set;
			_tmp23_ = _tmp22_->priv->_cmp;
			_tmp23__target = _tmp22_->priv->_cmp_target;
			_tmp24_ = val;
			_tmp25_ = range;
			_tmp26_ = _tmp25_->_start;
			_tmp27_ = _tmp23_ (_tmp24_, _tmp26_, _tmp23__target);
			if (_tmp27_ >= 0) {
				GeeConcurrentSetRangePosition _tmp28_ = 0;
				GeeConcurrentSetRange* _tmp29_;
				GeeConcurrentSet* _tmp30_;
				GCompareDataFunc _tmp31_;
				void* _tmp31__target;
				gconstpointer _tmp32_;
				GeeConcurrentSetRange* _tmp33_;
				gconstpointer _tmp34_;
				gint _tmp35_ = 0;
				GeeConcurrentSetRangePosition _tmp36_;
				_tmp29_ = range;
				_tmp30_ = _tmp29_->_set;
				_tmp31_ = _tmp30_->priv->_cmp;
				_tmp31__target = _tmp30_->priv->_cmp_target;
				_tmp32_ = val;
				_tmp33_ = range;
				_tmp34_ = _tmp33_->_end;
				_tmp35_ = _tmp31_ (_tmp32_, _tmp34_, _tmp31__target);
				if (_tmp35_ < 0) {
					_tmp28_ = GEE_CONCURRENT_SET_RANGE_POSITION_INSIDE;
				} else {
					_tmp28_ = GEE_CONCURRENT_SET_RANGE_POSITION_AFTER;
				}
				_tmp36_ = _tmp28_;
				_tmp20_ = _tmp36_;
			} else {
				_tmp20_ = GEE_CONCURRENT_SET_RANGE_POSITION_BEFORE;
			}
			_tmp37_ = _tmp20_;
			result = (gint) _tmp37_;
			return result;
		}
		case GEE_CONCURRENT_SET_RANGE_TYPE_EMPTY:
		{
			result = (gint) GEE_CONCURRENT_SET_RANGE_POSITION_EMPTY;
			return result;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
}


static void gee_concurrent_set_value_range_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void gee_concurrent_set_value_range_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gee_concurrent_set_range_unref (value->data[0].v_pointer);
	}
}


static void gee_concurrent_set_value_range_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gee_concurrent_set_range_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer gee_concurrent_set_value_range_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* gee_concurrent_set_value_range_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		GeeConcurrentSetRange* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gee_concurrent_set_range_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* gee_concurrent_set_value_range_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	GeeConcurrentSetRange** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gee_concurrent_set_range_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* gee_concurrent_set_param_spec_range (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	GeeConcurrentSetParamSpecRange* spec;
	g_return_val_if_fail (g_type_is_a (object_type, GEE_CONCURRENT_SET_TYPE_RANGE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer gee_concurrent_set_value_get_range (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_RANGE), NULL);
	return value->data[0].v_pointer;
}


static void gee_concurrent_set_value_set_range (GValue* value, gpointer v_object) {
	GeeConcurrentSetRange* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_RANGE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEE_CONCURRENT_SET_TYPE_RANGE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gee_concurrent_set_range_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gee_concurrent_set_range_unref (old);
	}
}


static void gee_concurrent_set_value_take_range (GValue* value, gpointer v_object) {
	GeeConcurrentSetRange* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_RANGE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEE_CONCURRENT_SET_TYPE_RANGE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gee_concurrent_set_range_unref (old);
	}
}


static void gee_concurrent_set_range_class_init (GeeConcurrentSetRangeClass * klass) {
	gee_concurrent_set_range_parent_class = g_type_class_peek_parent (klass);
	GEE_CONCURRENT_SET_RANGE_CLASS (klass)->finalize = gee_concurrent_set_range_finalize;
	g_type_class_add_private (klass, sizeof (GeeConcurrentSetRangePrivate));
}


static void gee_concurrent_set_range_instance_init (GeeConcurrentSetRange * self) {
	self->priv = GEE_CONCURRENT_SET_RANGE_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void gee_concurrent_set_range_finalize (GeeConcurrentSetRange* obj) {
	GeeConcurrentSetRange * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_CONCURRENT_SET_TYPE_RANGE, GeeConcurrentSetRange);
	((self->_start == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->_start = (self->priv->g_destroy_func (self->_start), NULL));
	((self->_end == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->_end = (self->priv->g_destroy_func (self->_end), NULL));
	gee_concurrent_set_tower_iter_destroy (&self->_bookmark);
	_g_object_unref0 (self->_set);
}


static GType gee_concurrent_set_range_get_type (void) {
	static volatile gsize gee_concurrent_set_range_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_range_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { gee_concurrent_set_value_range_init, gee_concurrent_set_value_range_free_value, gee_concurrent_set_value_range_copy_value, gee_concurrent_set_value_range_peek_pointer, "p", gee_concurrent_set_value_range_collect_value, "p", gee_concurrent_set_value_range_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetRangeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_range_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSetRange), 0, (GInstanceInitFunc) gee_concurrent_set_range_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gee_concurrent_set_range_type_id;
		gee_concurrent_set_range_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GeeConcurrentSetRange", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gee_concurrent_set_range_type_id__volatile, gee_concurrent_set_range_type_id);
	}
	return gee_concurrent_set_range_type_id__volatile;
}


static gpointer gee_concurrent_set_range_ref (gpointer instance) {
	GeeConcurrentSetRange* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void gee_concurrent_set_range_unref (gpointer instance) {
	GeeConcurrentSetRange* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GEE_CONCURRENT_SET_RANGE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static GeeConcurrentSetTower* gee_concurrent_set_tower_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, gconstpointer data, guint8 height) {
	GeeConcurrentSetTower* self = NULL;
	guint8 _tmp0_;
	GeeConcurrentSetTowerNode* _tmp1_ = NULL;
	gconstpointer _tmp2_;
	gpointer _tmp3_;
	GeeConcurrentSetTowerNode* _tmp4_;
	gint _tmp4__length1;
	self = (GeeConcurrentSetTower*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = height;
	_tmp1_ = g_new0 (GeeConcurrentSetTowerNode, _tmp0_);
	self->_nodes = (g_free (self->_nodes), NULL);
	self->_nodes = _tmp1_;
	_tmp2_ = data;
	_tmp3_ = ((_tmp2_ != NULL) && (g_dup_func != NULL)) ? g_dup_func ((gpointer) _tmp2_) : ((gpointer) _tmp2_);
	_g_destroy_func0 (self->_data);
	self->_data = _tmp3_;
	self->_height = 0;
	_tmp4_ = self->_nodes;
	_tmp4__length1 = -1;
	g_atomic_pointer_set ((volatile gpointer *) (&_tmp4_[0]._backlink), NULL);
	return self;
}


static GeeConcurrentSetTower* gee_concurrent_set_tower_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, gconstpointer data, guint8 height) {
	return gee_concurrent_set_tower_construct (GEE_CONCURRENT_SET_TYPE_TOWER, g_type, g_dup_func, g_destroy_func, data, height);
}


static GeeConcurrentSetTower* gee_concurrent_set_tower_construct_head (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func) {
	GeeConcurrentSetTower* self = NULL;
	GeeConcurrentSetTowerNode* _tmp0_ = NULL;
	self = (GeeConcurrentSetTower*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	_tmp0_ = g_new0 (GeeConcurrentSetTowerNode, GEE_CONCURRENT_SET__MAX_HEIGHT);
	self->_nodes = (g_free (self->_nodes), NULL);
	self->_nodes = _tmp0_;
	self->_height = -1;
	return self;
}


static GeeConcurrentSetTower* gee_concurrent_set_tower_new_head (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func) {
	return gee_concurrent_set_tower_construct_head (GEE_CONCURRENT_SET_TYPE_TOWER, g_type, g_dup_func, g_destroy_func);
}


static inline gboolean gee_concurrent_set_tower_search (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, gconstpointer key, GeeConcurrentSetTower** prev, GeeConcurrentSetTower** next, guint8 to_level, guint8 from_level) {
	GeeConcurrentSetTower* _vala_next = NULL;
	gboolean result = FALSE;
	guint8 _tmp0_;
	guint8 _tmp1_;
	gboolean res;
	g_return_val_if_fail (*prev != NULL, FALSE);
	_tmp0_ = from_level;
	_tmp1_ = to_level;
	_vala_assert (_tmp0_ >= _tmp1_, "from_level >= to_level");
	res = FALSE;
	_gee_concurrent_set_tower_unref0 (_vala_next);
	_vala_next = NULL;
	{
		guint8 _tmp2_;
		gint i;
		_tmp2_ = from_level;
		i = (gint) _tmp2_;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_;
				gint _tmp6_;
				guint8 _tmp7_;
				GCompareDataFunc _tmp8_;
				void* _tmp8__target;
				gconstpointer _tmp9_;
				gint _tmp10_;
				GeeConcurrentSetTower* _tmp11_ = NULL;
				gboolean _tmp12_ = FALSE;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					gint _tmp5_;
					_tmp5_ = i;
					i = _tmp5_ - 1;
				}
				_tmp3_ = FALSE;
				_tmp6_ = i;
				_tmp7_ = to_level;
				if (!(_tmp6_ >= ((gint) _tmp7_))) {
					break;
				}
				_tmp8_ = cmp;
				_tmp8__target = cmp_target;
				_tmp9_ = key;
				_tmp10_ = i;
				_tmp12_ = gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp8_, _tmp8__target, _tmp9_, prev, &_tmp11_, (guint8) _tmp10_);
				_gee_concurrent_set_tower_unref0 (_vala_next);
				_vala_next = _tmp11_;
				res = _tmp12_;
			}
		}
	}
	result = res;
	if (next) {
		*next = _vala_next;
	} else {
		_gee_concurrent_set_tower_unref0 (_vala_next);
	}
	return result;
}


static inline gboolean gee_concurrent_set_tower_search_from_bookmark (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, gconstpointer key, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTowerIter* next, guint8 to_level, guint8 from_level) {
	GeeConcurrentSetTowerIter _vala_next = {0};
	gboolean result = FALSE;
	guint8 _tmp0_;
	guint8 _tmp1_;
	gboolean res;
	g_return_val_if_fail (prev != NULL, FALSE);
	_tmp0_ = from_level;
	_tmp1_ = to_level;
	_vala_assert (_tmp0_ >= _tmp1_, "from_level >= to_level");
	res = FALSE;
	{
		guint8 _tmp2_;
		gint i;
		_tmp2_ = from_level;
		i = (gint) _tmp2_;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_;
				gint _tmp6_;
				guint8 _tmp7_;
				GeeConcurrentSetTowerIter _tmp8_;
				gint _tmp9_;
				GeeConcurrentSetTower* _tmp10_;
				GeeConcurrentSetTower* tmp_prev;
				GeeConcurrentSetTower* tmp_next = NULL;
				GCompareDataFunc _tmp11_;
				void* _tmp11__target;
				gconstpointer _tmp12_;
				gint _tmp13_;
				gint _tmp14_;
				GeeConcurrentSetTower* _tmp15_ = NULL;
				gboolean _tmp16_ = FALSE;
				GeeConcurrentSetTowerIter _tmp20_;
				gint _tmp21_;
				GeeConcurrentSetTower* _tmp22_;
				GeeConcurrentSetTower* _tmp23_;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					gint _tmp5_;
					_tmp5_ = i;
					i = _tmp5_ - 1;
				}
				_tmp3_ = FALSE;
				_tmp6_ = i;
				_tmp7_ = to_level;
				if (!(_tmp6_ >= ((gint) _tmp7_))) {
					break;
				}
				_tmp8_ = *prev;
				_tmp9_ = i;
				_tmp10_ = _tmp8_._iter[_tmp9_];
				tmp_prev = _tmp10_;
				_tmp11_ = cmp;
				_tmp11__target = cmp_target;
				_tmp12_ = key;
				_tmp13_ = i;
				_tmp14_ = i;
				_tmp16_ = gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp11_, _tmp11__target, _tmp12_, &(*prev)._iter[_tmp13_], &_tmp15_, (guint8) _tmp14_);
				_gee_concurrent_set_tower_unref0 (tmp_next);
				tmp_next = _tmp15_;
				res = _tmp16_;
				if ((&_vala_next) != NULL) {
					gint _tmp17_;
					GeeConcurrentSetTower* _tmp18_;
					GeeConcurrentSetTower* _tmp19_;
					_tmp17_ = i;
					_tmp18_ = tmp_next;
					tmp_next = NULL;
					_gee_concurrent_set_tower_unref0 (_vala_next._iter[_tmp17_]);
					_vala_next._iter[_tmp17_] = _tmp18_;
					_tmp19_ = _vala_next._iter[_tmp17_];
				}
				_tmp20_ = *prev;
				_tmp21_ = i;
				_tmp22_ = _tmp20_._iter[_tmp21_];
				_tmp23_ = tmp_prev;
				if (_tmp22_ != _tmp23_) {
					gint _tmp24_;
					GeeConcurrentSetTowerIter _tmp25_;
					gint _tmp26_;
					GeeConcurrentSetTower* _tmp27_;
					GeeConcurrentSetTower* _tmp28_;
					GeeConcurrentSetTower* _tmp29_;
					gboolean _tmp30_ = FALSE;
					gint _tmp31_;
					guint8 _tmp32_;
					gboolean _tmp41_;
					_tmp24_ = i;
					_tmp25_ = *prev;
					_tmp26_ = i;
					_tmp27_ = _tmp25_._iter[_tmp26_];
					_tmp28_ = _gee_concurrent_set_tower_ref0 (_tmp27_);
					_gee_concurrent_set_tower_unref0 ((*prev)._iter[_tmp24_]);
					(*prev)._iter[_tmp24_] = _tmp28_;
					_tmp29_ = (*prev)._iter[_tmp24_];
					_tmp31_ = i;
					_tmp32_ = to_level;
					if (_tmp31_ > ((gint) _tmp32_)) {
						GCompareDataFunc _tmp33_;
						void* _tmp33__target;
						GeeConcurrentSetTowerIter _tmp34_;
						gint _tmp35_;
						GeeConcurrentSetTower* _tmp36_;
						GeeConcurrentSetTowerIter _tmp37_;
						gint _tmp38_;
						GeeConcurrentSetTower* _tmp39_;
						gint _tmp40_ = 0;
						_tmp33_ = cmp;
						_tmp33__target = cmp_target;
						_tmp34_ = *prev;
						_tmp35_ = i;
						_tmp36_ = _tmp34_._iter[_tmp35_ - 1];
						_tmp37_ = *prev;
						_tmp38_ = i;
						_tmp39_ = _tmp37_._iter[_tmp38_];
						_tmp40_ = gee_concurrent_set_tower_compare (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp33_, _tmp33__target, _tmp36_, _tmp39_);
						_tmp30_ = _tmp40_ <= 0;
					} else {
						_tmp30_ = FALSE;
					}
					_tmp41_ = _tmp30_;
					if (_tmp41_) {
						gint _tmp42_;
						GeeConcurrentSetTowerIter _tmp43_;
						gint _tmp44_;
						GeeConcurrentSetTower* _tmp45_;
						GeeConcurrentSetTower* _tmp46_;
						GeeConcurrentSetTower* _tmp47_;
						_tmp42_ = i;
						_tmp43_ = *prev;
						_tmp44_ = i;
						_tmp45_ = _tmp43_._iter[_tmp44_];
						_tmp46_ = _gee_concurrent_set_tower_ref0 (_tmp45_);
						_gee_concurrent_set_tower_unref0 ((*prev)._iter[_tmp42_ - 1]);
						(*prev)._iter[_tmp42_ - 1] = _tmp46_;
						_tmp47_ = (*prev)._iter[_tmp42_ - 1];
					}
				}
				_gee_concurrent_set_tower_unref0 (tmp_next);
			}
		}
	}
	result = res;
	if (next) {
		*next = _vala_next;
	} else {
		gee_concurrent_set_tower_iter_destroy (&_vala_next);
	}
	return result;
}


static inline gboolean gee_concurrent_set_tower_search_helper (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, gconstpointer key, GeeConcurrentSetTower** prev, GeeConcurrentSetTower** next, guint8 level) {
	GeeConcurrentSetTower* _vala_next = NULL;
	gboolean result = FALSE;
	GeeConcurrentSetTower* _tmp0_;
	guint8 _tmp1_;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	gboolean _tmp15_ = FALSE;
	GeeConcurrentSetTower* _tmp16_;
	gboolean _tmp22_;
	_tmp0_ = *prev;
	_tmp1_ = level;
	_tmp2_ = gee_concurrent_set_tower_get_next (_tmp0_, _tmp1_);
	_gee_concurrent_set_tower_unref0 (_vala_next);
	_vala_next = _tmp2_;
	while (TRUE) {
		gboolean _tmp3_ = FALSE;
		gboolean _tmp4_ = FALSE;
		GeeConcurrentSetTower* _tmp5_;
		gboolean _tmp10_;
		gboolean _tmp14_;
		_tmp5_ = _vala_next;
		if (_tmp5_ != NULL) {
			GCompareDataFunc _tmp6_;
			void* _tmp6__target;
			GeeConcurrentSetTower* _tmp7_;
			gconstpointer _tmp8_;
			gint _tmp9_ = 0;
			_tmp6_ = cmp;
			_tmp6__target = cmp_target;
			_tmp7_ = _vala_next;
			_tmp8_ = key;
			_tmp9_ = gee_concurrent_set_tower_compare_data (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp6_, _tmp6__target, _tmp7_, _tmp8_);
			_tmp4_ = _tmp9_ < 0;
		} else {
			_tmp4_ = FALSE;
		}
		_tmp10_ = _tmp4_;
		if (_tmp10_) {
			GCompareDataFunc _tmp11_;
			void* _tmp11__target;
			guint8 _tmp12_;
			gboolean _tmp13_ = FALSE;
			_tmp11_ = cmp;
			_tmp11__target = cmp_target;
			_tmp12_ = level;
			_tmp13_ = gee_concurrent_set_tower_proceed (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp11_, _tmp11__target, prev, &_vala_next, _tmp12_, TRUE);
			_tmp3_ = _tmp13_;
		} else {
			_tmp3_ = FALSE;
		}
		_tmp14_ = _tmp3_;
		if (!_tmp14_) {
			break;
		}
	}
	_tmp16_ = _vala_next;
	if (_tmp16_ != NULL) {
		GCompareDataFunc _tmp17_;
		void* _tmp17__target;
		gconstpointer _tmp18_;
		GeeConcurrentSetTower* _tmp19_;
		gconstpointer _tmp20_;
		gint _tmp21_ = 0;
		_tmp17_ = cmp;
		_tmp17__target = cmp_target;
		_tmp18_ = key;
		_tmp19_ = _vala_next;
		_tmp20_ = _tmp19_->_data;
		_tmp21_ = _tmp17_ (_tmp18_, _tmp20_, _tmp17__target);
		_tmp15_ = _tmp21_ == 0;
	} else {
		_tmp15_ = FALSE;
	}
	_tmp22_ = _tmp15_;
	result = _tmp22_;
	if (next) {
		*next = _vala_next;
	} else {
		_gee_concurrent_set_tower_unref0 (_vala_next);
	}
	return result;
}


static inline GeeConcurrentSetTower* gee_concurrent_set_tower_insert (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, gconstpointer key, guint8 chosen_level) {
	GeeConcurrentSetTower* result = NULL;
	GCompareDataFunc _tmp0_;
	void* _tmp0__target;
	gconstpointer _tmp1_;
	guint8 _tmp2_;
	guint8 _tmp3_;
	GeeConcurrentSetTower* _tmp4_ = NULL;
	g_return_val_if_fail (prev != NULL, NULL);
	_tmp0_ = cmp;
	_tmp0__target = cmp_target;
	_tmp1_ = key;
	_tmp2_ = chosen_level;
	_tmp3_ = chosen_level;
	_tmp4_ = gee_concurrent_set_tower_insert_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp0_, _tmp0__target, prev, _tmp1_, _tmp2_, _tmp3_);
	result = _tmp4_;
	return result;
}


static inline GeeConcurrentSetTower* gee_concurrent_set_tower_insert_helper (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, gconstpointer key, guint8 chosen_level, guint8 level) {
	GeeConcurrentSetTower* result = NULL;
	GeeConcurrentSetTower* new_tower = NULL;
	GeeConcurrentSetTower* next = NULL;
	GCompareDataFunc _tmp0_;
	void* _tmp0__target;
	gconstpointer _tmp1_;
	guint8 _tmp2_;
	guint8 _tmp3_;
	GeeConcurrentSetTower* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	guint8 _tmp6_;
	GeeConcurrentSetTower* _tmp29_;
	GeeConcurrentSetTower* _tmp72_;
	GeeConcurrentSetTower* _tmp73_;
	GeeConcurrentSetState _tmp74_ = 0;
	g_return_val_if_fail (prev != NULL, NULL);
	_tmp0_ = cmp;
	_tmp0__target = cmp_target;
	_tmp1_ = key;
	_tmp2_ = level;
	_tmp3_ = level;
	_tmp5_ = gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp0_, _tmp0__target, _tmp1_, &(*prev)._iter[_tmp2_], &_tmp4_, _tmp3_);
	_gee_concurrent_set_tower_unref0 (next);
	next = _tmp4_;
	if (_tmp5_) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (new_tower);
		return result;
	}
	_tmp6_ = level;
	if (((gint) _tmp6_) > 0) {
		GCompareDataFunc _tmp7_;
		void* _tmp7__target;
		GeeConcurrentSetTowerIter _tmp8_;
		guint8 _tmp9_;
		GeeConcurrentSetTower* _tmp10_;
		GeeConcurrentSetTowerIter _tmp11_;
		guint8 _tmp12_;
		GeeConcurrentSetTower* _tmp13_;
		gint _tmp14_ = 0;
		GCompareDataFunc _tmp21_;
		void* _tmp21__target;
		gconstpointer _tmp22_;
		guint8 _tmp23_;
		guint8 _tmp24_;
		GeeConcurrentSetTower* _tmp25_ = NULL;
		_tmp7_ = cmp;
		_tmp7__target = cmp_target;
		_tmp8_ = *prev;
		_tmp9_ = level;
		_tmp10_ = _tmp8_._iter[_tmp9_];
		_tmp11_ = *prev;
		_tmp12_ = level;
		_tmp13_ = _tmp11_._iter[_tmp12_ - 1];
		_tmp14_ = gee_concurrent_set_tower_compare (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp7_, _tmp7__target, _tmp10_, _tmp13_);
		if (_tmp14_ >= 0) {
			guint8 _tmp15_;
			GeeConcurrentSetTowerIter _tmp16_;
			guint8 _tmp17_;
			GeeConcurrentSetTower* _tmp18_;
			GeeConcurrentSetTower* _tmp19_;
			GeeConcurrentSetTower* _tmp20_;
			_tmp15_ = level;
			_tmp16_ = *prev;
			_tmp17_ = level;
			_tmp18_ = _tmp16_._iter[_tmp17_];
			_tmp19_ = _gee_concurrent_set_tower_ref0 (_tmp18_);
			_gee_concurrent_set_tower_unref0 ((*prev)._iter[_tmp15_ - 1]);
			(*prev)._iter[_tmp15_ - 1] = _tmp19_;
			_tmp20_ = (*prev)._iter[_tmp15_ - 1];
		}
		_tmp21_ = cmp;
		_tmp21__target = cmp_target;
		_tmp22_ = key;
		_tmp23_ = chosen_level;
		_tmp24_ = level;
		_tmp25_ = gee_concurrent_set_tower_insert_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp21_, _tmp21__target, prev, _tmp22_, _tmp23_, (guint8) (_tmp24_ - 1));
		_gee_concurrent_set_tower_unref0 (new_tower);
		new_tower = _tmp25_;
	} else {
		gconstpointer _tmp26_;
		guint8 _tmp27_;
		GeeConcurrentSetTower* _tmp28_;
		_tmp26_ = key;
		_tmp27_ = chosen_level;
		_tmp28_ = gee_concurrent_set_tower_new (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp26_, (guint8) (_tmp27_ + 1));
		_gee_concurrent_set_tower_unref0 (new_tower);
		new_tower = _tmp28_;
	}
	_tmp29_ = new_tower;
	if (_tmp29_ == NULL) {
		result = NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (new_tower);
		return result;
	}
	while (TRUE) {
		GeeConcurrentSetState prev_state = 0;
		GeeConcurrentSetTowerIter _tmp30_;
		guint8 _tmp31_;
		GeeConcurrentSetTower* _tmp32_;
		guint8 _tmp33_;
		GeeConcurrentSetState _tmp34_ = 0;
		GeeConcurrentSetTower* _tmp35_ = NULL;
		GeeConcurrentSetTower* prev_next;
		GeeConcurrentSetState _tmp36_;
		GCompareDataFunc _tmp67_;
		void* _tmp67__target;
		gconstpointer _tmp68_;
		guint8 _tmp69_;
		guint8 _tmp70_;
		gboolean _tmp71_ = FALSE;
		_tmp30_ = *prev;
		_tmp31_ = level;
		_tmp32_ = _tmp30_._iter[_tmp31_];
		_tmp33_ = level;
		_tmp35_ = gee_concurrent_set_tower_get_succ (_tmp32_, &_tmp34_, _tmp33_);
		prev_state = _tmp34_;
		prev_next = _tmp35_;
		_tmp36_ = prev_state;
		if (_tmp36_ == GEE_CONCURRENT_SET_STATE_FLAGGED) {
			GeeConcurrentSetTower* _tmp37_;
			GeeConcurrentSetTowerIter _tmp38_;
			guint8 _tmp39_;
			GeeConcurrentSetTower* _tmp40_;
			guint8 _tmp41_;
			_tmp37_ = prev_next;
			_tmp38_ = *prev;
			_tmp39_ = level;
			_tmp40_ = _tmp38_._iter[_tmp39_];
			_tmp41_ = level;
			gee_concurrent_set_tower_help_flagged (_tmp37_, _tmp40_, _tmp41_);
		} else {
			GeeConcurrentSetTower* _tmp42_;
			GeeConcurrentSetTower* _tmp43_;
			guint8 _tmp44_;
			GeeConcurrentSetTowerIter _tmp45_;
			guint8 _tmp46_;
			GeeConcurrentSetTower* _tmp47_;
			GeeConcurrentSetTower* _tmp48_;
			GeeConcurrentSetTower* _tmp49_;
			guint8 _tmp50_;
			gboolean _tmp51_ = FALSE;
			gboolean _result_;
			gboolean _tmp52_;
			GeeConcurrentSetTowerIter _tmp53_;
			guint8 _tmp54_;
			GeeConcurrentSetTower* _tmp55_;
			guint8 _tmp56_;
			GeeConcurrentSetState _tmp57_ = 0;
			GeeConcurrentSetTower* _tmp58_ = NULL;
			GeeConcurrentSetState _tmp59_;
			guint8 _tmp65_;
			guint8 _tmp66_;
			_tmp42_ = new_tower;
			_tmp43_ = next;
			_tmp44_ = level;
			gee_concurrent_set_tower_set_succ (_tmp42_, _tmp43_, GEE_CONCURRENT_SET_STATE_NONE, _tmp44_);
			_tmp45_ = *prev;
			_tmp46_ = level;
			_tmp47_ = _tmp45_._iter[_tmp46_];
			_tmp48_ = next;
			_tmp49_ = new_tower;
			_tmp50_ = level;
			_tmp51_ = gee_concurrent_set_tower_compare_and_exchange (_tmp47_, _tmp48_, GEE_CONCURRENT_SET_STATE_NONE, _tmp49_, GEE_CONCURRENT_SET_STATE_NONE, _tmp50_);
			_result_ = _tmp51_;
			_tmp52_ = _result_;
			if (_tmp52_) {
				_gee_concurrent_set_tower_unref0 (prev_next);
				break;
			}
			_tmp53_ = *prev;
			_tmp54_ = level;
			_tmp55_ = _tmp53_._iter[_tmp54_];
			_tmp56_ = level;
			_tmp58_ = gee_concurrent_set_tower_get_succ (_tmp55_, &_tmp57_, _tmp56_);
			prev_state = _tmp57_;
			_gee_concurrent_set_tower_unref0 (prev_next);
			prev_next = _tmp58_;
			_tmp59_ = prev_state;
			if (_tmp59_ == GEE_CONCURRENT_SET_STATE_FLAGGED) {
				GeeConcurrentSetTower* _tmp60_;
				GeeConcurrentSetTowerIter _tmp61_;
				guint8 _tmp62_;
				GeeConcurrentSetTower* _tmp63_;
				guint8 _tmp64_;
				_tmp60_ = prev_next;
				_tmp61_ = *prev;
				_tmp62_ = level;
				_tmp63_ = _tmp61_._iter[_tmp62_];
				_tmp64_ = level;
				gee_concurrent_set_tower_help_flagged (_tmp60_, _tmp63_, _tmp64_);
			}
			_tmp65_ = level;
			_tmp66_ = level;
			gee_concurrent_set_tower_backtrace (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, &(*prev)._iter[_tmp65_], _tmp66_);
		}
		_tmp67_ = cmp;
		_tmp67__target = cmp_target;
		_tmp68_ = key;
		_tmp69_ = level;
		_tmp70_ = level;
		_tmp71_ = gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp67_, _tmp67__target, _tmp68_, &(*prev)._iter[_tmp69_], NULL, _tmp70_);
		if (_tmp71_) {
			result = NULL;
			_gee_concurrent_set_tower_unref0 (prev_next);
			_gee_concurrent_set_tower_unref0 (next);
			_gee_concurrent_set_tower_unref0 (new_tower);
			return result;
		}
		_gee_concurrent_set_tower_unref0 (prev_next);
	}
	_tmp72_ = new_tower;
	g_atomic_int_inc ((volatile gint *) (&_tmp72_->_height));
	_tmp73_ = new_tower;
	_tmp74_ = gee_concurrent_set_tower_get_state (_tmp73_, (guint8) 0);
	if (_tmp74_ == GEE_CONCURRENT_SET_STATE_MARKED) {
		GCompareDataFunc _tmp75_;
		void* _tmp75__target;
		guint8 _tmp76_;
		GeeConcurrentSetTower* _tmp77_;
		guint8 _tmp78_;
		_tmp75_ = cmp;
		_tmp75__target = cmp_target;
		_tmp76_ = level;
		_tmp77_ = new_tower;
		_tmp78_ = level;
		gee_concurrent_set_tower_remove_level (_tmp75_, _tmp75__target, &(*prev)._iter[_tmp76_], _tmp77_, _tmp78_);
		result = NULL;
		_gee_concurrent_set_tower_unref0 (next);
		_gee_concurrent_set_tower_unref0 (new_tower);
		return result;
	}
	result = new_tower;
	_gee_concurrent_set_tower_unref0 (next);
	return result;
}


static inline gboolean gee_concurrent_set_tower_remove_key (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, gconstpointer key, guint8 from_level) {
	gboolean result = FALSE;
	GeeConcurrentSetTower* curr = NULL;
	GCompareDataFunc _tmp24_;
	void* _tmp24__target;
	gconstpointer _tmp25_;
	GeeConcurrentSetTower* _tmp26_ = NULL;
	gboolean _tmp27_ = FALSE;
	g_return_val_if_fail (prev != NULL, FALSE);
	{
		guint8 _tmp0_;
		gint i;
		_tmp0_ = from_level;
		i = (gint) _tmp0_;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				gint _tmp4_;
				GeeConcurrentSetTower* next = NULL;
				GCompareDataFunc _tmp5_;
				void* _tmp5__target;
				gconstpointer _tmp6_;
				gint _tmp7_;
				gint _tmp8_;
				GeeConcurrentSetTower* _tmp9_ = NULL;
				GCompareDataFunc _tmp10_;
				void* _tmp10__target;
				GeeConcurrentSetTowerIter _tmp11_;
				gint _tmp12_;
				GeeConcurrentSetTower* _tmp13_;
				GeeConcurrentSetTowerIter _tmp14_;
				gint _tmp15_;
				GeeConcurrentSetTower* _tmp16_;
				gint _tmp17_ = 0;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ - 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				if (!(_tmp4_ >= 1)) {
					break;
				}
				_tmp5_ = cmp;
				_tmp5__target = cmp_target;
				_tmp6_ = key;
				_tmp7_ = i;
				_tmp8_ = i;
				gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp5_, _tmp5__target, _tmp6_, &(*prev)._iter[_tmp7_], &_tmp9_, (guint8) _tmp8_);
				_gee_concurrent_set_tower_unref0 (next);
				next = _tmp9_;
				_tmp10_ = cmp;
				_tmp10__target = cmp_target;
				_tmp11_ = *prev;
				_tmp12_ = i;
				_tmp13_ = _tmp11_._iter[_tmp12_ - 1];
				_tmp14_ = *prev;
				_tmp15_ = i;
				_tmp16_ = _tmp14_._iter[_tmp15_];
				_tmp17_ = gee_concurrent_set_tower_compare (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp10_, _tmp10__target, _tmp13_, _tmp16_);
				if (_tmp17_ < 0) {
					gint _tmp18_;
					GeeConcurrentSetTowerIter _tmp19_;
					gint _tmp20_;
					GeeConcurrentSetTower* _tmp21_;
					GeeConcurrentSetTower* _tmp22_;
					GeeConcurrentSetTower* _tmp23_;
					_tmp18_ = i;
					_tmp19_ = *prev;
					_tmp20_ = i;
					_tmp21_ = _tmp19_._iter[_tmp20_];
					_tmp22_ = _gee_concurrent_set_tower_ref0 (_tmp21_);
					_gee_concurrent_set_tower_unref0 ((*prev)._iter[_tmp18_ - 1]);
					(*prev)._iter[_tmp18_ - 1] = _tmp22_;
					_tmp23_ = (*prev)._iter[_tmp18_ - 1];
				}
				_gee_concurrent_set_tower_unref0 (next);
			}
		}
	}
	_tmp24_ = cmp;
	_tmp24__target = cmp_target;
	_tmp25_ = key;
	_tmp27_ = gee_concurrent_set_tower_search_helper (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp24_, _tmp24__target, _tmp25_, &(*prev)._iter[0], &_tmp26_, (guint8) 0);
	_gee_concurrent_set_tower_unref0 (curr);
	curr = _tmp26_;
	if (_tmp27_) {
		GCompareDataFunc _tmp28_;
		void* _tmp28__target;
		GeeConcurrentSetTower* _tmp29_;
		gboolean _tmp30_ = FALSE;
		_tmp28_ = cmp;
		_tmp28__target = cmp_target;
		_tmp29_ = curr;
		_tmp30_ = gee_concurrent_set_tower_remove (g_type, (GBoxedCopyFunc) g_dup_func, g_destroy_func, _tmp28_, _tmp28__target, prev, _tmp29_);
		result = _tmp30_;
		_gee_concurrent_set_tower_unref0 (curr);
		return result;
	} else {
		result = FALSE;
		_gee_concurrent_set_tower_unref0 (curr);
		return result;
	}
	_gee_concurrent_set_tower_unref0 (curr);
}


static inline gboolean gee_concurrent_set_tower_remove (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTowerIter* prev, GeeConcurrentSetTower* curr) {
	gboolean result = FALSE;
	GCompareDataFunc _tmp0_;
	void* _tmp0__target;
	GeeConcurrentSetTower* _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean removed;
	g_return_val_if_fail (prev != NULL, FALSE);
	g_return_val_if_fail (curr != NULL, FALSE);
	_tmp0_ = cmp;
	_tmp0__target = cmp_target;
	_tmp1_ = curr;
	_tmp2_ = gee_concurrent_set_tower_remove_level (_tmp0_, _tmp0__target, &(*prev)._iter[0], _tmp1_, (guint8) 0);
	removed = _tmp2_;
	{
		gint i;
		i = 1;
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				gboolean _tmp4_;
				gint _tmp6_;
				GCompareDataFunc _tmp7_;
				void* _tmp7__target;
				gint _tmp8_;
				GeeConcurrentSetTower* _tmp9_;
				gint _tmp10_;
				_tmp4_ = _tmp3_;
				if (!_tmp4_) {
					gint _tmp5_;
					_tmp5_ = i;
					i = _tmp5_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp6_ = i;
				if (!(_tmp6_ < GEE_CONCURRENT_SET__MAX_HEIGHT)) {
					break;
				}
				_tmp7_ = cmp;
				_tmp7__target = cmp_target;
				_tmp8_ = i;
				_tmp9_ = curr;
				_tmp10_ = i;
				gee_concurrent_set_tower_remove_level (_tmp7_, _tmp7__target, &(*prev)._iter[_tmp8_], _tmp9_, (guint8) _tmp10_);
			}
		}
	}
	result = removed;
	return result;
}


static inline gboolean gee_concurrent_set_tower_remove_level (GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower** prev, GeeConcurrentSetTower* curr, guint8 level) {
	gboolean result = FALSE;
	gboolean status = FALSE;
	GeeConcurrentSetTower* _tmp0_;
	GCompareDataFunc _tmp1_;
	void* _tmp1__target;
	guint8 _tmp2_;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	gboolean flagged;
	gboolean _tmp5_;
	g_return_val_if_fail (*prev != NULL, FALSE);
	g_return_val_if_fail (curr != NULL, FALSE);
	_tmp0_ = curr;
	_tmp1_ = cmp;
	_tmp1__target = cmp_target;
	_tmp2_ = level;
	_tmp4_ = gee_concurrent_set_tower_try_flag (_tmp0_, _tmp1_, _tmp1__target, prev, &_tmp3_, _tmp2_);
	status = _tmp3_;
	flagged = _tmp4_;
	_tmp5_ = status;
	if (_tmp5_) {
		GeeConcurrentSetTower* _tmp6_;
		GeeConcurrentSetTower* _tmp7_;
		guint8 _tmp8_;
		_tmp6_ = curr;
		_tmp7_ = *prev;
		_tmp8_ = level;
		gee_concurrent_set_tower_help_flagged (_tmp6_, _tmp7_, _tmp8_);
	}
	result = flagged;
	return result;
}


static inline gboolean gee_concurrent_set_tower_proceed (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower** arg_prev, GeeConcurrentSetTower** arg_curr, guint8 level, gboolean force) {
	gboolean result = FALSE;
	GeeConcurrentSetTower* _tmp0_;
	GeeConcurrentSetTower* _tmp1_;
	GeeConcurrentSetTower* curr;
	GeeConcurrentSetTower* _tmp2_;
	guint8 _tmp3_;
	GeeConcurrentSetTower* _tmp4_ = NULL;
	GeeConcurrentSetTower* next;
	GeeConcurrentSetTower* _tmp5_;
	GeeConcurrentSetTower* _tmp22_;
	gboolean success;
	gboolean _tmp23_ = FALSE;
	gboolean _tmp24_;
	gboolean _tmp26_;
	g_return_val_if_fail (*arg_curr != NULL, FALSE);
	_tmp0_ = *arg_curr;
	_tmp1_ = _gee_concurrent_set_tower_ref0 (_tmp0_);
	curr = _tmp1_;
	_tmp2_ = curr;
	_tmp3_ = level;
	_tmp4_ = gee_concurrent_set_tower_get_next (_tmp2_, _tmp3_);
	next = _tmp4_;
	_tmp5_ = next;
	if (_tmp5_ != NULL) {
		while (TRUE) {
			gboolean _tmp6_ = FALSE;
			GeeConcurrentSetTower* _tmp7_;
			gboolean _tmp10_;
			gboolean status = FALSE;
			GeeConcurrentSetTower* _tmp11_;
			GCompareDataFunc _tmp12_;
			void* _tmp12__target;
			guint8 _tmp13_;
			gboolean _tmp14_ = FALSE;
			gboolean _tmp15_;
			GeeConcurrentSetTower* _tmp19_;
			guint8 _tmp20_;
			GeeConcurrentSetTower* _tmp21_ = NULL;
			_tmp7_ = next;
			if (_tmp7_ != NULL) {
				GeeConcurrentSetTower* _tmp8_;
				GeeConcurrentSetState _tmp9_ = 0;
				_tmp8_ = next;
				_tmp9_ = gee_concurrent_set_tower_get_state (_tmp8_, (guint8) 0);
				_tmp6_ = _tmp9_ == GEE_CONCURRENT_SET_STATE_MARKED;
			} else {
				_tmp6_ = FALSE;
			}
			_tmp10_ = _tmp6_;
			if (!_tmp10_) {
				break;
			}
			_tmp11_ = next;
			_tmp12_ = cmp;
			_tmp12__target = cmp_target;
			_tmp13_ = level;
			gee_concurrent_set_tower_try_flag (_tmp11_, _tmp12_, _tmp12__target, &curr, &_tmp14_, _tmp13_);
			status = _tmp14_;
			_tmp15_ = status;
			if (_tmp15_) {
				GeeConcurrentSetTower* _tmp16_;
				GeeConcurrentSetTower* _tmp17_;
				guint8 _tmp18_;
				_tmp16_ = next;
				_tmp17_ = curr;
				_tmp18_ = level;
				gee_concurrent_set_tower_help_flagged (_tmp16_, _tmp17_, _tmp18_);
			}
			_tmp19_ = curr;
			_tmp20_ = level;
			_tmp21_ = gee_concurrent_set_tower_get_next (_tmp19_, _tmp20_);
			_gee_concurrent_set_tower_unref0 (next);
			next = _tmp21_;
		}
	}
	_tmp22_ = next;
	success = _tmp22_ != NULL;
	_tmp24_ = success;
	if (_tmp24_) {
		_tmp23_ = TRUE;
	} else {
		gboolean _tmp25_;
		_tmp25_ = force;
		_tmp23_ = _tmp25_;
	}
	_tmp26_ = _tmp23_;
	if (_tmp26_) {
		GeeConcurrentSetTower* _tmp27_;
		GeeConcurrentSetTower* _tmp28_;
		_tmp27_ = curr;
		curr = NULL;
		_gee_concurrent_set_tower_unref0 (*arg_prev);
		*arg_prev = _tmp27_;
		_tmp28_ = next;
		next = NULL;
		_gee_concurrent_set_tower_unref0 (*arg_curr);
		*arg_curr = _tmp28_;
	}
	result = success;
	_gee_concurrent_set_tower_unref0 (next);
	_gee_concurrent_set_tower_unref0 (curr);
	return result;
}


static inline void gee_concurrent_set_tower_help_marked (GeeConcurrentSetTower* self, GeeConcurrentSetTower* prev_tower, guint8 level) {
	GeeConcurrentSetTower* _tmp0_;
	guint8 _tmp1_;
	GeeConcurrentSetTower* _tmp2_ = NULL;
	GeeConcurrentSetTower* _tmp3_;
	guint8 _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (prev_tower != NULL);
	_tmp0_ = prev_tower;
	_tmp1_ = level;
	_tmp2_ = gee_concurrent_set_tower_get_next (self, _tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = level;
	gee_concurrent_set_tower_compare_and_exchange (_tmp0_, self, GEE_CONCURRENT_SET_STATE_FLAGGED, _tmp3_, GEE_CONCURRENT_SET_STATE_NONE, _tmp4_);
	_gee_concurrent_set_tower_unref0 (_tmp3_);
}


static inline void gee_concurrent_set_tower_help_flagged (GeeConcurrentSetTower* self, GeeConcurrentSetTower* prev, guint8 level) {
	GeeConcurrentSetTower* _tmp0_;
	guint8 _tmp1_;
	guint8 _tmp2_;
	GeeConcurrentSetState _tmp3_ = 0;
	GeeConcurrentSetTower* _tmp5_;
	guint8 _tmp6_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (prev != NULL);
	_tmp0_ = prev;
	_tmp1_ = level;
	gee_concurrent_set_tower_set_backlink (self, _tmp0_, _tmp1_);
	_tmp2_ = level;
	_tmp3_ = gee_concurrent_set_tower_get_state (self, _tmp2_);
	if (_tmp3_ != GEE_CONCURRENT_SET_STATE_MARKED) {
		guint8 _tmp4_;
		_tmp4_ = level;
		gee_concurrent_set_tower_try_mark (self, _tmp4_);
	}
	_tmp5_ = prev;
	_tmp6_ = level;
	gee_concurrent_set_tower_help_marked (self, _tmp5_, _tmp6_);
}


static inline void gee_concurrent_set_tower_try_mark (GeeConcurrentSetTower* self, guint8 level) {
	g_return_if_fail (self != NULL);
	{
		gboolean _tmp0_;
		_tmp0_ = TRUE;
		while (TRUE) {
			gboolean _tmp1_;
			guint8 _tmp4_;
			GeeConcurrentSetTower* _tmp5_ = NULL;
			GeeConcurrentSetTower* next_tower;
			GeeConcurrentSetTower* _tmp6_;
			GeeConcurrentSetTower* _tmp7_;
			guint8 _tmp8_;
			gboolean _tmp9_ = FALSE;
			gboolean _result_;
			gboolean _tmp10_;
			_tmp1_ = _tmp0_;
			if (!_tmp1_) {
				guint8 _tmp2_;
				GeeConcurrentSetState _tmp3_ = 0;
				_tmp2_ = level;
				_tmp3_ = gee_concurrent_set_tower_get_state (self, _tmp2_);
				if (!(_tmp3_ != GEE_CONCURRENT_SET_STATE_MARKED)) {
					break;
				}
			}
			_tmp0_ = FALSE;
			_tmp4_ = level;
			_tmp5_ = gee_concurrent_set_tower_get_next (self, _tmp4_);
			next_tower = _tmp5_;
			_tmp6_ = next_tower;
			_tmp7_ = next_tower;
			_tmp8_ = level;
			_tmp9_ = gee_concurrent_set_tower_compare_and_exchange (self, _tmp6_, GEE_CONCURRENT_SET_STATE_NONE, _tmp7_, GEE_CONCURRENT_SET_STATE_MARKED, _tmp8_);
			_result_ = _tmp9_;
			_tmp10_ = _result_;
			if (!_tmp10_) {
				GeeConcurrentSetState state = 0;
				guint8 _tmp11_;
				GeeConcurrentSetState _tmp12_ = 0;
				GeeConcurrentSetTower* _tmp13_ = NULL;
				GeeConcurrentSetState _tmp14_;
				_tmp11_ = level;
				_tmp13_ = gee_concurrent_set_tower_get_succ (self, &_tmp12_, _tmp11_);
				state = _tmp12_;
				_gee_concurrent_set_tower_unref0 (next_tower);
				next_tower = _tmp13_;
				_tmp14_ = state;
				if (_tmp14_ == GEE_CONCURRENT_SET_STATE_FLAGGED) {
					GeeConcurrentSetTower* _tmp15_;
					guint8 _tmp16_;
					_tmp15_ = next_tower;
					_tmp16_ = level;
					gee_concurrent_set_tower_help_flagged (self, _tmp15_, _tmp16_);
				}
			}
			_gee_concurrent_set_tower_unref0 (next_tower);
		}
	}
}


static inline gboolean gee_concurrent_set_tower_try_flag (GeeConcurrentSetTower* self, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower** prev_tower, gboolean* status, guint8 level) {
	gboolean _vala_status = FALSE;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (*prev_tower != NULL, FALSE);
	while (TRUE) {
		GeeConcurrentSetTower* _tmp0_;
		guint8 _tmp1_;
		gboolean _tmp2_ = FALSE;
		GeeConcurrentSetTower* _tmp3_;
		guint8 _tmp4_;
		gboolean _tmp5_ = FALSE;
		gboolean _result_;
		gboolean _tmp6_;
		GeeConcurrentSetState result_state = 0;
		GeeConcurrentSetTower* _tmp7_;
		guint8 _tmp8_;
		GeeConcurrentSetState _tmp9_ = 0;
		GeeConcurrentSetTower* _tmp10_ = NULL;
		GeeConcurrentSetTower* result_tower;
		gboolean _tmp11_ = FALSE;
		GeeConcurrentSetTower* _tmp12_;
		gboolean _tmp14_;
		guint8 _tmp15_;
		GCompareDataFunc _tmp16_;
		void* _tmp16__target;
		gconstpointer _tmp17_;
		guint8 _tmp18_;
		gboolean _tmp19_ = FALSE;
		_tmp0_ = *prev_tower;
		_tmp1_ = level;
		_tmp2_ = gee_concurrent_set_tower_compare_succ (_tmp0_, self, GEE_CONCURRENT_SET_STATE_FLAGGED, _tmp1_);
		if (_tmp2_) {
			_vala_status = TRUE;
			result = FALSE;
			if (status) {
				*status = _vala_status;
			}
			return result;
		}
		_tmp3_ = *prev_tower;
		_tmp4_ = level;
		_tmp5_ = gee_concurrent_set_tower_compare_and_exchange (_tmp3_, self, GEE_CONCURRENT_SET_STATE_NONE, self, GEE_CONCURRENT_SET_STATE_FLAGGED, _tmp4_);
		_result_ = _tmp5_;
		_tmp6_ = _result_;
		if (_tmp6_) {
			_vala_status = TRUE;
			result = TRUE;
			if (status) {
				*status = _vala_status;
			}
			return result;
		}
		_tmp7_ = *prev_tower;
		_tmp8_ = level;
		_tmp10_ = gee_concurrent_set_tower_get_succ (_tmp7_, &_tmp9_, _tmp8_);
		result_state = _tmp9_;
		result_tower = _tmp10_;
		_tmp12_ = result_tower;
		if (_tmp12_ == self) {
			GeeConcurrentSetState _tmp13_;
			_tmp13_ = result_state;
			_tmp11_ = _tmp13_ == GEE_CONCURRENT_SET_STATE_FLAGGED;
		} else {
			_tmp11_ = FALSE;
		}
		_tmp14_ = _tmp11_;
		if (_tmp14_) {
			_vala_status = TRUE;
			result = FALSE;
			_gee_concurrent_set_tower_unref0 (result_tower);
			if (status) {
				*status = _vala_status;
			}
			return result;
		}
		_tmp15_ = level;
		gee_concurrent_set_tower_backtrace (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, prev_tower, _tmp15_);
		_tmp16_ = cmp;
		_tmp16__target = cmp_target;
		_tmp17_ = self->_data;
		_tmp18_ = level;
		_tmp19_ = gee_concurrent_set_tower_search_helper (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func, _tmp16_, _tmp16__target, _tmp17_, prev_tower, NULL, _tmp18_);
		if (!_tmp19_) {
			_vala_status = FALSE;
			result = FALSE;
			_gee_concurrent_set_tower_unref0 (result_tower);
			if (status) {
				*status = _vala_status;
			}
			return result;
		}
		_gee_concurrent_set_tower_unref0 (result_tower);
	}
	if (status) {
		*status = _vala_status;
	}
}


static inline void gee_concurrent_set_tower_backtrace (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GeeConcurrentSetTower** curr, guint8 level) {
	while (TRUE) {
		GeeConcurrentSetTower* _tmp0_;
		guint8 _tmp1_;
		GeeConcurrentSetState _tmp2_ = 0;
		GeeConcurrentSetTower* _tmp3_;
		guint8 _tmp4_;
		GeeConcurrentSetTower* _tmp5_ = NULL;
		_tmp0_ = *curr;
		_tmp1_ = level;
		_tmp2_ = gee_concurrent_set_tower_get_state (_tmp0_, _tmp1_);
		if (!(_tmp2_ == GEE_CONCURRENT_SET_STATE_MARKED)) {
			break;
		}
		_tmp3_ = *curr;
		_tmp4_ = level;
		_tmp5_ = gee_concurrent_set_tower_get_backlink (_tmp3_, _tmp4_);
		_gee_concurrent_set_tower_unref0 (*curr);
		*curr = _tmp5_;
	}
}


static inline gboolean gee_concurrent_set_tower_compare_and_exchange (GeeConcurrentSetTower* self, GeeConcurrentSetTower* old_tower, GeeConcurrentSetState old_state, GeeConcurrentSetTower* new_tower, GeeConcurrentSetState new_state, guint8 level) {
	gboolean result = FALSE;
	GeeConcurrentSetTowerNode* _tmp0_;
	gint _tmp0__length1;
	guint8 _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	GeeConcurrentSetTower* _tmp4_;
	GeeConcurrentSetState _tmp5_;
	GeeConcurrentSetState _tmp6_;
	gboolean _tmp7_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = level;
	_tmp2_ = old_tower;
	_tmp3_ = new_tower;
	_tmp4_ = _gee_concurrent_set_tower_ref0 (_tmp3_);
	_tmp5_ = old_state;
	_tmp6_ = new_state;
	_tmp7_ = gee_hazard_pointer_compare_and_exchange_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp0_[_tmp1_]._succ, _tmp2_, _tmp4_, (gsize) 3, (gsize) _tmp5_, (gsize) _tmp6_);
	result = _tmp7_;
	return result;
}


static inline gboolean gee_concurrent_set_tower_compare_succ (GeeConcurrentSetTower* self, GeeConcurrentSetTower* next, GeeConcurrentSetState state, guint8 level) {
	gboolean result = FALSE;
	GeeConcurrentSetTowerNode* _tmp0_;
	gint _tmp0__length1;
	guint8 _tmp1_;
	void* _tmp2_ = NULL;
	gsize cur;
	GeeConcurrentSetTower* _tmp3_;
	GeeConcurrentSetState _tmp4_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = level;
	_tmp2_ = g_atomic_pointer_get ((volatile gpointer *) (&_tmp0_[_tmp1_]._succ));
	cur = (gsize) _tmp2_;
	_tmp3_ = next;
	_tmp4_ = state;
	result = cur == (((gsize) _tmp3_) | ((gsize) _tmp4_));
	return result;
}


static inline GeeConcurrentSetTower* gee_concurrent_set_tower_get_next (GeeConcurrentSetTower* self, guint8 level) {
	GeeConcurrentSetTower* result = NULL;
	guint8 _tmp0_;
	GeeConcurrentSetTower* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = level;
	_tmp1_ = gee_concurrent_set_tower_get_succ (self, NULL, _tmp0_);
	result = _tmp1_;
	return result;
}


static inline GeeConcurrentSetState gee_concurrent_set_tower_get_state (GeeConcurrentSetTower* self, guint8 level) {
	GeeConcurrentSetState result = 0;
	GeeConcurrentSetTowerNode* _tmp0_;
	gint _tmp0__length1;
	guint8 _tmp1_;
	void* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = level;
	_tmp2_ = g_atomic_pointer_get ((volatile gpointer *) (&_tmp0_[_tmp1_]._succ));
	result = (GeeConcurrentSetState) (((gsize) _tmp2_) & 3);
	return result;
}


static inline GeeConcurrentSetTower* gee_concurrent_set_tower_get_succ (GeeConcurrentSetTower* self, GeeConcurrentSetState* state, guint8 level) {
	GeeConcurrentSetState _vala_state = 0;
	GeeConcurrentSetTower* result = NULL;
	gsize rstate = 0UL;
	GeeConcurrentSetTowerNode* _tmp0_;
	gint _tmp0__length1;
	guint8 _tmp1_;
	gsize _tmp2_ = 0UL;
	gpointer _tmp3_ = NULL;
	GeeConcurrentSetTower* succ;
	GeeConcurrentSetTower* _tmp4_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = level;
	_tmp3_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp0_[_tmp1_]._succ, (gsize) 3, &_tmp2_);
	rstate = _tmp2_;
	succ = (GeeConcurrentSetTower*) _tmp3_;
	_vala_state = (GeeConcurrentSetState) rstate;
	_tmp4_ = succ;
	succ = NULL;
	result = _tmp4_;
	_gee_concurrent_set_tower_unref0 (succ);
	if (state) {
		*state = _vala_state;
	}
	return result;
}


static inline void gee_concurrent_set_tower_set_succ (GeeConcurrentSetTower* self, GeeConcurrentSetTower* next, GeeConcurrentSetState state, guint8 level) {
	GeeConcurrentSetTowerNode* _tmp0_;
	gint _tmp0__length1;
	guint8 _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	GeeConcurrentSetState _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = level;
	_tmp2_ = next;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	_tmp4_ = state;
	gee_hazard_pointer_set_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp0_[_tmp1_]._succ, _tmp3_, (gsize) 3, (gsize) _tmp4_);
}


static inline GeeConcurrentSetTower* gee_concurrent_set_tower_get_backlink (GeeConcurrentSetTower* self, guint8 level) {
	GeeConcurrentSetTower* result = NULL;
	GeeConcurrentSetTowerNode* _tmp0_;
	gint _tmp0__length1;
	guint8 _tmp1_;
	gpointer _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = level;
	_tmp2_ = gee_hazard_pointer_get_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp0_[_tmp1_]._backlink, (gsize) 0, NULL);
	result = (GeeConcurrentSetTower*) _tmp2_;
	return result;
}


static inline void gee_concurrent_set_tower_set_backlink (GeeConcurrentSetTower* self, GeeConcurrentSetTower* backlink, guint8 level) {
	GeeConcurrentSetTowerNode* _tmp0_;
	gint _tmp0__length1;
	guint8 _tmp1_;
	GeeConcurrentSetTower* _tmp2_;
	GeeConcurrentSetTower* _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->_nodes;
	_tmp0__length1 = -1;
	_tmp1_ = level;
	_tmp2_ = backlink;
	_tmp3_ = _gee_concurrent_set_tower_ref0 (_tmp2_);
	gee_hazard_pointer_compare_and_exchange_pointer (GEE_CONCURRENT_SET_TYPE_TOWER, (GBoxedCopyFunc) gee_concurrent_set_tower_ref, gee_concurrent_set_tower_unref, &_tmp0_[_tmp1_]._backlink, NULL, _tmp3_, (gsize) 0, (gsize) 0, (gsize) 0);
}


static inline gint gee_concurrent_set_tower_get_height (GeeConcurrentSetTower* self) {
	gint result = 0;
	gint _tmp0_ = 0;
	gint height;
	gint _tmp1_ = 0;
	gint _tmp2_;
	gint _tmp4_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = g_atomic_int_get ((volatile gint *) (&self->_height));
	height = _tmp0_;
	_tmp2_ = height;
	if (_tmp2_ != (-1)) {
		gint _tmp3_;
		_tmp3_ = height;
		_tmp1_ = _tmp3_;
	} else {
		_tmp1_ = GEE_CONCURRENT_SET__MAX_HEIGHT;
	}
	_tmp4_ = _tmp1_;
	result = _tmp4_;
	return result;
}


static inline gboolean gee_concurrent_set_tower_is_head (GeeConcurrentSetTower* self) {
	gboolean result = FALSE;
	gint _tmp0_ = 0;
	gint height;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = g_atomic_int_get ((volatile gint *) (&self->_height));
	height = _tmp0_;
	result = height == (-1);
	return result;
}


static inline gint gee_concurrent_set_tower_compare (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower* a, GeeConcurrentSetTower* b) {
	gint result = 0;
	GeeConcurrentSetTower* _tmp0_;
	gint _tmp1_ = 0;
	gboolean ah;
	GeeConcurrentSetTower* _tmp2_;
	gint _tmp3_ = 0;
	gboolean bh;
	gint _tmp4_ = 0;
	gboolean _tmp5_;
	gint _tmp18_;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = a;
	_tmp1_ = g_atomic_int_get ((volatile gint *) (&_tmp0_->_height));
	ah = _tmp1_ == (-1);
	_tmp2_ = b;
	_tmp3_ = g_atomic_int_get ((volatile gint *) (&_tmp2_->_height));
	bh = _tmp3_ == (-1);
	_tmp5_ = ah;
	if (_tmp5_) {
		gint _tmp6_ = 0;
		gboolean _tmp7_;
		gint _tmp8_;
		_tmp7_ = bh;
		if (_tmp7_) {
			_tmp6_ = 0;
		} else {
			_tmp6_ = -1;
		}
		_tmp8_ = _tmp6_;
		_tmp4_ = _tmp8_;
	} else {
		gint _tmp9_ = 0;
		gboolean _tmp10_;
		gint _tmp17_;
		_tmp10_ = bh;
		if (_tmp10_) {
			_tmp9_ = 1;
		} else {
			GCompareDataFunc _tmp11_;
			void* _tmp11__target;
			GeeConcurrentSetTower* _tmp12_;
			gconstpointer _tmp13_;
			GeeConcurrentSetTower* _tmp14_;
			gconstpointer _tmp15_;
			gint _tmp16_ = 0;
			_tmp11_ = cmp;
			_tmp11__target = cmp_target;
			_tmp12_ = a;
			_tmp13_ = _tmp12_->_data;
			_tmp14_ = b;
			_tmp15_ = _tmp14_->_data;
			_tmp16_ = _tmp11_ (_tmp13_, _tmp15_, _tmp11__target);
			_tmp9_ = _tmp16_;
		}
		_tmp17_ = _tmp9_;
		_tmp4_ = _tmp17_;
	}
	_tmp18_ = _tmp4_;
	result = _tmp18_;
	return result;
}


static inline gint gee_concurrent_set_tower_compare_data (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func, GCompareDataFunc cmp, void* cmp_target, GeeConcurrentSetTower* a, gconstpointer b) {
	gint result = 0;
	GeeConcurrentSetTower* _tmp0_;
	gint _tmp1_ = 0;
	gboolean ah;
	gint _tmp2_ = 0;
	gboolean _tmp3_;
	g_return_val_if_fail (a != NULL, 0);
	_tmp0_ = a;
	_tmp1_ = g_atomic_int_get ((volatile gint *) (&_tmp0_->_height));
	ah = _tmp1_ == (-1);
	_tmp3_ = ah;
	if (_tmp3_) {
		_tmp2_ = -1;
	} else {
		GCompareDataFunc _tmp4_;
		void* _tmp4__target;
		GeeConcurrentSetTower* _tmp5_;
		gconstpointer _tmp6_;
		gconstpointer _tmp7_;
		gint _tmp8_ = 0;
		_tmp4_ = cmp;
		_tmp4__target = cmp_target;
		_tmp5_ = a;
		_tmp6_ = _tmp5_->_data;
		_tmp7_ = b;
		_tmp8_ = _tmp4_ (_tmp6_, _tmp7_, _tmp4__target);
		_tmp2_ = _tmp8_;
	}
	result = _tmp2_;
	return result;
}


static void gee_concurrent_set_value_tower_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void gee_concurrent_set_value_tower_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		gee_concurrent_set_tower_unref (value->data[0].v_pointer);
	}
}


static void gee_concurrent_set_value_tower_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = gee_concurrent_set_tower_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer gee_concurrent_set_value_tower_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* gee_concurrent_set_value_tower_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		GeeConcurrentSetTower* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = gee_concurrent_set_tower_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* gee_concurrent_set_value_tower_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	GeeConcurrentSetTower** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = gee_concurrent_set_tower_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* gee_concurrent_set_param_spec_tower (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	GeeConcurrentSetParamSpecTower* spec;
	g_return_val_if_fail (g_type_is_a (object_type, GEE_CONCURRENT_SET_TYPE_TOWER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer gee_concurrent_set_value_get_tower (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_TOWER), NULL);
	return value->data[0].v_pointer;
}


static void gee_concurrent_set_value_set_tower (GValue* value, gpointer v_object) {
	GeeConcurrentSetTower* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_TOWER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEE_CONCURRENT_SET_TYPE_TOWER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		gee_concurrent_set_tower_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gee_concurrent_set_tower_unref (old);
	}
}


static void gee_concurrent_set_value_take_tower (GValue* value, gpointer v_object) {
	GeeConcurrentSetTower* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, GEE_CONCURRENT_SET_TYPE_TOWER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, GEE_CONCURRENT_SET_TYPE_TOWER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		gee_concurrent_set_tower_unref (old);
	}
}


static void gee_concurrent_set_tower_class_init (GeeConcurrentSetTowerClass * klass) {
	gee_concurrent_set_tower_parent_class = g_type_class_peek_parent (klass);
	GEE_CONCURRENT_SET_TOWER_CLASS (klass)->finalize = gee_concurrent_set_tower_finalize;
	g_type_class_add_private (klass, sizeof (GeeConcurrentSetTowerPrivate));
}


static void gee_concurrent_set_tower_instance_init (GeeConcurrentSetTower * self) {
	self->priv = GEE_CONCURRENT_SET_TOWER_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void gee_concurrent_set_tower_finalize (GeeConcurrentSetTower* obj) {
	GeeConcurrentSetTower * self;
	gint _tmp0_ = 0;
	gint height;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_CONCURRENT_SET_TYPE_TOWER, GeeConcurrentSetTower);
	_tmp0_ = gee_concurrent_set_tower_get_height (self);
	height = _tmp0_;
	{
		guint8 i;
		i = (guint8) 0;
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				gboolean _tmp2_;
				guint8 _tmp4_;
				gint _tmp5_;
				guint8 _tmp6_;
				guint8 _tmp7_;
				_tmp2_ = _tmp1_;
				if (!_tmp2_) {
					guint8 _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = height;
				if (!(((gint) _tmp4_) < _tmp5_)) {
					break;
				}
				_tmp6_ = i;
				gee_concurrent_set_tower_set_succ (self, NULL, GEE_CONCURRENT_SET_STATE_NONE, _tmp6_);
				_tmp7_ = i;
				gee_concurrent_set_tower_set_backlink (self, NULL, _tmp7_);
			}
		}
	}
	self->_nodes = (g_free (self->_nodes), NULL);
	self->_nodes = NULL;
	self->_nodes = (g_free (self->_nodes), NULL);
	((self->_data == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->_data = (self->priv->g_destroy_func (self->_data), NULL));
}


static GType gee_concurrent_set_tower_get_type (void) {
	static volatile gsize gee_concurrent_set_tower_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_tower_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { gee_concurrent_set_value_tower_init, gee_concurrent_set_value_tower_free_value, gee_concurrent_set_value_tower_copy_value, gee_concurrent_set_value_tower_peek_pointer, "p", gee_concurrent_set_value_tower_collect_value, "p", gee_concurrent_set_value_tower_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetTowerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_tower_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSetTower), 0, (GInstanceInitFunc) gee_concurrent_set_tower_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType gee_concurrent_set_tower_type_id;
		gee_concurrent_set_tower_type_id = g_type_register_fundamental (g_type_fundamental_next (), "GeeConcurrentSetTower", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&gee_concurrent_set_tower_type_id__volatile, gee_concurrent_set_tower_type_id);
	}
	return gee_concurrent_set_tower_type_id__volatile;
}


static gpointer gee_concurrent_set_tower_ref (gpointer instance) {
	GeeConcurrentSetTower* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void gee_concurrent_set_tower_unref (gpointer instance) {
	GeeConcurrentSetTower* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		GEE_CONCURRENT_SET_TOWER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static GeeConcurrentSetTowerNode* gee_concurrent_set_tower_node_dup (const GeeConcurrentSetTowerNode* self) {
	GeeConcurrentSetTowerNode* dup;
	dup = g_new0 (GeeConcurrentSetTowerNode, 1);
	memcpy (dup, self, sizeof (GeeConcurrentSetTowerNode));
	return dup;
}


static void gee_concurrent_set_tower_node_free (GeeConcurrentSetTowerNode* self) {
	g_free (self);
}


static GType gee_concurrent_set_tower_node_get_type (void) {
	static volatile gsize gee_concurrent_set_tower_node_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_tower_node_type_id__volatile)) {
		GType gee_concurrent_set_tower_node_type_id;
		gee_concurrent_set_tower_node_type_id = g_boxed_type_register_static ("GeeConcurrentSetTowerNode", (GBoxedCopyFunc) gee_concurrent_set_tower_node_dup, (GBoxedFreeFunc) gee_concurrent_set_tower_node_free);
		g_once_init_leave (&gee_concurrent_set_tower_node_type_id__volatile, gee_concurrent_set_tower_node_type_id);
	}
	return gee_concurrent_set_tower_node_type_id__volatile;
}


static void _vala_array_copy2 (GeeConcurrentSetTower** self, GeeConcurrentSetTower** dest) {
	int i;
	for (i = 0; i < 31; i++) {
		GeeConcurrentSetTower* _tmp0_;
		_tmp0_ = _gee_concurrent_set_tower_ref0 (self[i]);
		dest[i] = _tmp0_;
	}
}


static void gee_concurrent_set_tower_iter_copy (const GeeConcurrentSetTowerIter* self, GeeConcurrentSetTowerIter* dest) {
	GeeConcurrentSetTower* _tmp0_[31];
	gint _tmp0__length1;
	_vala_array_copy2 ((*self)._iter, _tmp0_);
	_vala_array_destroy ((*dest)._iter, 31, (GDestroyNotify) gee_concurrent_set_tower_unref);
	memcpy ((*dest)._iter, _tmp0_, 31 * sizeof (GeeConcurrentSetTower*));
}


static void gee_concurrent_set_tower_iter_destroy (GeeConcurrentSetTowerIter* self) {
	_vala_array_destroy ((*self)._iter, 31, (GDestroyNotify) gee_concurrent_set_tower_unref);
}


static GeeConcurrentSetTowerIter* gee_concurrent_set_tower_iter_dup (const GeeConcurrentSetTowerIter* self) {
	GeeConcurrentSetTowerIter* dup;
	dup = g_new0 (GeeConcurrentSetTowerIter, 1);
	gee_concurrent_set_tower_iter_copy (self, dup);
	return dup;
}


static void gee_concurrent_set_tower_iter_free (GeeConcurrentSetTowerIter* self) {
	gee_concurrent_set_tower_iter_destroy (self);
	g_free (self);
}


static GType gee_concurrent_set_tower_iter_get_type (void) {
	static volatile gsize gee_concurrent_set_tower_iter_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_tower_iter_type_id__volatile)) {
		GType gee_concurrent_set_tower_iter_type_id;
		gee_concurrent_set_tower_iter_type_id = g_boxed_type_register_static ("GeeConcurrentSetTowerIter", (GBoxedCopyFunc) gee_concurrent_set_tower_iter_dup, (GBoxedFreeFunc) gee_concurrent_set_tower_iter_free);
		g_once_init_leave (&gee_concurrent_set_tower_iter_type_id__volatile, gee_concurrent_set_tower_iter_type_id);
	}
	return gee_concurrent_set_tower_iter_type_id__volatile;
}


static void gee_concurrent_set_class_init (GeeConcurrentSetClass * klass) {
	GPrivate* _tmp0_;
	gee_concurrent_set_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (GeeConcurrentSetPrivate));
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->iterator = gee_concurrent_set_real_iterator;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->contains = gee_concurrent_set_real_contains;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->add = gee_concurrent_set_real_add;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->remove = gee_concurrent_set_real_remove;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->clear = gee_concurrent_set_real_clear;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->first = gee_concurrent_set_real_first;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->last = gee_concurrent_set_real_last;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->iterator_at = gee_concurrent_set_real_iterator_at;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->lower = gee_concurrent_set_real_lower;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->higher = gee_concurrent_set_real_higher;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->floor = gee_concurrent_set_real_floor;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->ceil = gee_concurrent_set_real_ceil;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->head_set = gee_concurrent_set_real_head_set;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->tail_set = gee_concurrent_set_real_tail_set;
	GEE_ABSTRACT_SORTED_SET_CLASS (klass)->sub_set = gee_concurrent_set_real_sub_set;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_size = gee_concurrent_set_real_get_size;
	GEE_ABSTRACT_COLLECTION_CLASS (klass)->get_read_only = gee_concurrent_set_real_get_read_only;
	G_OBJECT_CLASS (klass)->get_property = _vala_gee_concurrent_set_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_gee_concurrent_set_set_property;
	G_OBJECT_CLASS (klass)->finalize = gee_concurrent_set_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_G_TYPE, g_param_spec_gtype ("g-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_G_DUP_FUNC, g_param_spec_pointer ("g-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_G_DESTROY_FUNC, g_param_spec_pointer ("g-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_SIZE, g_param_spec_int ("size", "size", "size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), GEE_CONCURRENT_SET_READ_ONLY, g_param_spec_boolean ("read-only", "read-only", "read-only", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	_tmp0_ = g_private_new (__gee_concurrent_set_rand_lambda37__gdestroy_notify);
	gee_concurrent_set_rand = _tmp0_;
}


static void gee_concurrent_set_instance_init (GeeConcurrentSet * self) {
	GeeConcurrentSetTower* _tmp0_;
	self->priv = GEE_CONCURRENT_SET_GET_PRIVATE (self);
	self->priv->_size = 0;
	_tmp0_ = gee_concurrent_set_tower_new_head (self->priv->g_type, (GBoxedCopyFunc) self->priv->g_dup_func, self->priv->g_destroy_func);
	self->priv->_head = _tmp0_;
}


static void gee_concurrent_set_finalize (GObject* obj) {
	GeeConcurrentSet * self;
	GeeHazardPointerContext* _tmp0_;
	GeeHazardPointerContext* ctx;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, GEE_TYPE_CONCURRENT_SET, GeeConcurrentSet);
	_tmp0_ = gee_hazard_pointer_context_new (NULL);
	ctx = _tmp0_;
	_gee_concurrent_set_tower_unref0 (self->priv->_head);
	self->priv->_head = NULL;
	_gee_hazard_pointer_context_free0 (ctx);
	_gee_concurrent_set_tower_unref0 (self->priv->_head);
	(self->priv->_cmp_target_destroy_notify == NULL) ? NULL : (self->priv->_cmp_target_destroy_notify (self->priv->_cmp_target), NULL);
	self->priv->_cmp = NULL;
	self->priv->_cmp_target = NULL;
	self->priv->_cmp_target_destroy_notify = NULL;
	G_OBJECT_CLASS (gee_concurrent_set_parent_class)->finalize (obj);
}


/**
 * A skip-linked list. This implementation is based on
 * [[http://www.cse.yorku.ca/~ruppert/Mikhail.pdf|Mikhail Fomitchev Master Thesis]].
 *
 * Many threads are allowed to operate on the same structure as well as modification
 * of structure during iteration is allowed. However the change may not be immidiatly
 * visible to other threads.
 */
GType gee_concurrent_set_get_type (void) {
	static volatile gsize gee_concurrent_set_type_id__volatile = 0;
	if (g_once_init_enter (&gee_concurrent_set_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (GeeConcurrentSetClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) gee_concurrent_set_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (GeeConcurrentSet), 0, (GInstanceInitFunc) gee_concurrent_set_instance_init, NULL };
		GType gee_concurrent_set_type_id;
		gee_concurrent_set_type_id = g_type_register_static (GEE_TYPE_ABSTRACT_SORTED_SET, "GeeConcurrentSet", &g_define_type_info, 0);
		g_once_init_leave (&gee_concurrent_set_type_id__volatile, gee_concurrent_set_type_id);
	}
	return gee_concurrent_set_type_id__volatile;
}


static void _vala_gee_concurrent_set_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	GeeConcurrentSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_TYPE_CONCURRENT_SET, GeeConcurrentSet);
	switch (property_id) {
		case GEE_CONCURRENT_SET_SIZE:
		g_value_set_int (value, gee_abstract_collection_get_size ((GeeAbstractCollection*) self));
		break;
		case GEE_CONCURRENT_SET_READ_ONLY:
		g_value_set_boolean (value, gee_abstract_collection_get_read_only ((GeeAbstractCollection*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_gee_concurrent_set_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	GeeConcurrentSet * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, GEE_TYPE_CONCURRENT_SET, GeeConcurrentSet);
	switch (property_id) {
		case GEE_CONCURRENT_SET_G_TYPE:
		self->priv->g_type = g_value_get_gtype (value);
		break;
		case GEE_CONCURRENT_SET_G_DUP_FUNC:
		self->priv->g_dup_func = g_value_get_pointer (value);
		break;
		case GEE_CONCURRENT_SET_G_DESTROY_FUNC:
		self->priv->g_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



