/* gee-internals-0.8.vapi generated by valac 0.20.1.1-1480, do not modify. */

[CCode (gir_namespace = "Gee", gir_version = "0.8")]
namespace Gee {
	namespace Functions {
		[CCode (cheader_filename = "gee-internals.h")]
		public static Gee.EqualDataFunc get_equal_func_for (GLib.Type t);
		[CCode (cheader_filename = "gee-internals.h")]
		public static Gee.HashDataFunc get_hash_func_for (GLib.Type t);
		[CCode (cheader_filename = "gee-internals.h")]
		public static GLib.CompareDataFunc get_compare_func_for (GLib.Type t);
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public abstract class AbstractBidirList<G> : Gee.AbstractList<G>, Gee.BidirList<G> {
		public abstract Gee.BidirListIterator<G> bidir_list_iterator ();
		internal virtual new void reserved0 ();
		internal virtual new void reserved1 ();
		internal virtual new void reserved2 ();
		internal virtual new void reserved3 ();
		internal virtual new void reserved4 ();
		internal virtual new void reserved5 ();
		internal virtual new void reserved6 ();
		internal virtual new void reserved7 ();
		internal virtual new void reserved8 ();
		internal virtual new void reserved9 ();
		public AbstractBidirList ();
		public virtual Gee.BidirList<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public abstract class AbstractBidirSortedSet<G> : Gee.AbstractSortedSet<G>, Gee.BidirSortedSet<G> {
		public abstract Gee.BidirIterator<G> bidir_iterator ();
		internal virtual new void reserved0 ();
		internal virtual new void reserved1 ();
		internal virtual new void reserved2 ();
		internal virtual new void reserved3 ();
		internal virtual new void reserved4 ();
		internal virtual new void reserved5 ();
		internal virtual new void reserved6 ();
		internal virtual new void reserved7 ();
		internal virtual new void reserved8 ();
		internal virtual new void reserved9 ();
		public AbstractBidirSortedSet ();
		public virtual Gee.BidirSortedSet<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public abstract class AbstractBidirSortedMap<K,V> : Gee.AbstractSortedMap<K,V>, Gee.BidirSortedMap<K,V> {
		public abstract Gee.BidirMapIterator<K,V> bidir_map_iterator ();
		internal virtual new void reserved0 ();
		internal virtual new void reserved1 ();
		internal virtual new void reserved2 ();
		internal virtual new void reserved3 ();
		internal virtual new void reserved4 ();
		internal virtual new void reserved5 ();
		internal virtual new void reserved6 ();
		internal virtual new void reserved7 ();
		internal virtual new void reserved8 ();
		internal virtual new void reserved9 ();
		public AbstractBidirSortedMap ();
		public virtual Gee.BidirSortedMap<K,V> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public abstract class AbstractCollection<G> : GLib.Object, Gee.Traversable<G>, Gee.Iterable<G>, Gee.Collection<G> {
		public abstract bool contains (G item);
		public abstract bool add (G item);
		public abstract bool remove (G item);
		public abstract void clear ();
		public abstract Gee.Iterator<G> iterator ();
		public virtual bool @foreach (Gee.ForallFunc<G> f);
		internal virtual void reserved0 ();
		internal virtual void reserved1 ();
		internal virtual void reserved2 ();
		internal virtual void reserved3 ();
		internal virtual void reserved4 ();
		internal virtual void reserved5 ();
		internal virtual void reserved6 ();
		internal virtual void reserved7 ();
		internal virtual void reserved8 ();
		internal virtual void reserved9 ();
		public AbstractCollection ();
		public abstract int size { get; }
		public abstract bool read_only { get; }
		public virtual Gee.Collection<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public abstract class AbstractList<G> : Gee.AbstractCollection<G>, Gee.List<G> {
		public abstract Gee.ListIterator<G> list_iterator ();
		public abstract new G @get (int index);
		public abstract new void @set (int index, G item);
		public abstract int index_of (G item);
		public abstract void insert (int index, G item);
		public abstract G remove_at (int index);
		public abstract Gee.List<G>? slice (int start, int stop);
		internal virtual new void reserved0 ();
		internal virtual new void reserved1 ();
		internal virtual new void reserved2 ();
		internal virtual new void reserved3 ();
		internal virtual new void reserved4 ();
		internal virtual new void reserved5 ();
		internal virtual new void reserved6 ();
		internal virtual new void reserved7 ();
		internal virtual new void reserved8 ();
		internal virtual new void reserved9 ();
		public AbstractList ();
		public virtual Gee.List<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public abstract class AbstractMap<K,V> : GLib.Object, Gee.Traversable<Gee.Map.Entry<K,V>>, Gee.Iterable<Gee.Map.Entry<K,V>>, Gee.Map<K,V> {
		public abstract bool has_key (K key);
		public abstract bool has (K key, V value);
		public abstract new V @get (K key);
		public abstract new void @set (K key, V value);
		public abstract bool unset (K key, out V value = null);
		public abstract Gee.MapIterator<K,V> map_iterator ();
		public abstract void clear ();
		public virtual bool @foreach (Gee.ForallFunc<Gee.Map.Entry<K,V>> f);
		public virtual Gee.Iterator<A> stream<A> (owned Gee.StreamFunc<Gee.Map.Entry<K,V>,A> f);
		internal virtual new void reserved0 ();
		internal virtual new void reserved1 ();
		internal virtual new void reserved2 ();
		internal virtual new void reserved3 ();
		internal virtual new void reserved4 ();
		internal virtual new void reserved5 ();
		internal virtual new void reserved6 ();
		internal virtual new void reserved7 ();
		internal virtual new void reserved8 ();
		internal virtual new void reserved9 ();
		public AbstractMap ();
		public abstract int size { get; }
		public abstract bool read_only { get; }
		public abstract Gee.Set<K> keys { owned get; }
		public abstract Gee.Collection<V> values { owned get; }
		public abstract Gee.Set<Gee.Map.Entry<K,V>> entries { owned get; }
		public virtual Gee.Map<K,V> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public abstract class AbstractMultiMap<K,V> : GLib.Object, Gee.MultiMap<K,V> {
		protected Gee.Map<K,Gee.Collection<V>> _storage_map;
		public AbstractMultiMap (Gee.Map<K,Gee.Collection<V>> storage_map);
		protected abstract Gee.Collection<V> create_value_storage ();
		protected abstract Gee.MultiSet<K> create_multi_key_set ();
		protected abstract Gee.EqualDataFunc<V> get_value_equal_func ();
		internal virtual new void reserved0 ();
		internal virtual new void reserved1 ();
		internal virtual new void reserved2 ();
		internal virtual new void reserved3 ();
		internal virtual new void reserved4 ();
		internal virtual new void reserved5 ();
		internal virtual new void reserved6 ();
		internal virtual new void reserved7 ();
		internal virtual new void reserved8 ();
		public virtual Gee.MultiMap<K,V> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public abstract class AbstractMultiSet<G> : Gee.AbstractCollection<G>, Gee.MultiSet<G> {
		protected Gee.Map<G,int> _storage_map;
		public AbstractMultiSet (Gee.Map<G,int> storage_map);
		public override bool contains (G item);
		public override Gee.Iterator<G> iterator ();
		public override bool add (G item);
		public override bool remove (G item);
		public override void clear ();
		internal virtual new void reserved0 ();
		internal virtual new void reserved1 ();
		internal virtual new void reserved2 ();
		internal virtual new void reserved3 ();
		internal virtual new void reserved4 ();
		internal virtual new void reserved5 ();
		internal virtual new void reserved6 ();
		internal virtual new void reserved7 ();
		internal virtual new void reserved8 ();
		public override int size { get; }
		public override bool read_only { get; }
		public virtual Gee.MultiSet<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public abstract class AbstractQueue<G> : Gee.AbstractCollection<G>, Gee.Queue<G> {
		public abstract G peek ();
		public abstract G poll ();
		internal virtual new void reserved0 ();
		internal virtual new void reserved1 ();
		internal virtual new void reserved2 ();
		internal virtual new void reserved3 ();
		internal virtual new void reserved4 ();
		internal virtual new void reserved5 ();
		internal virtual new void reserved6 ();
		internal virtual new void reserved7 ();
		internal virtual new void reserved8 ();
		internal virtual new void reserved9 ();
		public AbstractQueue ();
		public abstract int capacity { get; }
		public abstract int remaining_capacity { get; }
		public abstract bool is_full { get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public abstract class AbstractSet<G> : Gee.AbstractCollection<G>, Gee.Set<G> {
		internal virtual new void reserved0 ();
		internal virtual new void reserved1 ();
		internal virtual new void reserved2 ();
		internal virtual new void reserved3 ();
		internal virtual new void reserved4 ();
		internal virtual new void reserved5 ();
		internal virtual new void reserved6 ();
		internal virtual new void reserved7 ();
		internal virtual new void reserved8 ();
		internal virtual new void reserved9 ();
		public AbstractSet ();
		public virtual Gee.Set<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public abstract class AbstractSortedMap<K,V> : Gee.AbstractMap<K,V>, Gee.SortedMap<K,V> {
		public abstract Gee.SortedMap<K,V> head_map (K before);
		public abstract Gee.SortedMap<K,V> tail_map (K after);
		public abstract Gee.SortedMap<K,V> sub_map (K before, K after);
		internal virtual new void reserved0 ();
		internal virtual new void reserved1 ();
		internal virtual new void reserved2 ();
		internal virtual new void reserved3 ();
		internal virtual new void reserved4 ();
		internal virtual new void reserved5 ();
		internal virtual new void reserved6 ();
		internal virtual new void reserved7 ();
		internal virtual new void reserved8 ();
		internal virtual new void reserved9 ();
		public AbstractSortedMap ();
		public abstract Gee.SortedSet<K> ascending_keys { owned get; }
		public abstract Gee.SortedSet<Gee.Map.Entry<K,V>> ascending_entries { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public abstract class AbstractSortedSet<G> : Gee.AbstractSet<G>, Gee.SortedSet<G> {
		public abstract G first ();
		public abstract G last ();
		public abstract Gee.Iterator<G>? iterator_at (G element);
		public abstract G lower (G element);
		public abstract G higher (G element);
		public abstract G floor (G element);
		public abstract G ceil (G element);
		public abstract Gee.SortedSet<G> head_set (G before);
		public abstract Gee.SortedSet<G> tail_set (G after);
		public abstract Gee.SortedSet<G> sub_set (G from, G to);
		internal virtual new void reserved0 ();
		internal virtual new void reserved1 ();
		internal virtual new void reserved2 ();
		internal virtual new void reserved3 ();
		internal virtual new void reserved4 ();
		internal virtual new void reserved5 ();
		internal virtual new void reserved6 ();
		internal virtual new void reserved7 ();
		internal virtual new void reserved8 ();
		internal virtual new void reserved9 ();
		public AbstractSortedSet ();
		public virtual Gee.SortedSet<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public class ArrayList<G> : Gee.AbstractBidirList<G> {
		internal G[] _items;
		internal int _size;
		public ArrayList (owned Gee.EqualDataFunc<G>? equal_func = null);
		public ArrayList.wrap (owned G[] items, owned Gee.EqualDataFunc<G>? equal_func = null);
		public override bool @foreach (Gee.ForallFunc<G> f);
		public override Gee.Iterator<G> iterator ();
		public override Gee.ListIterator<G> list_iterator ();
		public override Gee.BidirListIterator<G> bidir_list_iterator ();
		public override bool contains (G item);
		public override int index_of (G item);
		public override G @get (int index);
		public override void @set (int index, G item);
		public override bool add (G item);
		public override void insert (int index, G item);
		public override bool remove (G item);
		public override G remove_at (int index);
		public override void clear ();
		public override Gee.List<G>? slice (int start, int stop);
		public bool add_all (Gee.Collection<G> collection);
		public override int size { get; }
		public override bool read_only { get; }
		[CCode (notify = false)]
		public Gee.EqualDataFunc<G> equal_func { get; private set; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public class ArrayQueue<G> : Gee.AbstractQueue<G>, Gee.Deque<G> {
		public ArrayQueue (owned Gee.EqualDataFunc<G>? equal_func = null);
		public override Gee.Iterator<G> iterator ();
		public override bool add (G element);
		public override bool contains (G item);
		public override bool remove (G item);
		public override void clear ();
		public override G peek ();
		public override G poll ();
		[CCode (notify = false)]
		public Gee.EqualDataFunc<G> equal_func { get; private set; }
		public override int size { get; }
		public bool is_empty { get; }
		public override bool read_only { get; }
		public override int capacity { get; }
		public override int remaining_capacity { get; }
		public override bool is_full { get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public class ConcurrentList<G> : Gee.AbstractList<G> {
		public ConcurrentList (owned Gee.EqualDataFunc<G>? equal_func = null);
		public override bool contains (G item);
		public override bool add (G item);
		public override bool remove (G item);
		public override void clear ();
		public override Gee.Iterator<G> iterator ();
		public override Gee.ListIterator<G> list_iterator ();
		public override G @get (int index);
		public override void @set (int index, G item);
		public override int index_of (G item);
		public override void insert (int index, G item);
		public override G remove_at (int index);
		public override Gee.List<G>? slice (int start, int end);
		[CCode (notify = false)]
		public Gee.EqualDataFunc<G> equal_func { get; private set; }
		public override bool read_only { get; }
		public override int size { get; }
		public bool is_empty { get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public class ConcurrentSet<G> : Gee.AbstractSortedSet<G> {
		public enum RangeType {
			HEAD,
			TAIL,
			BOUNDED,
			EMPTY
		}
		public ConcurrentSet (owned GLib.CompareDataFunc<G>? compare_func = null);
		public override Gee.Iterator<G> iterator ();
		public override bool contains (G key);
		public override bool add (G key);
		public override bool remove (G item);
		public override void clear ();
		public override G first ();
		public override G last ();
		public override Gee.Iterator<G>? iterator_at (G element);
		public override G lower (G element);
		public override G higher (G element);
		public override G floor (G element);
		public override G ceil (G element);
		public override Gee.SortedSet<G> head_set (G before);
		public override Gee.SortedSet<G> tail_set (G after);
		public override Gee.SortedSet<G> sub_set (G from, G to);
		public override int size { get; }
		public override bool read_only { get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public class HashMap<K,V> : Gee.AbstractMap<K,V> {
		public HashMap (owned Gee.HashDataFunc<K>? key_hash_func = null, owned Gee.EqualDataFunc<K>? key_equal_func = null, owned Gee.EqualDataFunc<V>? value_equal_func = null);
		public override bool has_key (K key);
		public override bool has (K key, V value);
		public override V @get (K key);
		public override void @set (K key, V value);
		public override bool unset (K key, out V value = null);
		public override void clear ();
		public override Gee.MapIterator<K,V> map_iterator ();
		public override int size { get; }
		public override bool read_only { get; }
		public override Gee.Set<K> keys { owned get; }
		public override Gee.Collection<V> values { owned get; }
		public override Gee.Set<Gee.Map.Entry<K,V>> entries { owned get; }
		[CCode (notify = false)]
		public Gee.HashDataFunc<K> key_hash_func { get; private set; }
		[CCode (notify = false)]
		public Gee.EqualDataFunc<K> key_equal_func { get; private set; }
		[CCode (notify = false)]
		public Gee.EqualDataFunc<V> value_equal_func { get; private set; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public class HashMultiMap<K,V> : Gee.AbstractMultiMap<K,V> {
		public HashMultiMap (owned Gee.HashDataFunc<K>? key_hash_func = null, owned Gee.EqualDataFunc<K>? key_equal_func = null, owned Gee.HashDataFunc<V>? value_hash_func = null, owned Gee.EqualDataFunc<V>? value_equal_func = null);
		protected override Gee.Collection<V> create_value_storage ();
		protected override Gee.MultiSet<K> create_multi_key_set ();
		protected override Gee.EqualDataFunc get_value_equal_func ();
		public Gee.HashDataFunc<K> key_hash_func { get; }
		public Gee.EqualDataFunc<K> key_equal_func { get; }
		[CCode (notify = false)]
		public Gee.HashDataFunc<V> value_hash_func { get; private set; }
		[CCode (notify = false)]
		public Gee.EqualDataFunc<V> value_equal_func { get; private set; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public class HashMultiSet<G> : Gee.AbstractMultiSet<G> {
		public HashMultiSet (Gee.HashDataFunc<G>? hash_func = null, Gee.EqualDataFunc<G>? equal_func = null);
		public Gee.HashDataFunc<G> hash_func { get; }
		public Gee.EqualDataFunc<G> equal_func { get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public class HashSet<G> : Gee.AbstractSet<G> {
		public HashSet (owned Gee.HashDataFunc<G>? hash_func = null, owned Gee.EqualDataFunc<G>? equal_func = null);
		public override bool contains (G key);
		public override Gee.Iterator<G> iterator ();
		public override bool add (G key);
		public override bool remove (G key);
		public override void clear ();
		public override int size { get; }
		public override bool read_only { get; }
		[CCode (notify = false)]
		public Gee.HashDataFunc<G> hash_func { get; private set; }
		[CCode (notify = false)]
		public Gee.EqualDataFunc<G> equal_func { get; private set; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[Compact]
	public class HazardPointer<G> {
		[Compact]
		public class Context {
			internal Gee.HazardPointer.Context* _parent;
			internal Gee.ArrayList<weak Gee.HazardPointer.FreeNode*> _to_free;
			internal Gee.HazardPointer.Policy? _policy;
			internal static GLib.StaticPrivate _current_context;
			internal static GLib.StaticPrivate _root_context;
			public Context (Gee.HazardPointer.Policy? policy = null);
			public void try_free ();
			public void free_all ();
			public void try_release ();
			public void release ();
			internal void release_ptr (void* ptr, owned Gee.HazardPointer.DestroyNotify notify);
			internal static Gee.HazardPointer.Context* get_current_context ();
		}
		[Compact]
		internal class FreeNode {
			public void* pointer;
			public Gee.HazardPointer.DestroyNotify destroy_notify;
			public FreeNode ();
		}
		[Compact]
		internal class Node {
			public Gee.HazardPointer.Node* _next;
			public int _active;
			public void* _hazard;
			public Node ();
			public void release ();
			public bool is_active ();
			public bool activate ();
			public void @set (void* ptr);
			public void* @get (bool safe = true);
			public unowned Gee.HazardPointer.Node? get_next ();
			public void set_next (Gee.HazardPointer.Node* next);
		}
		public enum Policy {
			DEFAULT,
			THREAD_EXIT,
			TRY_FREE,
			FREE,
			TRY_RELEASE,
			RELEASE;
			public bool is_concrete ();
			public bool is_blocking ();
			public bool is_safe ();
			public Gee.HazardPointer.Policy to_concrete ();
			internal Gee.ArrayList<weak Gee.HazardPointer.FreeNode*>? perform (owned Gee.ArrayList<weak Gee.HazardPointer.FreeNode*> to_free);
		}
		public enum ReleasePolicy {
			HELPER_THREAD,
			MAIN_LOOP;
			internal static void ensure_start ();
		}
		public delegate void DestroyNotify (void* ptr);
		internal weak Gee.HazardPointer.Node _node;
		internal static Gee.HazardPointer.Node* _head;
		internal static int _default_policy;
		internal static int _thread_exit_policy;
		internal static int release_policy;
		internal static Gee.Queue<Gee.ArrayList<weak Gee.HazardPointer.FreeNode*>> _queue;
		internal static GLib.StaticMutex _queue_mutex;
		internal static Gee.ArrayList<weak Gee.HazardPointer.FreeNode*> _global_to_free;
		public HazardPointer (G* ptr);
		internal HazardPointer.from_node (Gee.HazardPointer.Node node);
		public static Gee.HazardPointer<G>? get_hazard_pointer<G> (G** aptr, size_t mask = 0, out size_t mask_out = null);
		public static G get_pointer<G> (G** aptr, size_t mask = 0, out size_t mask_out = null);
		public static Gee.HazardPointer<G>? exchange_hazard_pointer<G> (G** aptr, owned G new_ptr, size_t mask = 0, size_t new_mask = 0, out size_t old_mask = null);
		public static void set_pointer<G> (G** aptr, owned G new_ptr, size_t mask = 0, size_t new_mask = 0);
		public static G exchange_pointer<G> (G** aptr, owned G new_ptr, size_t mask = 0, size_t new_mask = 0, out size_t old_mask = null);
		public static bool compare_and_exchange_pointer<G> (G** aptr, G old_ptr, owned G _new_ptr, size_t mask = 0, size_t old_mask = 0, size_t new_mask = 0);
		public new unowned G @get (bool other_thread = false);
		public void release (owned Gee.HazardPointer.DestroyNotify notify);
		public static void set_default_policy (Gee.HazardPointer.Policy policy);
		public static void set_thread_exit_policy (Gee.HazardPointer.Policy policy);
		public static bool set_release_policy (Gee.HazardPointer.ReleasePolicy policy);
		internal static unowned Gee.HazardPointer.Node acquire ();
		internal static bool try_free (Gee.ArrayList<weak Gee.HazardPointer.FreeNode*> to_free);
		internal static unowned Gee.HazardPointer.Node? get_head ();
		internal static Gee.HazardPointer.DestroyNotify get_destroy_notify<G> ();
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public class Lazy<G> {
		public Lazy (owned Gee.LazyFunc<G> func);
		public Lazy.from_value (G item);
		public void eval ();
		public new G @get ();
		public G value { get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public class LinkedList<G> : Gee.AbstractBidirList<G>, Gee.Queue<G>, Gee.Deque<G> {
		public LinkedList (owned Gee.EqualDataFunc<G>? equal_func = null);
		public override bool @foreach (Gee.ForallFunc<G> f);
		public override Gee.Iterator<G> iterator ();
		public override Gee.ListIterator<G> list_iterator ();
		public override Gee.BidirListIterator<G> bidir_list_iterator ();
		public override bool contains (G item);
		public override bool add (G item);
		public override bool remove (G item);
		public override void clear ();
		public override G @get (int index);
		public override void @set (int index, G item);
		public override int index_of (G item);
		public override void insert (int index, G item);
		public override G remove_at (int index);
		public override Gee.List<G>? slice (int start, int stop);
		public G first ();
		public G last ();
		[CCode (notify = false)]
		public Gee.EqualDataFunc<G> equal_func { get; private set; }
		public override int size { get; }
		public override bool read_only { get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public class PriorityQueue<G> : Gee.AbstractQueue<G> {
		public PriorityQueue (owned GLib.CompareDataFunc<G>? compare_func = null);
		public bool offer (G element);
		public override G peek ();
		public override G poll ();
		public int drain (Gee.Collection<G> recipient, int amount = -1);
		public override bool contains (G item);
		public override bool add (G item);
		public override bool remove (G item);
		public override void clear ();
		public override Gee.Iterator<G> iterator ();
		[CCode (notify = false)]
		public GLib.CompareDataFunc<G> compare_func { get; private set; }
		public override int capacity { get; }
		public override int remaining_capacity { get; }
		public override bool is_full { get; }
		public override bool read_only { get; }
		public override int size { get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	internal class ReadOnlyBidirList<G> : Gee.ReadOnlyList<G>, Gee.BidirList<G> {
		public ReadOnlyBidirList (Gee.BidirList<G> list);
		public virtual Gee.BidirList<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	internal class ReadOnlyBidirSortedSet<G> : Gee.ReadOnlySortedSet<G>, Gee.BidirSortedSet<G> {
		protected class BidirIterator<G> : Gee.ReadOnlyCollection.Iterator<G>, Gee.BidirIterator<G> {
			public BidirIterator (Gee.BidirIterator<G> iterator);
		}
		public ReadOnlyBidirSortedSet (Gee.BidirSortedSet<G> @set);
	}
	[CCode (cheader_filename = "gee-internals.h")]
	internal class ReadOnlyBidirSortedMap<K,V> : Gee.ReadOnlySortedMap<K,V>, Gee.BidirSortedMap<K,V> {
		protected class BidirMapIterator<K,V> : Gee.ReadOnlyMap.MapIterator<K,V>, Gee.BidirMapIterator<K,V> {
			public BidirMapIterator (Gee.BidirMapIterator<K,V> iterator);
		}
		public ReadOnlyBidirSortedMap (Gee.BidirSortedMap<K,V> map);
	}
	[CCode (cheader_filename = "gee-internals.h")]
	internal class ReadOnlyCollection<G> : GLib.Object, Gee.Traversable<G>, Gee.Iterable<G>, Gee.Collection<G> {
		protected class Iterator<G> : GLib.Object, Gee.Traversable<G>, Gee.Iterator<G> {
			protected Gee.Iterator<G> _iter;
			public Iterator (Gee.Iterator<G> iterator);
		}
		protected Gee.Collection<G> _collection;
		public ReadOnlyCollection (Gee.Collection<G> collection);
		public virtual Gee.Collection<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	internal class ReadOnlyList<G> : Gee.ReadOnlyCollection<G>, Gee.List<G> {
		protected class Iterator<G> : Gee.ReadOnlyCollection.Iterator<G>, Gee.ListIterator<G> {
			public Iterator (Gee.ListIterator<G> iterator);
		}
		public ReadOnlyList (Gee.List<G> list);
		public virtual Gee.List<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	internal class ReadOnlyMap<K,V> : GLib.Object, Gee.Traversable<Gee.Map.Entry<K,V>>, Gee.Iterable<Gee.Map.Entry<K,V>>, Gee.Map<K,V> {
		internal class MapIterator<K,V> : GLib.Object, Gee.MapIterator<K,V> {
			protected Gee.MapIterator<K,V> _iter;
			public MapIterator (Gee.MapIterator<K,V> iterator);
		}
		protected Gee.Map<K,V> _map;
		public ReadOnlyMap (Gee.Map<K,V> map);
		public bool contains (K key);
		public bool remove (K key, out V value = null);
		public bool remove_all (Gee.Map<K,V> map);
		public bool contains_all (Gee.Map<K,V> map);
		public virtual Gee.Map<K,V> read_only_view { owned get; }
		public GLib.Type key_type { get; }
		public GLib.Type value_type { get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	internal class ReadOnlyMultiMap<K,V> : GLib.Object, Gee.MultiMap<K,V> {
		public ReadOnlyMultiMap (Gee.MultiMap<K,V> multimap);
		public virtual Gee.MultiMap<K,V> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	internal class ReadOnlyMultiSet<G> : Gee.ReadOnlyCollection<G>, Gee.MultiSet<G> {
		public ReadOnlyMultiSet (Gee.MultiSet<G> multiset);
		public virtual Gee.MultiSet<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	internal class ReadOnlySet<G> : Gee.ReadOnlyCollection<G>, Gee.Set<G> {
		public ReadOnlySet (Gee.Set<G> @set);
		public virtual Gee.Set<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	internal class ReadOnlySortedMap<K,V> : Gee.ReadOnlyMap<K,V>, Gee.SortedMap<K,V> {
		public ReadOnlySortedMap (Gee.Map<K,V> map);
	}
	[CCode (cheader_filename = "gee-internals.h")]
	internal class ReadOnlySortedSet<G> : Gee.ReadOnlySet<G>, Gee.SortedSet<G> {
		public ReadOnlySortedSet (Gee.SortedSet<G> @set);
	}
	[CCode (cheader_filename = "gee-internals.h")]
	internal class TimSort<G> : GLib.Object {
		public static void sort<G> (Gee.List<G> list, GLib.CompareDataFunc<G> compare);
		public TimSort ();
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public class TreeMap<K,V> : Gee.AbstractBidirSortedMap<K,V> {
		public TreeMap (owned GLib.CompareDataFunc<K>? key_compare_func = null, owned Gee.EqualDataFunc<V>? value_equal_func = null);
		public override bool has_key (K key);
		public override bool has (K key, V value);
		public override V @get (K key);
		public override void @set (K key, V value);
		public override bool unset (K key, out V value = null);
		public override void clear ();
		public override Gee.SortedMap<K,V> head_map (K before);
		public override Gee.SortedMap<K,V> tail_map (K after);
		public override Gee.SortedMap<K,V> sub_map (K after, K before);
		public override Gee.MapIterator<K,V> map_iterator ();
		public override Gee.BidirMapIterator<K,V> bidir_map_iterator ();
		public override int size { get; }
		public override bool read_only { get; }
		public override Gee.Set<K> keys { owned get; }
		public override Gee.Collection<V> values { owned get; }
		public override Gee.Set<Gee.Map.Entry<K,V>> entries { owned get; }
		[CCode (notify = false)]
		public GLib.CompareDataFunc<K> key_compare_func { get; private set; }
		[CCode (notify = false)]
		public Gee.EqualDataFunc<V> value_equal_func { get; private set; }
		public override Gee.SortedSet<K> ascending_keys { owned get; }
		public override Gee.SortedSet<Gee.Map.Entry<K,V>> ascending_entries { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public class TreeMultiMap<K,V> : Gee.AbstractMultiMap<K,V> {
		public TreeMultiMap (owned GLib.CompareDataFunc<K>? key_compare_func = null, owned GLib.CompareDataFunc<V>? value_compare_func = null);
		protected override Gee.Collection<V> create_value_storage ();
		protected override Gee.MultiSet<K> create_multi_key_set ();
		protected override Gee.EqualDataFunc<V> get_value_equal_func ();
		public GLib.CompareDataFunc<K> key_compare_func { get; }
		[CCode (notify = false)]
		public GLib.CompareDataFunc<V> value_compare_func { get; private set; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public class TreeMultiSet<G> : Gee.AbstractMultiSet<G> {
		public TreeMultiSet (owned GLib.CompareDataFunc<G>? compare_func = null);
		public GLib.CompareDataFunc<G> compare_func { get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public class TreeSet<G> : Gee.AbstractBidirSortedSet<G> {
		public TreeSet (owned GLib.CompareDataFunc<G>? compare_func = null);
		public override bool contains (G item);
		public override bool add (G item);
		public override bool remove (G item);
		public override void clear ();
		public override Gee.Iterator<G> iterator ();
		public override Gee.BidirIterator<G> bidir_iterator ();
		public override G first ();
		public override G last ();
		public override Gee.SortedSet<G> head_set (G before);
		public override Gee.SortedSet<G> tail_set (G after);
		public override Gee.SortedSet<G> sub_set (G after, G before);
		public override Gee.Iterator<G>? iterator_at (G item);
		public override G lower (G item);
		public override G higher (G item);
		public override G floor (G item);
		public override G ceil (G item);
		public override int size { get; }
		public override bool read_only { get; }
		[CCode (notify = false)]
		public GLib.CompareDataFunc<G> compare_func { get; private set; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	internal class UnfoldIterator<G> : GLib.Object, Gee.Traversable<G>, Gee.Iterator<G> {
		public UnfoldIterator (owned Gee.UnfoldFunc<G> func, owned Gee.Lazy<G>? current = null);
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface BidirIterator<G> : Gee.Iterator<G> {
		public abstract bool previous ();
		public abstract bool has_previous ();
		public abstract bool first ();
		public abstract bool last ();
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface BidirList<G> : Gee.List<G> {
		public abstract new Gee.BidirListIterator<G> bidir_list_iterator ();
		public abstract Gee.BidirList<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface BidirListIterator<G> : Gee.BidirIterator<G>, Gee.ListIterator<G> {
		public abstract void insert (G item);
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface BidirMapIterator<K,V> : Gee.MapIterator<K,V> {
		public abstract bool previous ();
		public abstract bool has_previous ();
		public abstract bool first ();
		public abstract bool last ();
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface BidirSortedSet<G> : Gee.SortedSet<G> {
		public abstract Gee.BidirIterator<G> bidir_iterator ();
		public static Gee.BidirSortedSet<G> empty<G> ();
		public abstract Gee.BidirSortedSet<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface BidirSortedMap<K,V> : Gee.SortedMap<K,V> {
		public abstract Gee.BidirMapIterator<K,V> bidir_map_iterator ();
		public static Gee.BidirSortedMap<K,V> empty<K,V> ();
		public abstract Gee.BidirSortedMap<K,V> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface Collection<G> : Gee.Iterable<G> {
		public abstract bool contains (G item);
		public abstract bool add (G item);
		public abstract bool remove (G item);
		public abstract void clear ();
		public virtual bool add_all (Gee.Collection<G> collection);
		public virtual bool contains_all (Gee.Collection<G> collection);
		public virtual bool remove_all (Gee.Collection<G> collection);
		public virtual bool retain_all (Gee.Collection<G> collection);
		public virtual G[] to_array ();
		public bool add_all_array (G[] array);
		public bool contains_all_array (G[] array);
		public bool remove_all_array (G[] array);
		public static Gee.Collection<G> empty<G> ();
		public abstract int size { get; }
		public virtual bool is_empty { get; }
		public abstract bool read_only { get; }
		public abstract Gee.Collection<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public interface Comparable<G> : GLib.Object {
		public abstract int compare_to (G object);
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface Deque<G> : Gee.Queue<G> {
		public abstract bool offer_head (G element);
		public abstract G peek_head ();
		public abstract G poll_head ();
		public abstract int drain_head (Gee.Collection<G> recipient, int amount = -1);
		public abstract bool offer_tail (G element);
		public abstract G peek_tail ();
		public abstract G poll_tail ();
		public abstract int drain_tail (Gee.Collection<G> recipient, int amount = -1);
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public interface Hashable<G> : GLib.Object {
		public abstract uint hash ();
		public abstract bool equal_to (G object);
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface Iterable<G> : GLib.Object, Gee.Traversable<G> {
		public abstract Gee.Iterator<G> iterator ();
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public interface Iterator<G> : GLib.Object, Gee.Traversable<G> {
		public abstract bool next ();
		public abstract bool has_next ();
		public abstract G @get ();
		public abstract void remove ();
		public static Gee.Iterator<A> unfold<A> (owned Gee.UnfoldFunc<A> f, owned Gee.Lazy<G>? current = null);
		public static Gee.Iterator<G> concat<G> (Gee.Iterator<Gee.Iterator<G>> iters);
		public abstract bool valid { get; }
		public abstract bool read_only { get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface List<G> : Gee.Collection<G> {
		public abstract new Gee.ListIterator<G> list_iterator ();
		public abstract G @get (int index);
		public abstract void @set (int index, G item);
		public abstract int index_of (G item);
		public abstract void insert (int index, G item);
		public abstract G remove_at (int index);
		public abstract Gee.List<G>? slice (int start, int stop);
		public virtual G first ();
		public virtual G last ();
		public virtual void insert_all (int index, Gee.Collection<G> collection);
		public virtual void sort (owned GLib.CompareDataFunc<G>? compare_func = null);
		public static Gee.List<G> empty<G> ();
		public abstract Gee.List<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public interface ListIterator<G> : Gee.Iterator<G> {
		public abstract void @set (G item);
		public abstract void add (G item);
		public abstract int index ();
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface Map<K,V> : GLib.Object, Gee.Iterable<Gee.Map.Entry<K,V>> {
		public abstract class Entry<K,V> : GLib.Object {
			public Entry ();
			public abstract K key { get; }
			public abstract V value { get; set; }
			public abstract bool read_only { get; }
		}
		public abstract bool has_key (K key);
		[Deprecated (replacement = "Map.has_key")]
		public bool contains (K key);
		public abstract bool has (K key, V value);
		public abstract V @get (K key);
		public abstract void @set (K key, V value);
		public abstract bool unset (K key, out V value = null);
		[Deprecated (replacement = "Map.unset")]
		public bool remove (K key, out V value = null);
		public abstract void clear ();
		public abstract Gee.MapIterator<K,V> map_iterator ();
		public virtual void set_all (Gee.Map<K,V> map);
		public virtual bool unset_all (Gee.Map<K,V> map);
		[Deprecated (replacement = "Map.unset_all")]
		public bool remove_all (Gee.Map<K,V> map);
		public virtual bool has_all (Gee.Map<K,V> map);
		[Deprecated (replacement = "Map.has_all")]
		public bool contains_all (Gee.Map<K,V> map);
		public static Gee.Map<K,V> empty<K,V> ();
		public abstract int size { get; }
		public virtual bool is_empty { get; }
		public abstract bool read_only { get; }
		public abstract Gee.Set<K> keys { owned get; }
		public abstract Gee.Collection<V> values { owned get; }
		public abstract Gee.Set<Gee.Map.Entry<K,V>> entries { owned get; }
		public abstract Gee.Map<K,V> read_only_view { owned get; }
		public GLib.Type key_type { get; }
		public GLib.Type value_type { get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface MapIterator<K,V> : GLib.Object {
		public abstract bool next ();
		public abstract bool has_next ();
		public abstract K get_key ();
		public abstract V get_value ();
		public abstract void set_value (V value);
		public abstract void unset ();
		public virtual A fold<A> (Gee.FoldMapFunc<A,K,V> f, owned A seed);
		public virtual new bool @foreach (Gee.ForallMapFunc<K,V> f);
		public abstract bool valid { get; }
		public abstract bool mutable { get; }
		public abstract bool read_only { get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface MultiMap<K,V> : GLib.Object {
		public abstract Gee.Set<K> get_keys ();
		public abstract Gee.MultiSet<K> get_all_keys ();
		public abstract Gee.Collection<V> get_values ();
		public abstract bool contains (K key);
		public abstract Gee.Collection<V> @get (K key);
		public abstract void @set (K key, V value);
		public abstract bool remove (K key, V value);
		public abstract bool remove_all (K key);
		public abstract void clear ();
		public abstract Gee.MapIterator<K,V> map_iterator ();
		public abstract int size { get; }
		public abstract bool read_only { get; }
		public GLib.Type key_type { get; }
		public GLib.Type value_type { get; }
		public virtual Gee.MultiMap<K,V> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface MultiSet<G> : Gee.Collection<G> {
		public abstract int count (G item);
		public static Gee.Set<G> empty<G> ();
		public virtual Gee.MultiSet<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface Queue<G> : Gee.Collection<G> {
		public const int UNBOUNDED_CAPACITY;
		public virtual bool offer (G element);
		public abstract G peek ();
		public abstract G poll ();
		public virtual int drain (Gee.Collection<G> recipient, int amount = -1);
		public abstract int capacity { get; }
		public abstract int remaining_capacity { get; }
		public abstract bool is_full { get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface Set<G> : Gee.Collection<G> {
		public static Gee.Set<G> empty<G> ();
		public abstract Gee.Set<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public interface SortedMap<K,V> : Gee.Map<K,V> {
		public abstract Gee.SortedMap<K,V> head_map (K before);
		public abstract Gee.SortedMap<K,V> tail_map (K after);
		public abstract Gee.SortedMap<K,V> sub_map (K before, K after);
		public static Gee.Map<K,V> empty<K,V> ();
		public abstract Gee.SortedSet<K> ascending_keys { owned get; }
		public abstract Gee.SortedSet<Gee.Map.Entry<K,V>> ascending_entries { owned get; }
		public abstract Gee.SortedMap<K,V> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface SortedSet<G> : Gee.Set<G> {
		public abstract G first ();
		public abstract G last ();
		public abstract Gee.Iterator<G>? iterator_at (G element);
		public abstract G lower (G element);
		public abstract G higher (G element);
		public abstract G floor (G element);
		public abstract G ceil (G element);
		public abstract Gee.SortedSet<G> head_set (G before);
		public abstract Gee.SortedSet<G> tail_set (G after);
		public abstract Gee.SortedSet<G> sub_set (G from, G to);
		public static Gee.SortedSet<G> empty<G> ();
		public abstract Gee.SortedSet<G> read_only_view { owned get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	[GenericAccessors]
	public interface Traversable<G> : GLib.Object {
		public enum Stream {
			YIELD,
			CONTINUE,
			END
		}
		public abstract new bool @foreach (Gee.ForallFunc<G> f);
		public virtual Gee.Iterator<A> stream<A> (owned Gee.StreamFunc<G,A> f);
		public virtual A fold<A> (Gee.FoldFunc<A,G> f, owned A seed);
		public virtual Gee.Iterator<A> map<A> (Gee.MapFunc<A,G> f);
		public virtual Gee.Iterator<A> scan<A> (Gee.FoldFunc<A,G> f, owned A seed);
		public virtual Gee.Iterator<G> filter (owned Gee.Predicate<G> pred);
		public virtual Gee.Iterator<G> chop (int offset, int length = -1);
		public virtual GLib.Type element_type { get; }
	}
	[CCode (cheader_filename = "gee-internals.h")]
	public delegate uint HashDataFunc<T> (T v);
	[CCode (cheader_filename = "gee-internals.h")]
	public delegate bool EqualDataFunc<T> (T a, T b);
	[CCode (cheader_filename = "gee-internals.h")]
	public delegate G LazyFunc<G> ();
	[CCode (cheader_filename = "gee-internals.h")]
	public delegate A FoldMapFunc<A,K,V> (K k, V v, owned A a);
	[CCode (cheader_filename = "gee-internals.h")]
	public delegate bool ForallMapFunc<K,V> (K k, V v);
	[CCode (cheader_filename = "gee-internals.h")]
	public delegate A FoldFunc<A,G> (owned G g, owned A a);
	[CCode (cheader_filename = "gee-internals.h")]
	public delegate bool ForallFunc<G> (owned G g);
	[CCode (cheader_filename = "gee-internals.h")]
	public delegate Gee.Lazy<A>? UnfoldFunc<A> ();
	[CCode (cheader_filename = "gee-internals.h")]
	public delegate Gee.Traversable.Stream StreamFunc<G,A> (Gee.Traversable.Stream state, owned Gee.Lazy<G>? g, out Gee.Lazy<A>? lazy);
	[CCode (cheader_filename = "gee-internals.h")]
	public delegate A MapFunc<A,G> (owned G g);
	[CCode (cheader_filename = "gee-internals.h")]
	public delegate bool Predicate<G> (G g);
}
