/* testreadonlylist.c generated by valac 0.20.1.66-2886, the Vala compiler
 * generated from testreadonlylist.vala, do not modify */

/* testreadonlylist.vala
 *
 * Copyright (C) 2008  Jürg Billeter
 * Copyright (C) 2009  Didier Villevalois
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Tomaž Vajngerl <quikee@gmail.com>
 * 	Julien Peeters <contact@julienpeeters.fr>
 * 	Didier 'Ptitjes' Villevalois <ptitjes@free.fr>
 */

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>


#define GEE_TYPE_TEST_CASE (gee_test_case_get_type ())
#define GEE_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_TEST_CASE, GeeTestCase))
#define GEE_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_TEST_CASE, GeeTestCaseClass))
#define GEE_IS_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_TEST_CASE))
#define GEE_IS_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_TEST_CASE))
#define GEE_TEST_CASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_TEST_CASE, GeeTestCaseClass))

typedef struct _GeeTestCase GeeTestCase;
typedef struct _GeeTestCaseClass GeeTestCaseClass;
typedef struct _GeeTestCasePrivate GeeTestCasePrivate;

#define TYPE_READ_ONLY_COLLECTION_TESTS (read_only_collection_tests_get_type ())
#define READ_ONLY_COLLECTION_TESTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_READ_ONLY_COLLECTION_TESTS, ReadOnlyCollectionTests))
#define READ_ONLY_COLLECTION_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_READ_ONLY_COLLECTION_TESTS, ReadOnlyCollectionTestsClass))
#define IS_READ_ONLY_COLLECTION_TESTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_READ_ONLY_COLLECTION_TESTS))
#define IS_READ_ONLY_COLLECTION_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_READ_ONLY_COLLECTION_TESTS))
#define READ_ONLY_COLLECTION_TESTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_READ_ONLY_COLLECTION_TESTS, ReadOnlyCollectionTestsClass))

typedef struct _ReadOnlyCollectionTests ReadOnlyCollectionTests;
typedef struct _ReadOnlyCollectionTestsClass ReadOnlyCollectionTestsClass;
typedef struct _ReadOnlyCollectionTestsPrivate ReadOnlyCollectionTestsPrivate;

#define TYPE_READ_ONLY_LIST_TESTS (read_only_list_tests_get_type ())
#define READ_ONLY_LIST_TESTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_READ_ONLY_LIST_TESTS, ReadOnlyListTests))
#define READ_ONLY_LIST_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_READ_ONLY_LIST_TESTS, ReadOnlyListTestsClass))
#define IS_READ_ONLY_LIST_TESTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_READ_ONLY_LIST_TESTS))
#define IS_READ_ONLY_LIST_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_READ_ONLY_LIST_TESTS))
#define READ_ONLY_LIST_TESTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_READ_ONLY_LIST_TESTS, ReadOnlyListTestsClass))

typedef struct _ReadOnlyListTests ReadOnlyListTests;
typedef struct _ReadOnlyListTestsClass ReadOnlyListTestsClass;
typedef struct _ReadOnlyListTestsPrivate ReadOnlyListTestsPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _GeeTestCase {
	GObject parent_instance;
	GeeTestCasePrivate * priv;
};

struct _GeeTestCaseClass {
	GObjectClass parent_class;
	void (*set_up) (GeeTestCase* self);
	void (*tear_down) (GeeTestCase* self);
};

struct _ReadOnlyCollectionTests {
	GeeTestCase parent_instance;
	ReadOnlyCollectionTestsPrivate * priv;
	GeeCollection* test_collection;
	GeeCollection* ro_collection;
};

struct _ReadOnlyCollectionTestsClass {
	GeeTestCaseClass parent_class;
	GeeCollection* (*get_ro_view) (ReadOnlyCollectionTests* self, GeeCollection* collection);
};

struct _ReadOnlyListTests {
	ReadOnlyCollectionTests parent_instance;
	ReadOnlyListTestsPrivate * priv;
};

struct _ReadOnlyListTestsClass {
	ReadOnlyCollectionTestsClass parent_class;
};

typedef void (*GeeTestCaseTestMethod) (void* user_data);

static gpointer read_only_list_tests_parent_class = NULL;

GType gee_test_case_get_type (void) G_GNUC_CONST;
GType read_only_collection_tests_get_type (void) G_GNUC_CONST;
GType read_only_list_tests_get_type (void) G_GNUC_CONST;
enum  {
	READ_ONLY_LIST_TESTS_DUMMY_PROPERTY
};
ReadOnlyListTests* read_only_list_tests_new (void);
ReadOnlyListTests* read_only_list_tests_construct (GType object_type);
ReadOnlyListTests* read_only_list_tests_new_with_name (const gchar* name);
ReadOnlyListTests* read_only_list_tests_construct_with_name (GType object_type, const gchar* name);
ReadOnlyCollectionTests* read_only_collection_tests_new_with_name (const gchar* name);
ReadOnlyCollectionTests* read_only_collection_tests_construct_with_name (GType object_type, const gchar* name);
void gee_test_case_add_test (GeeTestCase* self, const gchar* name, GeeTestCaseTestMethod test, void* test_target, GDestroyNotify test_target_destroy_notify);
void read_only_list_tests_test_immutable_iterator (ReadOnlyListTests* self);
static void _read_only_list_tests_test_immutable_iterator_gee_test_case_test_method (gpointer self);
void read_only_list_tests_test_immutable (ReadOnlyListTests* self);
static void _read_only_list_tests_test_immutable_gee_test_case_test_method (gpointer self);
void read_only_list_tests_test_accurate_view (ReadOnlyListTests* self);
static void _read_only_list_tests_test_accurate_view_gee_test_case_test_method (gpointer self);
static void read_only_list_tests_real_set_up (GeeTestCase* base);
GeeCollection* read_only_collection_tests_get_ro_view (ReadOnlyCollectionTests* self, GeeCollection* collection);
static void read_only_list_tests_real_tear_down (GeeTestCase* base);
static GeeCollection* read_only_list_tests_real_get_ro_view (ReadOnlyCollectionTests* base, GeeCollection* collection);


ReadOnlyListTests* read_only_list_tests_construct (GType object_type) {
	ReadOnlyListTests * self = NULL;
	self = (ReadOnlyListTests*) read_only_list_tests_construct_with_name (object_type, "ReadOnlyList");
	return self;
}


ReadOnlyListTests* read_only_list_tests_new (void) {
	return read_only_list_tests_construct (TYPE_READ_ONLY_LIST_TESTS);
}


static void _read_only_list_tests_test_immutable_iterator_gee_test_case_test_method (gpointer self) {
	read_only_list_tests_test_immutable_iterator (self);
}


static void _read_only_list_tests_test_immutable_gee_test_case_test_method (gpointer self) {
	read_only_list_tests_test_immutable (self);
}


static void _read_only_list_tests_test_accurate_view_gee_test_case_test_method (gpointer self) {
	read_only_list_tests_test_accurate_view (self);
}


ReadOnlyListTests* read_only_list_tests_construct_with_name (GType object_type, const gchar* name) {
	ReadOnlyListTests * self = NULL;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = name;
	self = (ReadOnlyListTests*) read_only_collection_tests_construct_with_name (object_type, _tmp0_);
	gee_test_case_add_test ((GeeTestCase*) self, "[ReadOnlyList] immutable iterator", _read_only_list_tests_test_immutable_iterator_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[ReadOnlyList] immutable", _read_only_list_tests_test_immutable_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[ReadOnlyList] accurate view", _read_only_list_tests_test_accurate_view_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	return self;
}


ReadOnlyListTests* read_only_list_tests_new_with_name (const gchar* name) {
	return read_only_list_tests_construct_with_name (TYPE_READ_ONLY_LIST_TESTS, name);
}


static void read_only_list_tests_real_set_up (GeeTestCase* base) {
	ReadOnlyListTests * self;
	GeeArrayList* _tmp0_ = NULL;
	GeeCollection* _tmp1_ = NULL;
	GeeCollection* _tmp2_ = NULL;
	self = (ReadOnlyListTests*) base;
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	_g_object_unref0 (((ReadOnlyCollectionTests*) self)->test_collection);
	((ReadOnlyCollectionTests*) self)->test_collection = (GeeCollection*) _tmp0_;
	_tmp1_ = ((ReadOnlyCollectionTests*) self)->test_collection;
	_tmp2_ = read_only_collection_tests_get_ro_view ((ReadOnlyCollectionTests*) self, _tmp1_);
	_g_object_unref0 (((ReadOnlyCollectionTests*) self)->ro_collection);
	((ReadOnlyCollectionTests*) self)->ro_collection = _tmp2_;
}


static void read_only_list_tests_real_tear_down (GeeTestCase* base) {
	ReadOnlyListTests * self;
	self = (ReadOnlyListTests*) base;
	_g_object_unref0 (((ReadOnlyCollectionTests*) self)->test_collection);
	((ReadOnlyCollectionTests*) self)->test_collection = NULL;
	_g_object_unref0 (((ReadOnlyCollectionTests*) self)->ro_collection);
	((ReadOnlyCollectionTests*) self)->ro_collection = NULL;
}


static GeeCollection* read_only_list_tests_real_get_ro_view (ReadOnlyCollectionTests* base, GeeCollection* collection) {
	ReadOnlyListTests * self;
	GeeCollection* result = NULL;
	GeeCollection* _tmp0_ = NULL;
	GeeList* _tmp1_ = NULL;
	GeeList* _tmp2_ = NULL;
	self = (ReadOnlyListTests*) base;
	g_return_val_if_fail (collection != NULL, NULL);
	_tmp0_ = collection;
	_tmp1_ = gee_list_get_read_only_view (G_TYPE_CHECK_INSTANCE_CAST (_tmp0_, GEE_TYPE_LIST, GeeList));
	_tmp2_ = _tmp1_;
	result = (GeeCollection*) _tmp2_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void read_only_list_tests_test_immutable_iterator (ReadOnlyListTests* self) {
	GeeList* test_list = NULL;
	GeeCollection* _tmp0_ = NULL;
	GeeList* _tmp1_ = NULL;
	GeeList* ro_list = NULL;
	GeeCollection* _tmp2_ = NULL;
	GeeList* _tmp3_ = NULL;
	GeeList* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	GeeList* _tmp6_ = NULL;
	gboolean _tmp7_ = FALSE;
	GeeList* _tmp8_ = NULL;
	gint _tmp9_ = 0;
	gint _tmp10_ = 0;
	GeeList* _tmp11_ = NULL;
	gpointer _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	GeeList* _tmp14_ = NULL;
	gpointer _tmp15_ = NULL;
	gchar* _tmp16_ = NULL;
	GeeListIterator* iterator = NULL;
	GeeList* _tmp17_ = NULL;
	GeeListIterator* _tmp18_ = NULL;
	GeeListIterator* _tmp19_ = NULL;
	gboolean _tmp20_ = FALSE;
	GeeListIterator* _tmp21_ = NULL;
	gboolean _tmp22_ = FALSE;
	GeeListIterator* _tmp23_ = NULL;
	gpointer _tmp24_ = NULL;
	gchar* _tmp25_ = NULL;
	GeeListIterator* _tmp26_ = NULL;
	gint _tmp27_ = 0;
	GeeListIterator* _tmp28_ = NULL;
	gboolean _tmp29_ = FALSE;
	GeeListIterator* _tmp30_ = NULL;
	gboolean _tmp31_ = FALSE;
	GeeListIterator* _tmp32_ = NULL;
	gpointer _tmp33_ = NULL;
	gchar* _tmp34_ = NULL;
	GeeListIterator* _tmp35_ = NULL;
	gint _tmp36_ = 0;
	GeeListIterator* _tmp37_ = NULL;
	gboolean _tmp38_ = FALSE;
	GeeListIterator* _tmp39_ = NULL;
	gboolean _tmp40_ = FALSE;
	GeeList* _tmp41_ = NULL;
	GeeListIterator* _tmp42_ = NULL;
	GeeListIterator* _tmp43_ = NULL;
	gboolean _tmp44_ = FALSE;
	gboolean _tmp45_ = FALSE;
	GeeList* _tmp47_ = NULL;
	gint _tmp48_ = 0;
	gint _tmp49_ = 0;
	GeeList* _tmp50_ = NULL;
	gpointer _tmp51_ = NULL;
	gchar* _tmp52_ = NULL;
	GeeList* _tmp53_ = NULL;
	gpointer _tmp54_ = NULL;
	gchar* _tmp55_ = NULL;
	GeeListIterator* _tmp56_ = NULL;
	gint _tmp57_ = 0;
	gboolean _tmp58_ = FALSE;
	GeeList* _tmp60_ = NULL;
	gint _tmp61_ = 0;
	gint _tmp62_ = 0;
	GeeList* _tmp63_ = NULL;
	gpointer _tmp64_ = NULL;
	gchar* _tmp65_ = NULL;
	GeeList* _tmp66_ = NULL;
	gpointer _tmp67_ = NULL;
	gchar* _tmp68_ = NULL;
	GeeListIterator* _tmp69_ = NULL;
	gint _tmp70_ = 0;
	GeeList* _tmp71_ = NULL;
	gint _tmp72_ = 0;
	gint _tmp73_ = 0;
	GeeList* _tmp74_ = NULL;
	gpointer _tmp75_ = NULL;
	gchar* _tmp76_ = NULL;
	GeeList* _tmp77_ = NULL;
	gpointer _tmp78_ = NULL;
	gchar* _tmp79_ = NULL;
	GeeListIterator* _tmp80_ = NULL;
	gint _tmp81_ = 0;
	gboolean _tmp82_ = FALSE;
	GeeList* _tmp84_ = NULL;
	gint _tmp85_ = 0;
	gint _tmp86_ = 0;
	GeeList* _tmp87_ = NULL;
	gpointer _tmp88_ = NULL;
	gchar* _tmp89_ = NULL;
	GeeList* _tmp90_ = NULL;
	gpointer _tmp91_ = NULL;
	gchar* _tmp92_ = NULL;
	GeeListIterator* _tmp93_ = NULL;
	gint _tmp94_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = ((ReadOnlyCollectionTests*) self)->test_collection;
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, GEE_TYPE_LIST) ? ((GeeList*) _tmp0_) : NULL);
	test_list = _tmp1_;
	_tmp2_ = ((ReadOnlyCollectionTests*) self)->ro_collection;
	_tmp3_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, GEE_TYPE_LIST) ? ((GeeList*) _tmp2_) : NULL);
	ro_list = _tmp3_;
	_tmp4_ = test_list;
	_tmp5_ = gee_collection_add ((GeeCollection*) _tmp4_, "one");
	_vala_assert (_tmp5_, "test_list.add (\"one\")");
	_tmp6_ = test_list;
	_tmp7_ = gee_collection_add ((GeeCollection*) _tmp6_, "two");
	_vala_assert (_tmp7_, "test_list.add (\"two\")");
	_tmp8_ = ro_list;
	_tmp9_ = gee_collection_get_size ((GeeCollection*) _tmp8_);
	_tmp10_ = _tmp9_;
	_vala_assert (_tmp10_ == 2, "ro_list.size == 2");
	_tmp11_ = ro_list;
	_tmp12_ = gee_list_get (_tmp11_, 0);
	_tmp13_ = (gchar*) _tmp12_;
	_vala_assert (g_strcmp0 (_tmp13_, "one") == 0, "ro_list.get (0) == \"one\"");
	_g_free0 (_tmp13_);
	_tmp14_ = ro_list;
	_tmp15_ = gee_list_get (_tmp14_, 1);
	_tmp16_ = (gchar*) _tmp15_;
	_vala_assert (g_strcmp0 (_tmp16_, "two") == 0, "ro_list.get (1) == \"two\"");
	_g_free0 (_tmp16_);
	_tmp17_ = ro_list;
	_tmp18_ = gee_list_list_iterator (_tmp17_);
	iterator = _tmp18_;
	_tmp19_ = iterator;
	_tmp20_ = gee_iterator_has_next ((GeeIterator*) _tmp19_);
	_vala_assert (_tmp20_, "iterator.has_next ()");
	_tmp21_ = iterator;
	_tmp22_ = gee_iterator_next ((GeeIterator*) _tmp21_);
	_vala_assert (_tmp22_, "iterator.next ()");
	_tmp23_ = iterator;
	_tmp24_ = gee_iterator_get ((GeeIterator*) _tmp23_);
	_tmp25_ = (gchar*) _tmp24_;
	_vala_assert (g_strcmp0 (_tmp25_, "one") == 0, "iterator.get () == \"one\"");
	_g_free0 (_tmp25_);
	_tmp26_ = iterator;
	_tmp27_ = gee_list_iterator_index (_tmp26_);
	_vala_assert (_tmp27_ == 0, "iterator.index () == 0");
	_tmp28_ = iterator;
	_tmp29_ = gee_iterator_has_next ((GeeIterator*) _tmp28_);
	_vala_assert (_tmp29_, "iterator.has_next ()");
	_tmp30_ = iterator;
	_tmp31_ = gee_iterator_next ((GeeIterator*) _tmp30_);
	_vala_assert (_tmp31_, "iterator.next ()");
	_tmp32_ = iterator;
	_tmp33_ = gee_iterator_get ((GeeIterator*) _tmp32_);
	_tmp34_ = (gchar*) _tmp33_;
	_vala_assert (g_strcmp0 (_tmp34_, "two") == 0, "iterator.get () == \"two\"");
	_g_free0 (_tmp34_);
	_tmp35_ = iterator;
	_tmp36_ = gee_list_iterator_index (_tmp35_);
	_vala_assert (_tmp36_ == 1, "iterator.index () == 1");
	_tmp37_ = iterator;
	_tmp38_ = gee_iterator_has_next ((GeeIterator*) _tmp37_);
	_vala_assert (!_tmp38_, "! iterator.has_next ()");
	_tmp39_ = iterator;
	_tmp40_ = gee_iterator_next ((GeeIterator*) _tmp39_);
	_vala_assert (!_tmp40_, "! iterator.next ()");
	_tmp41_ = ro_list;
	_tmp42_ = gee_list_list_iterator (_tmp41_);
	_g_object_unref0 (iterator);
	iterator = _tmp42_;
	_tmp43_ = iterator;
	_tmp44_ = gee_iterator_next ((GeeIterator*) _tmp43_);
	_vala_assert (_tmp44_, "iterator.next ()");
	_tmp45_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp45_) {
		GeeListIterator* _tmp46_ = NULL;
		_tmp46_ = iterator;
		gee_iterator_remove ((GeeIterator*) _tmp46_);
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp47_ = ro_list;
	_tmp48_ = gee_collection_get_size ((GeeCollection*) _tmp47_);
	_tmp49_ = _tmp48_;
	_vala_assert (_tmp49_ == 2, "ro_list.size == 2");
	_tmp50_ = ro_list;
	_tmp51_ = gee_list_get (_tmp50_, 0);
	_tmp52_ = (gchar*) _tmp51_;
	_vala_assert (g_strcmp0 (_tmp52_, "one") == 0, "ro_list.get (0) == \"one\"");
	_g_free0 (_tmp52_);
	_tmp53_ = ro_list;
	_tmp54_ = gee_list_get (_tmp53_, 1);
	_tmp55_ = (gchar*) _tmp54_;
	_vala_assert (g_strcmp0 (_tmp55_, "two") == 0, "ro_list.get (1) == \"two\"");
	_g_free0 (_tmp55_);
	_tmp56_ = iterator;
	_tmp57_ = gee_list_iterator_index (_tmp56_);
	_vala_assert (_tmp57_ == 0, "iterator.index () == 0");
	_tmp58_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp58_) {
		GeeListIterator* _tmp59_ = NULL;
		_tmp59_ = iterator;
		gee_list_iterator_set (_tmp59_, "three");
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp60_ = ro_list;
	_tmp61_ = gee_collection_get_size ((GeeCollection*) _tmp60_);
	_tmp62_ = _tmp61_;
	_vala_assert (_tmp62_ == 2, "ro_list.size == 2");
	_tmp63_ = ro_list;
	_tmp64_ = gee_list_get (_tmp63_, 0);
	_tmp65_ = (gchar*) _tmp64_;
	_vala_assert (g_strcmp0 (_tmp65_, "one") == 0, "ro_list.get (0) == \"one\"");
	_g_free0 (_tmp65_);
	_tmp66_ = ro_list;
	_tmp67_ = gee_list_get (_tmp66_, 1);
	_tmp68_ = (gchar*) _tmp67_;
	_vala_assert (g_strcmp0 (_tmp68_, "two") == 0, "ro_list.get (1) == \"two\"");
	_g_free0 (_tmp68_);
	_tmp69_ = iterator;
	_tmp70_ = gee_list_iterator_index (_tmp69_);
	_vala_assert (_tmp70_ == 0, "iterator.index () == 0");
	_tmp71_ = ro_list;
	_tmp72_ = gee_collection_get_size ((GeeCollection*) _tmp71_);
	_tmp73_ = _tmp72_;
	_vala_assert (_tmp73_ == 2, "ro_list.size == 2");
	_tmp74_ = ro_list;
	_tmp75_ = gee_list_get (_tmp74_, 0);
	_tmp76_ = (gchar*) _tmp75_;
	_vala_assert (g_strcmp0 (_tmp76_, "one") == 0, "ro_list.get (0) == \"one\"");
	_g_free0 (_tmp76_);
	_tmp77_ = ro_list;
	_tmp78_ = gee_list_get (_tmp77_, 1);
	_tmp79_ = (gchar*) _tmp78_;
	_vala_assert (g_strcmp0 (_tmp79_, "two") == 0, "ro_list.get (1) == \"two\"");
	_g_free0 (_tmp79_);
	_tmp80_ = iterator;
	_tmp81_ = gee_list_iterator_index (_tmp80_);
	_vala_assert (_tmp81_ == 0, "iterator.index () == 0");
	_tmp82_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp82_) {
		GeeListIterator* _tmp83_ = NULL;
		_tmp83_ = iterator;
		gee_list_iterator_add (_tmp83_, "three");
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp84_ = ro_list;
	_tmp85_ = gee_collection_get_size ((GeeCollection*) _tmp84_);
	_tmp86_ = _tmp85_;
	_vala_assert (_tmp86_ == 2, "ro_list.size == 2");
	_tmp87_ = ro_list;
	_tmp88_ = gee_list_get (_tmp87_, 0);
	_tmp89_ = (gchar*) _tmp88_;
	_vala_assert (g_strcmp0 (_tmp89_, "one") == 0, "ro_list.get (0) == \"one\"");
	_g_free0 (_tmp89_);
	_tmp90_ = ro_list;
	_tmp91_ = gee_list_get (_tmp90_, 1);
	_tmp92_ = (gchar*) _tmp91_;
	_vala_assert (g_strcmp0 (_tmp92_, "two") == 0, "ro_list.get (1) == \"two\"");
	_g_free0 (_tmp92_);
	_tmp93_ = iterator;
	_tmp94_ = gee_list_iterator_index (_tmp93_);
	_vala_assert (_tmp94_ == 0, "iterator.index () == 0");
	_g_object_unref0 (iterator);
	_g_object_unref0 (ro_list);
	_g_object_unref0 (test_list);
}


void read_only_list_tests_test_immutable (ReadOnlyListTests* self) {
	GeeList* test_list = NULL;
	GeeCollection* _tmp0_ = NULL;
	GeeList* _tmp1_ = NULL;
	GeeList* ro_list = NULL;
	GeeCollection* _tmp2_ = NULL;
	GeeList* _tmp3_ = NULL;
	GeeList* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	GeeList* _tmp6_ = NULL;
	gint _tmp7_ = 0;
	gint _tmp8_ = 0;
	GeeList* _tmp9_ = NULL;
	gboolean _tmp10_ = FALSE;
	GeeCollection* dummy = NULL;
	GeeArrayList* _tmp11_ = NULL;
	GeeCollection* _tmp12_ = NULL;
	gboolean _tmp13_ = FALSE;
	GeeCollection* _tmp14_ = NULL;
	gboolean _tmp15_ = FALSE;
	gboolean _tmp16_ = FALSE;
	GeeList* _tmp18_ = NULL;
	gint _tmp19_ = 0;
	gint _tmp20_ = 0;
	GeeList* _tmp21_ = NULL;
	gboolean _tmp22_ = FALSE;
	gboolean _tmp23_ = FALSE;
	GeeList* _tmp25_ = NULL;
	gint _tmp26_ = 0;
	gint _tmp27_ = 0;
	GeeList* _tmp28_ = NULL;
	gboolean _tmp29_ = FALSE;
	gboolean _tmp30_ = FALSE;
	GeeList* _tmp34_ = NULL;
	gint _tmp35_ = 0;
	gint _tmp36_ = 0;
	GeeList* _tmp37_ = NULL;
	gboolean _tmp38_ = FALSE;
	gboolean _tmp39_ = FALSE;
	GeeList* _tmp42_ = NULL;
	gint _tmp43_ = 0;
	gint _tmp44_ = 0;
	GeeList* _tmp45_ = NULL;
	gboolean _tmp46_ = FALSE;
	gboolean _tmp47_ = FALSE;
	GeeList* _tmp49_ = NULL;
	gint _tmp50_ = 0;
	gint _tmp51_ = 0;
	GeeList* _tmp52_ = NULL;
	gboolean _tmp53_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = ((ReadOnlyCollectionTests*) self)->test_collection;
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, GEE_TYPE_LIST) ? ((GeeList*) _tmp0_) : NULL);
	test_list = _tmp1_;
	_tmp2_ = ((ReadOnlyCollectionTests*) self)->ro_collection;
	_tmp3_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, GEE_TYPE_LIST) ? ((GeeList*) _tmp2_) : NULL);
	ro_list = _tmp3_;
	_tmp4_ = test_list;
	_tmp5_ = gee_collection_add ((GeeCollection*) _tmp4_, "one");
	_vala_assert (_tmp5_, "test_list.add (\"one\")");
	_tmp6_ = ro_list;
	_tmp7_ = gee_collection_get_size ((GeeCollection*) _tmp6_);
	_tmp8_ = _tmp7_;
	_vala_assert (_tmp8_ == 1, "ro_list.size == 1");
	_tmp9_ = ro_list;
	_tmp10_ = gee_collection_contains ((GeeCollection*) _tmp9_, "one");
	_vala_assert (_tmp10_, "ro_list.contains (\"one\")");
	_tmp11_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	dummy = (GeeCollection*) _tmp11_;
	_tmp12_ = dummy;
	_tmp13_ = gee_collection_add (_tmp12_, "one");
	_vala_assert (_tmp13_, "dummy.add (\"one\")");
	_tmp14_ = dummy;
	_tmp15_ = gee_collection_add (_tmp14_, "two");
	_vala_assert (_tmp15_, "dummy.add (\"two\")");
	_tmp16_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp16_) {
		GeeList* _tmp17_ = NULL;
		_tmp17_ = ro_list;
		gee_list_set (_tmp17_, 0, "two");
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp18_ = ro_list;
	_tmp19_ = gee_collection_get_size ((GeeCollection*) _tmp18_);
	_tmp20_ = _tmp19_;
	_vala_assert (_tmp20_ == 1, "ro_list.size == 1");
	_tmp21_ = ro_list;
	_tmp22_ = gee_collection_contains ((GeeCollection*) _tmp21_, "one");
	_vala_assert (_tmp22_, "ro_list.contains (\"one\")");
	_tmp23_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp23_) {
		GeeList* _tmp24_ = NULL;
		_tmp24_ = ro_list;
		gee_list_insert (_tmp24_, 1, "two");
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp25_ = ro_list;
	_tmp26_ = gee_collection_get_size ((GeeCollection*) _tmp25_);
	_tmp27_ = _tmp26_;
	_vala_assert (_tmp27_ == 1, "ro_list.size == 1");
	_tmp28_ = ro_list;
	_tmp29_ = gee_collection_contains ((GeeCollection*) _tmp28_, "one");
	_vala_assert (_tmp29_, "ro_list.contains (\"one\")");
	_tmp30_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp30_) {
		GeeList* _tmp31_ = NULL;
		gpointer _tmp32_ = NULL;
		gchar* _tmp33_ = NULL;
		_tmp31_ = ro_list;
		_tmp32_ = gee_list_remove_at (_tmp31_, 1);
		_tmp33_ = (gchar*) _tmp32_;
		_g_free0 (_tmp33_);
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp34_ = ro_list;
	_tmp35_ = gee_collection_get_size ((GeeCollection*) _tmp34_);
	_tmp36_ = _tmp35_;
	_vala_assert (_tmp36_ == 1, "ro_list.size == 1");
	_tmp37_ = ro_list;
	_tmp38_ = gee_collection_contains ((GeeCollection*) _tmp37_, "one");
	_vala_assert (_tmp38_, "ro_list.contains (\"one\")");
	_tmp39_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp39_) {
		GeeList* _tmp40_ = NULL;
		GeeCollection* _tmp41_ = NULL;
		_tmp40_ = ro_list;
		_tmp41_ = dummy;
		gee_list_insert_all (_tmp40_, 1, _tmp41_);
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp42_ = ro_list;
	_tmp43_ = gee_collection_get_size ((GeeCollection*) _tmp42_);
	_tmp44_ = _tmp43_;
	_vala_assert (_tmp44_ == 1, "ro_list.size == 1");
	_tmp45_ = ro_list;
	_tmp46_ = gee_collection_contains ((GeeCollection*) _tmp45_, "one");
	_vala_assert (_tmp46_, "ro_list.contains (\"one\")");
	_tmp47_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp47_) {
		GeeList* _tmp48_ = NULL;
		_tmp48_ = ro_list;
		gee_list_sort (_tmp48_, NULL, NULL, NULL);
		exit (0);
	}
	g_test_trap_assert_failed ();
	_tmp49_ = ro_list;
	_tmp50_ = gee_collection_get_size ((GeeCollection*) _tmp49_);
	_tmp51_ = _tmp50_;
	_vala_assert (_tmp51_ == 1, "ro_list.size == 1");
	_tmp52_ = ro_list;
	_tmp53_ = gee_collection_contains ((GeeCollection*) _tmp52_, "one");
	_vala_assert (_tmp53_, "ro_list.contains (\"one\")");
	_g_object_unref0 (dummy);
	_g_object_unref0 (ro_list);
	_g_object_unref0 (test_list);
}


void read_only_list_tests_test_accurate_view (ReadOnlyListTests* self) {
	GeeList* test_list = NULL;
	GeeCollection* _tmp0_ = NULL;
	GeeList* _tmp1_ = NULL;
	GeeList* ro_list = NULL;
	GeeCollection* _tmp2_ = NULL;
	GeeList* _tmp3_ = NULL;
	GeeCollection* dummy = NULL;
	GeeArrayList* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	GType _tmp7_ = 0UL;
	GType _tmp8_ = 0UL;
	gint _tmp9_ = 0;
	gint _tmp10_ = 0;
	gboolean _tmp11_ = FALSE;
	gboolean _tmp12_ = FALSE;
	gboolean _tmp13_ = FALSE;
	gint _tmp14_ = 0;
	gboolean _tmp15_ = FALSE;
	gint _tmp16_ = 0;
	gint _tmp17_ = 0;
	gboolean _tmp18_ = FALSE;
	gboolean _tmp19_ = FALSE;
	gpointer _tmp20_ = NULL;
	gchar* _tmp21_ = NULL;
	gint _tmp22_ = 0;
	gpointer _tmp23_ = NULL;
	gchar* _tmp24_ = NULL;
	gpointer _tmp25_ = NULL;
	gchar* _tmp26_ = NULL;
	gboolean _tmp27_ = FALSE;
	gint _tmp28_ = 0;
	gint _tmp29_ = 0;
	gboolean _tmp30_ = FALSE;
	gboolean _tmp31_ = FALSE;
	gpointer _tmp32_ = NULL;
	gchar* _tmp33_ = NULL;
	gint _tmp34_ = 0;
	gpointer _tmp35_ = NULL;
	gchar* _tmp36_ = NULL;
	gint _tmp37_ = 0;
	gpointer _tmp38_ = NULL;
	gchar* _tmp39_ = NULL;
	gpointer _tmp40_ = NULL;
	gchar* _tmp41_ = NULL;
	gboolean _tmp42_ = FALSE;
	gint _tmp43_ = 0;
	gint _tmp44_ = 0;
	gboolean _tmp45_ = FALSE;
	gboolean _tmp46_ = FALSE;
	gboolean _tmp47_ = FALSE;
	gint _tmp48_ = 0;
	gboolean _tmp49_ = FALSE;
	gpointer _tmp50_ = NULL;
	gchar* _tmp51_ = NULL;
	gint _tmp52_ = 0;
	gpointer _tmp53_ = NULL;
	gchar* _tmp54_ = NULL;
	gpointer _tmp55_ = NULL;
	gchar* _tmp56_ = NULL;
	gint _tmp57_ = 0;
	gint _tmp58_ = 0;
	gboolean _tmp59_ = FALSE;
	gboolean _tmp60_ = FALSE;
	gint _tmp61_ = 0;
	gint _tmp62_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = ((ReadOnlyCollectionTests*) self)->test_collection;
	_tmp1_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, GEE_TYPE_LIST) ? ((GeeList*) _tmp0_) : NULL);
	test_list = _tmp1_;
	_tmp2_ = ((ReadOnlyCollectionTests*) self)->ro_collection;
	_tmp3_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, GEE_TYPE_LIST) ? ((GeeList*) _tmp2_) : NULL);
	ro_list = _tmp3_;
	_tmp4_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	dummy = (GeeCollection*) _tmp4_;
	_tmp5_ = gee_collection_add (dummy, "one");
	_vala_assert (_tmp5_, "dummy.add (\"one\")");
	_tmp6_ = gee_collection_add (dummy, "two");
	_vala_assert (_tmp6_, "dummy.add (\"two\")");
	_tmp7_ = gee_traversable_get_element_type ((GeeTraversable*) ro_list);
	_tmp8_ = _tmp7_;
	_vala_assert (_tmp8_ == G_TYPE_STRING, "ro_list.element_type == typeof (string)");
	_tmp9_ = gee_collection_get_size ((GeeCollection*) ro_list);
	_tmp10_ = _tmp9_;
	_vala_assert (_tmp10_ == 0, "ro_list.size == 0");
	_tmp11_ = gee_collection_get_is_empty ((GeeCollection*) ro_list);
	_tmp12_ = _tmp11_;
	_vala_assert (_tmp12_, "ro_list.is_empty");
	_tmp13_ = gee_collection_contains ((GeeCollection*) ro_list, "one");
	_vala_assert (!_tmp13_, "! ro_list.contains (\"one\")");
	_tmp14_ = gee_list_index_of (ro_list, "one");
	_vala_assert (_tmp14_ == (-1), "ro_list.index_of (\"one\") == -1");
	_tmp15_ = gee_collection_add ((GeeCollection*) test_list, "one");
	_vala_assert (_tmp15_, "test_list.add (\"one\")");
	_tmp16_ = gee_collection_get_size ((GeeCollection*) ro_list);
	_tmp17_ = _tmp16_;
	_vala_assert (_tmp17_ == 1, "ro_list.size == 1");
	_tmp18_ = gee_collection_get_is_empty ((GeeCollection*) ro_list);
	_tmp19_ = _tmp18_;
	_vala_assert (!_tmp19_, "! ro_list.is_empty");
	_tmp20_ = gee_list_get (ro_list, 0);
	_tmp21_ = (gchar*) _tmp20_;
	_vala_assert (g_strcmp0 (_tmp21_, "one") == 0, "ro_list.get (0) == \"one\"");
	_g_free0 (_tmp21_);
	_tmp22_ = gee_list_index_of (ro_list, "one");
	_vala_assert (_tmp22_ == 0, "ro_list.index_of (\"one\") == 0");
	_tmp23_ = gee_list_first (ro_list);
	_tmp24_ = (gchar*) _tmp23_;
	_vala_assert (g_strcmp0 (_tmp24_, "one") == 0, "ro_list.first () == \"one\"");
	_g_free0 (_tmp24_);
	_tmp25_ = gee_list_last (ro_list);
	_tmp26_ = (gchar*) _tmp25_;
	_vala_assert (g_strcmp0 (_tmp26_, "one") == 0, "ro_list.last () == \"one\"");
	_g_free0 (_tmp26_);
	_tmp27_ = gee_collection_add ((GeeCollection*) test_list, "two");
	_vala_assert (_tmp27_, "test_list.add (\"two\")");
	_tmp28_ = gee_collection_get_size ((GeeCollection*) ro_list);
	_tmp29_ = _tmp28_;
	_vala_assert (_tmp29_ == 2, "ro_list.size == 2");
	_tmp30_ = gee_collection_get_is_empty ((GeeCollection*) ro_list);
	_tmp31_ = _tmp30_;
	_vala_assert (!_tmp31_, "! ro_list.is_empty");
	_tmp32_ = gee_list_get (ro_list, 0);
	_tmp33_ = (gchar*) _tmp32_;
	_vala_assert (g_strcmp0 (_tmp33_, "one") == 0, "ro_list.get (0) == \"one\"");
	_g_free0 (_tmp33_);
	_tmp34_ = gee_list_index_of (ro_list, "one");
	_vala_assert (_tmp34_ == 0, "ro_list.index_of (\"one\") == 0");
	_tmp35_ = gee_list_get (ro_list, 1);
	_tmp36_ = (gchar*) _tmp35_;
	_vala_assert (g_strcmp0 (_tmp36_, "two") == 0, "ro_list.get (1) == \"two\"");
	_g_free0 (_tmp36_);
	_tmp37_ = gee_list_index_of (ro_list, "two");
	_vala_assert (_tmp37_ == 1, "ro_list.index_of (\"two\") == 1");
	_tmp38_ = gee_list_first (ro_list);
	_tmp39_ = (gchar*) _tmp38_;
	_vala_assert (g_strcmp0 (_tmp39_, "one") == 0, "ro_list.first () == \"one\"");
	_g_free0 (_tmp39_);
	_tmp40_ = gee_list_last (ro_list);
	_tmp41_ = (gchar*) _tmp40_;
	_vala_assert (g_strcmp0 (_tmp41_, "two") == 0, "ro_list.last () == \"two\"");
	_g_free0 (_tmp41_);
	_tmp42_ = gee_collection_remove ((GeeCollection*) test_list, "one");
	_vala_assert (_tmp42_, "test_list.remove (\"one\")");
	_tmp43_ = gee_collection_get_size ((GeeCollection*) ro_list);
	_tmp44_ = _tmp43_;
	_vala_assert (_tmp44_ == 1, "ro_list.size == 1");
	_tmp45_ = gee_collection_get_is_empty ((GeeCollection*) ro_list);
	_tmp46_ = _tmp45_;
	_vala_assert (!_tmp46_, "! ro_list.is_empty");
	_tmp47_ = gee_collection_contains ((GeeCollection*) ro_list, "one");
	_vala_assert (!_tmp47_, "! ro_list.contains (\"one\")");
	_tmp48_ = gee_list_index_of (ro_list, "one");
	_vala_assert (_tmp48_ == (-1), "ro_list.index_of (\"one\") == -1");
	_tmp49_ = gee_collection_contains ((GeeCollection*) ro_list, "two");
	_vala_assert (_tmp49_, "ro_list.contains (\"two\")");
	_tmp50_ = gee_list_get (ro_list, 0);
	_tmp51_ = (gchar*) _tmp50_;
	_vala_assert (g_strcmp0 (_tmp51_, "two") == 0, "ro_list.get (0) == \"two\"");
	_g_free0 (_tmp51_);
	_tmp52_ = gee_list_index_of (ro_list, "two");
	_vala_assert (_tmp52_ == 0, "ro_list.index_of (\"two\") == 0");
	_tmp53_ = gee_list_first (ro_list);
	_tmp54_ = (gchar*) _tmp53_;
	_vala_assert (g_strcmp0 (_tmp54_, "two") == 0, "ro_list.first () == \"two\"");
	_g_free0 (_tmp54_);
	_tmp55_ = gee_list_last (ro_list);
	_tmp56_ = (gchar*) _tmp55_;
	_vala_assert (g_strcmp0 (_tmp56_, "two") == 0, "ro_list.last () == \"two\"");
	_g_free0 (_tmp56_);
	gee_collection_clear ((GeeCollection*) test_list);
	_tmp57_ = gee_collection_get_size ((GeeCollection*) ro_list);
	_tmp58_ = _tmp57_;
	_vala_assert (_tmp58_ == 0, "ro_list.size == 0");
	_tmp59_ = gee_collection_get_is_empty ((GeeCollection*) ro_list);
	_tmp60_ = _tmp59_;
	_vala_assert (_tmp60_, "ro_list.is_empty");
	_tmp61_ = gee_list_index_of (ro_list, "one");
	_vala_assert (_tmp61_ == (-1), "ro_list.index_of (\"one\") == -1");
	_tmp62_ = gee_list_index_of (ro_list, "two");
	_vala_assert (_tmp62_ == (-1), "ro_list.index_of (\"two\") == -1");
	_g_object_unref0 (dummy);
	_g_object_unref0 (ro_list);
	_g_object_unref0 (test_list);
}


static void read_only_list_tests_class_init (ReadOnlyListTestsClass * klass) {
	read_only_list_tests_parent_class = g_type_class_peek_parent (klass);
	GEE_TEST_CASE_CLASS (klass)->set_up = read_only_list_tests_real_set_up;
	GEE_TEST_CASE_CLASS (klass)->tear_down = read_only_list_tests_real_tear_down;
	READ_ONLY_COLLECTION_TESTS_CLASS (klass)->get_ro_view = read_only_list_tests_real_get_ro_view;
}


static void read_only_list_tests_instance_init (ReadOnlyListTests * self) {
}


GType read_only_list_tests_get_type (void) {
	static volatile gsize read_only_list_tests_type_id__volatile = 0;
	if (g_once_init_enter (&read_only_list_tests_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ReadOnlyListTestsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) read_only_list_tests_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ReadOnlyListTests), 0, (GInstanceInitFunc) read_only_list_tests_instance_init, NULL };
		GType read_only_list_tests_type_id;
		read_only_list_tests_type_id = g_type_register_static (TYPE_READ_ONLY_COLLECTION_TESTS, "ReadOnlyListTests", &g_define_type_info, 0);
		g_once_init_leave (&read_only_list_tests_type_id__volatile, read_only_list_tests_type_id);
	}
	return read_only_list_tests_type_id__volatile;
}



