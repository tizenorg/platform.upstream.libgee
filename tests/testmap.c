/* testmap.c generated by valac 0.18.0, the Vala compiler
 * generated from testmap.vala, do not modify */

/* testmap.vala
 *
 * Copyright (C) 2008  Jürg Billeter, Maciej Piechotka
 * Copyright (C) 2009  Didier Villevalois, Julien Peeters
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Jürg Billeter <j@bitron.ch>
 * 	Maciej Piechotka <uzytkownik2@gmail.com>
 * 	Julien Peeters <contact@julienpeeters.fr>
 */

#include <glib.h>
#include <glib-object.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>


#define GEE_TYPE_TEST_CASE (gee_test_case_get_type ())
#define GEE_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_TEST_CASE, GeeTestCase))
#define GEE_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_TEST_CASE, GeeTestCaseClass))
#define GEE_IS_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_TEST_CASE))
#define GEE_IS_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_TEST_CASE))
#define GEE_TEST_CASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_TEST_CASE, GeeTestCaseClass))

typedef struct _GeeTestCase GeeTestCase;
typedef struct _GeeTestCaseClass GeeTestCaseClass;
typedef struct _GeeTestCasePrivate GeeTestCasePrivate;

#define TYPE_MAP_TESTS (map_tests_get_type ())
#define MAP_TESTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAP_TESTS, MapTests))
#define MAP_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAP_TESTS, MapTestsClass))
#define IS_MAP_TESTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAP_TESTS))
#define IS_MAP_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAP_TESTS))
#define MAP_TESTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAP_TESTS, MapTestsClass))

typedef struct _MapTests MapTests;
typedef struct _MapTestsClass MapTestsClass;
typedef struct _MapTestsPrivate MapTestsPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define MAP_TESTS_TYPE_TEST_ENTRY (map_tests_test_entry_get_type ())
#define MAP_TESTS_TEST_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAP_TESTS_TYPE_TEST_ENTRY, MapTestsTestEntry))
#define MAP_TESTS_TEST_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MAP_TESTS_TYPE_TEST_ENTRY, MapTestsTestEntryClass))
#define MAP_TESTS_IS_TEST_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAP_TESTS_TYPE_TEST_ENTRY))
#define MAP_TESTS_IS_TEST_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAP_TESTS_TYPE_TEST_ENTRY))
#define MAP_TESTS_TEST_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MAP_TESTS_TYPE_TEST_ENTRY, MapTestsTestEntryClass))

typedef struct _MapTestsTestEntry MapTestsTestEntry;
typedef struct _MapTestsTestEntryClass MapTestsTestEntryClass;
typedef struct _MapTestsTestEntryPrivate MapTestsTestEntryPrivate;
#define _k_destroy_func0(var) (((var == NULL) || (k_destroy_func == NULL)) ? NULL : (var = (k_destroy_func (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _GeeTestCase {
	GObject parent_instance;
	GeeTestCasePrivate * priv;
};

struct _GeeTestCaseClass {
	GObjectClass parent_class;
	void (*set_up) (GeeTestCase* self);
	void (*tear_down) (GeeTestCase* self);
};

struct _MapTests {
	GeeTestCase parent_instance;
	MapTestsPrivate * priv;
	GeeMap* test_map;
};

struct _MapTestsClass {
	GeeTestCaseClass parent_class;
};

typedef void (*GeeTestCaseTestMethod) (void* user_data);
struct _MapTestsTestEntry {
	GeeMapEntry parent_instance;
	MapTestsTestEntryPrivate * priv;
};

struct _MapTestsTestEntryClass {
	GeeMapEntryClass parent_class;
};

struct _MapTestsTestEntryPrivate {
	GType k_type;
	GBoxedCopyFunc k_dup_func;
	GDestroyNotify k_destroy_func;
	GType v_type;
	GBoxedCopyFunc v_dup_func;
	GDestroyNotify v_destroy_func;
	gpointer _key;
	gpointer _value;
};


static gpointer map_tests_parent_class = NULL;
static gpointer map_tests_test_entry_parent_class = NULL;

GType gee_test_case_get_type (void) G_GNUC_CONST;
GType map_tests_get_type (void) G_GNUC_CONST;
enum  {
	MAP_TESTS_DUMMY_PROPERTY
};
MapTests* map_tests_construct (GType object_type, const gchar* name);
GeeTestCase* gee_test_case_construct (GType object_type, const gchar* name);
void gee_test_case_add_test (GeeTestCase* self, const gchar* name, GeeTestCaseTestMethod test, void* test_target);
void map_tests_test_type_correctness (MapTests* self);
static void _map_tests_test_type_correctness_gee_test_case_test_method (gpointer self);
void map_tests_test_has_key_size_is_empty (MapTests* self);
static void _map_tests_test_has_key_size_is_empty_gee_test_case_test_method (gpointer self);
void map_tests_test_keys (MapTests* self);
static void _map_tests_test_keys_gee_test_case_test_method (gpointer self);
void map_tests_test_values (MapTests* self);
static void _map_tests_test_values_gee_test_case_test_method (gpointer self);
void map_tests_test_entries (MapTests* self);
static void _map_tests_test_entries_gee_test_case_test_method (gpointer self);
void map_tests_test_set_all (MapTests* self);
static void _map_tests_test_set_all_gee_test_case_test_method (gpointer self);
void map_tests_test_unset_all (MapTests* self);
static void _map_tests_test_unset_all_gee_test_case_test_method (gpointer self);
void map_tests_test_has_all (MapTests* self);
static void _map_tests_test_has_all_gee_test_case_test_method (gpointer self);
void map_tests_test_gobject_properties (MapTests* self);
static void _map_tests_test_gobject_properties_gee_test_case_test_method (gpointer self);
MapTestsTestEntry* map_tests_test_entry_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, gconstpointer key, gconstpointer value);
MapTestsTestEntry* map_tests_test_entry_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, gconstpointer key, gconstpointer value);
GType map_tests_test_entry_get_type (void) G_GNUC_CONST;
void map_tests_test_clear (MapTests* self);
#define MAP_TESTS_TEST_ENTRY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), MAP_TESTS_TYPE_TEST_ENTRY, MapTestsTestEntryPrivate))
enum  {
	MAP_TESTS_TEST_ENTRY_DUMMY_PROPERTY,
	MAP_TESTS_TEST_ENTRY_K_TYPE,
	MAP_TESTS_TEST_ENTRY_K_DUP_FUNC,
	MAP_TESTS_TEST_ENTRY_K_DESTROY_FUNC,
	MAP_TESTS_TEST_ENTRY_V_TYPE,
	MAP_TESTS_TEST_ENTRY_V_DUP_FUNC,
	MAP_TESTS_TEST_ENTRY_V_DESTROY_FUNC,
	MAP_TESTS_TEST_ENTRY_KEY,
	MAP_TESTS_TEST_ENTRY_VALUE
};
static void map_tests_test_entry_finalize (GObject* obj);
static void _vala_map_tests_test_entry_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_map_tests_test_entry_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void map_tests_finalize (GObject* obj);


static void _map_tests_test_type_correctness_gee_test_case_test_method (gpointer self) {
	map_tests_test_type_correctness (self);
}


static void _map_tests_test_has_key_size_is_empty_gee_test_case_test_method (gpointer self) {
	map_tests_test_has_key_size_is_empty (self);
}


static void _map_tests_test_keys_gee_test_case_test_method (gpointer self) {
	map_tests_test_keys (self);
}


static void _map_tests_test_values_gee_test_case_test_method (gpointer self) {
	map_tests_test_values (self);
}


static void _map_tests_test_entries_gee_test_case_test_method (gpointer self) {
	map_tests_test_entries (self);
}


static void _map_tests_test_set_all_gee_test_case_test_method (gpointer self) {
	map_tests_test_set_all (self);
}


static void _map_tests_test_unset_all_gee_test_case_test_method (gpointer self) {
	map_tests_test_unset_all (self);
}


static void _map_tests_test_has_all_gee_test_case_test_method (gpointer self) {
	map_tests_test_has_all (self);
}


static void _map_tests_test_gobject_properties_gee_test_case_test_method (gpointer self) {
	map_tests_test_gobject_properties (self);
}


MapTests* map_tests_construct (GType object_type, const gchar* name) {
	MapTests * self = NULL;
	const gchar* _tmp0_;
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = name;
	self = (MapTests*) gee_test_case_construct (object_type, _tmp0_);
	gee_test_case_add_test ((GeeTestCase*) self, "[Map] type correctness", _map_tests_test_type_correctness_gee_test_case_test_method, self);
	gee_test_case_add_test ((GeeTestCase*) self, "[Map] has_key, size and is_empty", _map_tests_test_has_key_size_is_empty_gee_test_case_test_method, self);
	gee_test_case_add_test ((GeeTestCase*) self, "[Map] keys", _map_tests_test_keys_gee_test_case_test_method, self);
	gee_test_case_add_test ((GeeTestCase*) self, "[Map] values", _map_tests_test_values_gee_test_case_test_method, self);
	gee_test_case_add_test ((GeeTestCase*) self, "[Map] entries", _map_tests_test_entries_gee_test_case_test_method, self);
	gee_test_case_add_test ((GeeTestCase*) self, "[Map] set all", _map_tests_test_set_all_gee_test_case_test_method, self);
	gee_test_case_add_test ((GeeTestCase*) self, "[Map] unset all", _map_tests_test_unset_all_gee_test_case_test_method, self);
	gee_test_case_add_test ((GeeTestCase*) self, "[Map] has all", _map_tests_test_has_all_gee_test_case_test_method, self);
	gee_test_case_add_test ((GeeTestCase*) self, "[Map] GObject properties", _map_tests_test_gobject_properties_gee_test_case_test_method, self);
	return self;
}


void map_tests_test_type_correctness (MapTests* self) {
	GeeMap* _tmp0_;
	GeeMap* _tmp1_;
	GType _tmp2_;
	GType _tmp3_;
	GeeMap* _tmp4_;
	GType _tmp5_;
	GType _tmp6_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->test_map;
	_vala_assert (_tmp0_ != NULL, "test_map != null");
	_tmp1_ = self->test_map;
	_tmp2_ = gee_map_get_key_type (_tmp1_);
	_tmp3_ = _tmp2_;
	_vala_assert (_tmp3_ == G_TYPE_STRING, "test_map.key_type == typeof (string)");
	_tmp4_ = self->test_map;
	_tmp5_ = gee_map_get_value_type (_tmp4_);
	_tmp6_ = _tmp5_;
	_vala_assert (_tmp6_ == G_TYPE_STRING, "test_map.value_type == typeof (string)");
}


void map_tests_test_has_key_size_is_empty (MapTests* self) {
	GeeMap* _tmp0_;
	gchar* value = NULL;
	GeeMap* _tmp1_;
	gboolean _tmp2_ = FALSE;
	GeeMap* _tmp3_;
	gboolean _tmp4_ = FALSE;
	GeeMap* _tmp5_;
	gboolean _tmp6_ = FALSE;
	GeeMap* _tmp7_;
	gint _tmp8_;
	gint _tmp9_;
	GeeMap* _tmp10_;
	gboolean _tmp11_;
	gboolean _tmp12_;
	GeeMap* _tmp13_;
	GeeMap* _tmp14_;
	gboolean _tmp15_ = FALSE;
	GeeMap* _tmp16_;
	gboolean _tmp17_ = FALSE;
	GeeMap* _tmp18_;
	gboolean _tmp19_ = FALSE;
	GeeMap* _tmp20_;
	gpointer _tmp21_ = NULL;
	gchar* _tmp22_;
	GeeMap* _tmp23_;
	gboolean _tmp24_ = FALSE;
	GeeMap* _tmp25_;
	gpointer _tmp26_ = NULL;
	gchar* _tmp27_;
	GeeMap* _tmp28_;
	gboolean _tmp29_ = FALSE;
	GeeMap* _tmp30_;
	gpointer _tmp31_ = NULL;
	gchar* _tmp32_;
	GeeMap* _tmp33_;
	gint _tmp34_;
	gint _tmp35_;
	GeeMap* _tmp36_;
	gboolean _tmp37_;
	gboolean _tmp38_;
	GeeMap* _tmp39_;
	gboolean _tmp40_ = FALSE;
	GeeMap* _tmp41_;
	gboolean _tmp42_ = FALSE;
	GeeMap* _tmp43_;
	gboolean _tmp44_ = FALSE;
	GeeMap* _tmp45_;
	gboolean _tmp46_ = FALSE;
	GeeMap* _tmp47_;
	gpointer _tmp48_ = NULL;
	gchar* _tmp49_;
	GeeMap* _tmp50_;
	gboolean _tmp51_ = FALSE;
	GeeMap* _tmp52_;
	gpointer _tmp53_ = NULL;
	gchar* _tmp54_;
	GeeMap* _tmp55_;
	gboolean _tmp56_ = FALSE;
	GeeMap* _tmp57_;
	gpointer _tmp58_ = NULL;
	gchar* _tmp59_;
	GeeMap* _tmp60_;
	gint _tmp61_;
	gint _tmp62_;
	GeeMap* _tmp63_;
	gboolean _tmp64_;
	gboolean _tmp65_;
	GeeMap* _tmp66_;
	GeeMap* _tmp67_;
	gboolean _tmp68_ = FALSE;
	GeeMap* _tmp69_;
	gpointer _tmp70_ = NULL;
	gchar* _tmp71_;
	GeeMap* _tmp72_;
	gboolean _tmp73_ = FALSE;
	GeeMap* _tmp74_;
	gpointer _tmp75_ = NULL;
	gchar* _tmp76_;
	GeeMap* _tmp77_;
	gboolean _tmp78_ = FALSE;
	GeeMap* _tmp79_;
	gpointer _tmp80_ = NULL;
	gchar* _tmp81_;
	GeeMap* _tmp82_;
	gint _tmp83_;
	gint _tmp84_;
	GeeMap* _tmp85_;
	gboolean _tmp86_;
	gboolean _tmp87_;
	GeeMap* _tmp88_;
	GeeMap* _tmp89_;
	gboolean _tmp90_ = FALSE;
	GeeMap* _tmp91_;
	gpointer _tmp92_ = NULL;
	gchar* _tmp93_;
	GeeMap* _tmp94_;
	gboolean _tmp95_ = FALSE;
	GeeMap* _tmp96_;
	gpointer _tmp97_ = NULL;
	gchar* _tmp98_;
	GeeMap* _tmp99_;
	gboolean _tmp100_ = FALSE;
	GeeMap* _tmp101_;
	gpointer _tmp102_ = NULL;
	gchar* _tmp103_;
	GeeMap* _tmp104_;
	gint _tmp105_;
	gint _tmp106_;
	GeeMap* _tmp107_;
	gboolean _tmp108_;
	gboolean _tmp109_;
	GeeMap* _tmp110_;
	GeeMap* _tmp111_;
	gboolean _tmp112_ = FALSE;
	GeeMap* _tmp113_;
	gpointer _tmp114_ = NULL;
	gchar* _tmp115_;
	GeeMap* _tmp116_;
	gboolean _tmp117_ = FALSE;
	GeeMap* _tmp118_;
	gpointer _tmp119_ = NULL;
	gchar* _tmp120_;
	GeeMap* _tmp121_;
	gboolean _tmp122_ = FALSE;
	GeeMap* _tmp123_;
	gpointer _tmp124_ = NULL;
	gchar* _tmp125_;
	GeeMap* _tmp126_;
	gint _tmp127_;
	gint _tmp128_;
	GeeMap* _tmp129_;
	gboolean _tmp130_;
	gboolean _tmp131_;
	GeeMap* _tmp132_;
	GeeMap* _tmp133_;
	gboolean _tmp134_ = FALSE;
	GeeMap* _tmp135_;
	gpointer _tmp136_ = NULL;
	gchar* _tmp137_;
	GeeMap* _tmp138_;
	gboolean _tmp139_ = FALSE;
	GeeMap* _tmp140_;
	gpointer _tmp141_ = NULL;
	gchar* _tmp142_;
	GeeMap* _tmp143_;
	gboolean _tmp144_ = FALSE;
	GeeMap* _tmp145_;
	gpointer _tmp146_ = NULL;
	gchar* _tmp147_;
	GeeMap* _tmp148_;
	gint _tmp149_;
	gint _tmp150_;
	GeeMap* _tmp151_;
	gboolean _tmp152_;
	gboolean _tmp153_;
	GeeMap* _tmp154_;
	gpointer _tmp155_ = NULL;
	gboolean _tmp156_ = FALSE;
	const gchar* _tmp157_;
	GeeMap* _tmp158_;
	gboolean _tmp159_ = FALSE;
	GeeMap* _tmp160_;
	gpointer _tmp161_ = NULL;
	gchar* _tmp162_;
	GeeMap* _tmp163_;
	gboolean _tmp164_ = FALSE;
	GeeMap* _tmp165_;
	gpointer _tmp166_ = NULL;
	gchar* _tmp167_;
	GeeMap* _tmp168_;
	gboolean _tmp169_ = FALSE;
	GeeMap* _tmp170_;
	gpointer _tmp171_ = NULL;
	gchar* _tmp172_;
	GeeMap* _tmp173_;
	gint _tmp174_;
	gint _tmp175_;
	GeeMap* _tmp176_;
	gboolean _tmp177_;
	gboolean _tmp178_;
	GeeMap* _tmp179_;
	gpointer _tmp180_ = NULL;
	gboolean _tmp181_ = FALSE;
	const gchar* _tmp182_;
	GeeMap* _tmp183_;
	gboolean _tmp184_ = FALSE;
	GeeMap* _tmp185_;
	gboolean _tmp186_ = FALSE;
	GeeMap* _tmp187_;
	gboolean _tmp188_ = FALSE;
	GeeMap* _tmp189_;
	gint _tmp190_;
	gint _tmp191_;
	GeeMap* _tmp192_;
	gboolean _tmp193_;
	gboolean _tmp194_;
	GeeMap* _tmp195_;
	GeeMap* _tmp196_;
	gboolean _tmp197_ = FALSE;
	GeeMap* _tmp198_;
	gpointer _tmp199_ = NULL;
	gchar* _tmp200_;
	GeeMap* _tmp201_;
	gboolean _tmp202_ = FALSE;
	GeeMap* _tmp203_;
	gpointer _tmp204_ = NULL;
	gchar* _tmp205_;
	GeeMap* _tmp206_;
	gboolean _tmp207_ = FALSE;
	GeeMap* _tmp208_;
	gpointer _tmp209_ = NULL;
	gchar* _tmp210_;
	GeeMap* _tmp211_;
	gint _tmp212_;
	gint _tmp213_;
	GeeMap* _tmp214_;
	gboolean _tmp215_;
	gboolean _tmp216_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->test_map;
	_vala_assert (_tmp0_ != NULL, "test_map != null");
	_tmp1_ = self->test_map;
	_tmp2_ = gee_map_has_key (_tmp1_, "one");
	_vala_assert (!_tmp2_, "! test_map.has_key (\"one\")");
	_tmp3_ = self->test_map;
	_tmp4_ = gee_map_has_key (_tmp3_, "two");
	_vala_assert (!_tmp4_, "! test_map.has_key (\"two\")");
	_tmp5_ = self->test_map;
	_tmp6_ = gee_map_has_key (_tmp5_, "three");
	_vala_assert (!_tmp6_, "! test_map.has_key (\"three\")");
	_tmp7_ = self->test_map;
	_tmp8_ = gee_map_get_size (_tmp7_);
	_tmp9_ = _tmp8_;
	_vala_assert (_tmp9_ == 0, "test_map.size == 0");
	_tmp10_ = self->test_map;
	_tmp11_ = gee_map_get_is_empty (_tmp10_);
	_tmp12_ = _tmp11_;
	_vala_assert (_tmp12_, "test_map.is_empty");
	_tmp13_ = self->test_map;
	gee_map_set (_tmp13_, "one", "value_of_one");
	_tmp14_ = self->test_map;
	_tmp15_ = gee_map_has_key (_tmp14_, "one");
	_vala_assert (_tmp15_, "test_map.has_key (\"one\")");
	_tmp16_ = self->test_map;
	_tmp17_ = gee_map_has (_tmp16_, "one", "value_of_one");
	_vala_assert (_tmp17_, "test_map.has (\"one\", \"value_of_one\")");
	_tmp18_ = self->test_map;
	_tmp19_ = gee_map_has (_tmp18_, "one", "another_value_for_one");
	_vala_assert (!_tmp19_, "! test_map.has (\"one\", \"another_value_for_one\")");
	_tmp20_ = self->test_map;
	_tmp21_ = gee_map_get (_tmp20_, "one");
	_tmp22_ = (gchar*) _tmp21_;
	_vala_assert (g_strcmp0 (_tmp22_, "value_of_one") == 0, "test_map.get (\"one\") == \"value_of_one\"");
	_g_free0 (_tmp22_);
	_tmp23_ = self->test_map;
	_tmp24_ = gee_map_has_key (_tmp23_, "two");
	_vala_assert (!_tmp24_, "! test_map.has_key (\"two\")");
	_tmp25_ = self->test_map;
	_tmp26_ = gee_map_get (_tmp25_, "two");
	_tmp27_ = (gchar*) _tmp26_;
	_vala_assert (_tmp27_ == NULL, "test_map.get (\"two\") == null");
	_g_free0 (_tmp27_);
	_tmp28_ = self->test_map;
	_tmp29_ = gee_map_has_key (_tmp28_, "three");
	_vala_assert (!_tmp29_, "! test_map.has_key (\"three\")");
	_tmp30_ = self->test_map;
	_tmp31_ = gee_map_get (_tmp30_, "three");
	_tmp32_ = (gchar*) _tmp31_;
	_vala_assert (_tmp32_ == NULL, "test_map.get (\"three\") == null");
	_g_free0 (_tmp32_);
	_tmp33_ = self->test_map;
	_tmp34_ = gee_map_get_size (_tmp33_);
	_tmp35_ = _tmp34_;
	_vala_assert (_tmp35_ == 1, "test_map.size == 1");
	_tmp36_ = self->test_map;
	_tmp37_ = gee_map_get_is_empty (_tmp36_);
	_tmp38_ = _tmp37_;
	_vala_assert (!_tmp38_, "! test_map.is_empty");
	_tmp39_ = self->test_map;
	_tmp40_ = gee_map_unset (_tmp39_, "one", NULL);
	_vala_assert (_tmp40_, "test_map.unset (\"one\")");
	_tmp41_ = self->test_map;
	_tmp42_ = gee_map_has_key (_tmp41_, "one");
	_vala_assert (!_tmp42_, "! test_map.has_key (\"one\")");
	_tmp43_ = self->test_map;
	_tmp44_ = gee_map_has (_tmp43_, "one", "value_of_one");
	_vala_assert (!_tmp44_, "! test_map.has (\"one\", \"value_of_one\")");
	_tmp45_ = self->test_map;
	_tmp46_ = gee_map_has (_tmp45_, "one", "another_value_for_one");
	_vala_assert (!_tmp46_, "! test_map.has (\"one\", \"another_value_for_one\")");
	_tmp47_ = self->test_map;
	_tmp48_ = gee_map_get (_tmp47_, "one");
	_tmp49_ = (gchar*) _tmp48_;
	_vala_assert (_tmp49_ == NULL, "test_map.get (\"one\") == null");
	_g_free0 (_tmp49_);
	_tmp50_ = self->test_map;
	_tmp51_ = gee_map_has_key (_tmp50_, "two");
	_vala_assert (!_tmp51_, "! test_map.has_key (\"two\")");
	_tmp52_ = self->test_map;
	_tmp53_ = gee_map_get (_tmp52_, "two");
	_tmp54_ = (gchar*) _tmp53_;
	_vala_assert (_tmp54_ == NULL, "test_map.get (\"two\") ==  null");
	_g_free0 (_tmp54_);
	_tmp55_ = self->test_map;
	_tmp56_ = gee_map_has_key (_tmp55_, "three");
	_vala_assert (!_tmp56_, "! test_map.has_key (\"three\")");
	_tmp57_ = self->test_map;
	_tmp58_ = gee_map_get (_tmp57_, "three");
	_tmp59_ = (gchar*) _tmp58_;
	_vala_assert (_tmp59_ == NULL, "test_map.get (\"three\") == null");
	_g_free0 (_tmp59_);
	_tmp60_ = self->test_map;
	_tmp61_ = gee_map_get_size (_tmp60_);
	_tmp62_ = _tmp61_;
	_vala_assert (_tmp62_ == 0, "test_map.size == 0");
	_tmp63_ = self->test_map;
	_tmp64_ = gee_map_get_is_empty (_tmp63_);
	_tmp65_ = _tmp64_;
	_vala_assert (_tmp65_, "test_map.is_empty");
	_tmp66_ = self->test_map;
	gee_map_set (_tmp66_, "one", "value_of_one");
	_tmp67_ = self->test_map;
	_tmp68_ = gee_map_has_key (_tmp67_, "one");
	_vala_assert (_tmp68_, "test_map.has_key (\"one\")");
	_tmp69_ = self->test_map;
	_tmp70_ = gee_map_get (_tmp69_, "one");
	_tmp71_ = (gchar*) _tmp70_;
	_vala_assert (g_strcmp0 (_tmp71_, "value_of_one") == 0, "test_map.get (\"one\") == \"value_of_one\"");
	_g_free0 (_tmp71_);
	_tmp72_ = self->test_map;
	_tmp73_ = gee_map_has_key (_tmp72_, "two");
	_vala_assert (!_tmp73_, "! test_map.has_key (\"two\")");
	_tmp74_ = self->test_map;
	_tmp75_ = gee_map_get (_tmp74_, "two");
	_tmp76_ = (gchar*) _tmp75_;
	_vala_assert (_tmp76_ == NULL, "test_map.get (\"two\") == null");
	_g_free0 (_tmp76_);
	_tmp77_ = self->test_map;
	_tmp78_ = gee_map_has_key (_tmp77_, "three");
	_vala_assert (!_tmp78_, "! test_map.has_key (\"three\")");
	_tmp79_ = self->test_map;
	_tmp80_ = gee_map_get (_tmp79_, "three");
	_tmp81_ = (gchar*) _tmp80_;
	_vala_assert (_tmp81_ == NULL, "test_map.get (\"three\") == null");
	_g_free0 (_tmp81_);
	_tmp82_ = self->test_map;
	_tmp83_ = gee_map_get_size (_tmp82_);
	_tmp84_ = _tmp83_;
	_vala_assert (_tmp84_ == 1, "test_map.size == 1");
	_tmp85_ = self->test_map;
	_tmp86_ = gee_map_get_is_empty (_tmp85_);
	_tmp87_ = _tmp86_;
	_vala_assert (!_tmp87_, "! test_map.is_empty");
	_tmp88_ = self->test_map;
	gee_map_set (_tmp88_, "two", "value_of_two");
	_tmp89_ = self->test_map;
	_tmp90_ = gee_map_has_key (_tmp89_, "one");
	_vala_assert (_tmp90_, "test_map.has_key (\"one\")");
	_tmp91_ = self->test_map;
	_tmp92_ = gee_map_get (_tmp91_, "one");
	_tmp93_ = (gchar*) _tmp92_;
	_vala_assert (g_strcmp0 (_tmp93_, "value_of_one") == 0, "test_map.get (\"one\") == \"value_of_one\"");
	_g_free0 (_tmp93_);
	_tmp94_ = self->test_map;
	_tmp95_ = gee_map_has_key (_tmp94_, "two");
	_vala_assert (_tmp95_, "test_map.has_key (\"two\")");
	_tmp96_ = self->test_map;
	_tmp97_ = gee_map_get (_tmp96_, "two");
	_tmp98_ = (gchar*) _tmp97_;
	_vala_assert (g_strcmp0 (_tmp98_, "value_of_two") == 0, "test_map.get (\"two\") == \"value_of_two\"");
	_g_free0 (_tmp98_);
	_tmp99_ = self->test_map;
	_tmp100_ = gee_map_has_key (_tmp99_, "three");
	_vala_assert (!_tmp100_, "! test_map.has_key (\"three\")");
	_tmp101_ = self->test_map;
	_tmp102_ = gee_map_get (_tmp101_, "three");
	_tmp103_ = (gchar*) _tmp102_;
	_vala_assert (_tmp103_ == NULL, "test_map.get (\"three\") == null");
	_g_free0 (_tmp103_);
	_tmp104_ = self->test_map;
	_tmp105_ = gee_map_get_size (_tmp104_);
	_tmp106_ = _tmp105_;
	_vala_assert (_tmp106_ == 2, "test_map.size == 2");
	_tmp107_ = self->test_map;
	_tmp108_ = gee_map_get_is_empty (_tmp107_);
	_tmp109_ = _tmp108_;
	_vala_assert (!_tmp109_, "! test_map.is_empty");
	_tmp110_ = self->test_map;
	gee_map_set (_tmp110_, "three", "value_of_three");
	_tmp111_ = self->test_map;
	_tmp112_ = gee_map_has_key (_tmp111_, "one");
	_vala_assert (_tmp112_, "test_map.has_key (\"one\")");
	_tmp113_ = self->test_map;
	_tmp114_ = gee_map_get (_tmp113_, "one");
	_tmp115_ = (gchar*) _tmp114_;
	_vala_assert (g_strcmp0 (_tmp115_, "value_of_one") == 0, "test_map.get (\"one\") == \"value_of_one\"");
	_g_free0 (_tmp115_);
	_tmp116_ = self->test_map;
	_tmp117_ = gee_map_has_key (_tmp116_, "two");
	_vala_assert (_tmp117_, "test_map.has_key (\"two\")");
	_tmp118_ = self->test_map;
	_tmp119_ = gee_map_get (_tmp118_, "two");
	_tmp120_ = (gchar*) _tmp119_;
	_vala_assert (g_strcmp0 (_tmp120_, "value_of_two") == 0, "test_map.get (\"two\") == \"value_of_two\"");
	_g_free0 (_tmp120_);
	_tmp121_ = self->test_map;
	_tmp122_ = gee_map_has_key (_tmp121_, "three");
	_vala_assert (_tmp122_, "test_map.has_key (\"three\")");
	_tmp123_ = self->test_map;
	_tmp124_ = gee_map_get (_tmp123_, "three");
	_tmp125_ = (gchar*) _tmp124_;
	_vala_assert (g_strcmp0 (_tmp125_, "value_of_three") == 0, "test_map.get (\"three\") == \"value_of_three\"");
	_g_free0 (_tmp125_);
	_tmp126_ = self->test_map;
	_tmp127_ = gee_map_get_size (_tmp126_);
	_tmp128_ = _tmp127_;
	_vala_assert (_tmp128_ == 3, "test_map.size == 3");
	_tmp129_ = self->test_map;
	_tmp130_ = gee_map_get_is_empty (_tmp129_);
	_tmp131_ = _tmp130_;
	_vala_assert (!_tmp131_, "! test_map.is_empty");
	_tmp132_ = self->test_map;
	gee_map_set (_tmp132_, "two", "value_of_two_new");
	_tmp133_ = self->test_map;
	_tmp134_ = gee_map_has_key (_tmp133_, "one");
	_vala_assert (_tmp134_, "test_map.has_key (\"one\")");
	_tmp135_ = self->test_map;
	_tmp136_ = gee_map_get (_tmp135_, "one");
	_tmp137_ = (gchar*) _tmp136_;
	_vala_assert (g_strcmp0 (_tmp137_, "value_of_one") == 0, "test_map.get (\"one\") == \"value_of_one\"");
	_g_free0 (_tmp137_);
	_tmp138_ = self->test_map;
	_tmp139_ = gee_map_has_key (_tmp138_, "two");
	_vala_assert (_tmp139_, "test_map.has_key (\"two\")");
	_tmp140_ = self->test_map;
	_tmp141_ = gee_map_get (_tmp140_, "two");
	_tmp142_ = (gchar*) _tmp141_;
	_vala_assert (g_strcmp0 (_tmp142_, "value_of_two_new") == 0, "test_map.get (\"two\") == \"value_of_two_new\"");
	_g_free0 (_tmp142_);
	_tmp143_ = self->test_map;
	_tmp144_ = gee_map_has_key (_tmp143_, "three");
	_vala_assert (_tmp144_, "test_map.has_key (\"three\")");
	_tmp145_ = self->test_map;
	_tmp146_ = gee_map_get (_tmp145_, "three");
	_tmp147_ = (gchar*) _tmp146_;
	_vala_assert (g_strcmp0 (_tmp147_, "value_of_three") == 0, "test_map.get (\"three\") == \"value_of_three\"");
	_g_free0 (_tmp147_);
	_tmp148_ = self->test_map;
	_tmp149_ = gee_map_get_size (_tmp148_);
	_tmp150_ = _tmp149_;
	_vala_assert (_tmp150_ == 3, "test_map.size == 3");
	_tmp151_ = self->test_map;
	_tmp152_ = gee_map_get_is_empty (_tmp151_);
	_tmp153_ = _tmp152_;
	_vala_assert (!_tmp153_, "! test_map.is_empty");
	_tmp154_ = self->test_map;
	_tmp156_ = gee_map_unset (_tmp154_, "two", &_tmp155_);
	_g_free0 (value);
	value = _tmp155_;
	_vala_assert (_tmp156_, "test_map.unset (\"two\", out value)");
	_tmp157_ = value;
	_vala_assert (g_strcmp0 (_tmp157_, "value_of_two_new") == 0, "value == \"value_of_two_new\"");
	_tmp158_ = self->test_map;
	_tmp159_ = gee_map_has_key (_tmp158_, "one");
	_vala_assert (_tmp159_, "test_map.has_key (\"one\")");
	_tmp160_ = self->test_map;
	_tmp161_ = gee_map_get (_tmp160_, "one");
	_tmp162_ = (gchar*) _tmp161_;
	_vala_assert (g_strcmp0 (_tmp162_, "value_of_one") == 0, "test_map.get (\"one\") == \"value_of_one\"");
	_g_free0 (_tmp162_);
	_tmp163_ = self->test_map;
	_tmp164_ = gee_map_has_key (_tmp163_, "two");
	_vala_assert (!_tmp164_, "! test_map.has_key (\"two\")");
	_tmp165_ = self->test_map;
	_tmp166_ = gee_map_get (_tmp165_, "two");
	_tmp167_ = (gchar*) _tmp166_;
	_vala_assert (_tmp167_ == NULL, "test_map.get (\"two\") == null");
	_g_free0 (_tmp167_);
	_tmp168_ = self->test_map;
	_tmp169_ = gee_map_has_key (_tmp168_, "three");
	_vala_assert (_tmp169_, "test_map.has_key (\"three\")");
	_tmp170_ = self->test_map;
	_tmp171_ = gee_map_get (_tmp170_, "three");
	_tmp172_ = (gchar*) _tmp171_;
	_vala_assert (g_strcmp0 (_tmp172_, "value_of_three") == 0, "test_map.get (\"three\") == \"value_of_three\"");
	_g_free0 (_tmp172_);
	_tmp173_ = self->test_map;
	_tmp174_ = gee_map_get_size (_tmp173_);
	_tmp175_ = _tmp174_;
	_vala_assert (_tmp175_ == 2, "test_map.size == 2");
	_tmp176_ = self->test_map;
	_tmp177_ = gee_map_get_is_empty (_tmp176_);
	_tmp178_ = _tmp177_;
	_vala_assert (!_tmp178_, "! test_map.is_empty");
	_tmp179_ = self->test_map;
	_tmp181_ = gee_map_unset (_tmp179_, "two", &_tmp180_);
	_g_free0 (value);
	value = _tmp180_;
	_vala_assert (!_tmp181_, "! test_map.unset (\"two\", out value)");
	_tmp182_ = value;
	_vala_assert (_tmp182_ == NULL, "value == null");
	_tmp183_ = self->test_map;
	_tmp184_ = gee_map_has_key (_tmp183_, "one");
	_vala_assert (_tmp184_, "test_map.has_key (\"one\")");
	_tmp185_ = self->test_map;
	_tmp186_ = gee_map_has_key (_tmp185_, "two");
	_vala_assert (!_tmp186_, "! test_map.has_key (\"two\")");
	_tmp187_ = self->test_map;
	_tmp188_ = gee_map_has_key (_tmp187_, "three");
	_vala_assert (_tmp188_, "test_map.has_key (\"three\")");
	_tmp189_ = self->test_map;
	_tmp190_ = gee_map_get_size (_tmp189_);
	_tmp191_ = _tmp190_;
	_vala_assert (_tmp191_ == 2, "test_map.size == 2");
	_tmp192_ = self->test_map;
	_tmp193_ = gee_map_get_is_empty (_tmp192_);
	_tmp194_ = _tmp193_;
	_vala_assert (!_tmp194_, "! test_map.is_empty");
	_tmp195_ = self->test_map;
	gee_map_clear (_tmp195_);
	_tmp196_ = self->test_map;
	_tmp197_ = gee_map_has_key (_tmp196_, "one");
	_vala_assert (!_tmp197_, "! test_map.has_key (\"one\")");
	_tmp198_ = self->test_map;
	_tmp199_ = gee_map_get (_tmp198_, "one");
	_tmp200_ = (gchar*) _tmp199_;
	_vala_assert (_tmp200_ == NULL, "test_map.get (\"one\") == null");
	_g_free0 (_tmp200_);
	_tmp201_ = self->test_map;
	_tmp202_ = gee_map_has_key (_tmp201_, "two");
	_vala_assert (!_tmp202_, "! test_map.has_key (\"two\")");
	_tmp203_ = self->test_map;
	_tmp204_ = gee_map_get (_tmp203_, "two");
	_tmp205_ = (gchar*) _tmp204_;
	_vala_assert (_tmp205_ == NULL, "test_map.get (\"two\") == null");
	_g_free0 (_tmp205_);
	_tmp206_ = self->test_map;
	_tmp207_ = gee_map_has_key (_tmp206_, "three");
	_vala_assert (!_tmp207_, "! test_map.has_key (\"three\")");
	_tmp208_ = self->test_map;
	_tmp209_ = gee_map_get (_tmp208_, "three");
	_tmp210_ = (gchar*) _tmp209_;
	_vala_assert (_tmp210_ == NULL, "test_map.get (\"three\") == null");
	_g_free0 (_tmp210_);
	_tmp211_ = self->test_map;
	_tmp212_ = gee_map_get_size (_tmp211_);
	_tmp213_ = _tmp212_;
	_vala_assert (_tmp213_ == 0, "test_map.size == 0");
	_tmp214_ = self->test_map;
	_tmp215_ = gee_map_get_is_empty (_tmp214_);
	_tmp216_ = _tmp215_;
	_vala_assert (_tmp216_, "test_map.is_empty");
	_g_free0 (value);
}


void map_tests_test_keys (MapTests* self) {
	GeeMap* _tmp0_;
	GeeSet* _tmp1_;
	GeeSet* _tmp2_;
	GeeSet* keys;
	GeeSet* _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	GeeMap* _tmp6_;
	GeeSet* _tmp7_;
	gint _tmp8_;
	gint _tmp9_;
	GeeSet* _tmp10_;
	gboolean _tmp11_ = FALSE;
	GeeMap* _tmp12_;
	GeeSet* _tmp13_;
	GeeSet* _tmp14_;
	GeeSet* _tmp15_;
	gint _tmp16_;
	gint _tmp17_;
	GeeSet* _tmp18_;
	gboolean _tmp19_ = FALSE;
	gboolean _tmp20_ = FALSE;
	GeeMap* _tmp23_;
	GeeSet* _tmp24_;
	gint _tmp25_;
	gint _tmp26_;
	GeeSet* _tmp27_;
	gboolean _tmp28_ = FALSE;
	GeeSet* _tmp29_;
	gboolean _tmp30_ = FALSE;
	GeeMap* _tmp31_;
	GeeSet* _tmp32_;
	GeeSet* _tmp33_;
	GeeSet* _tmp34_;
	gint _tmp35_;
	gint _tmp36_;
	GeeSet* _tmp37_;
	gboolean _tmp38_ = FALSE;
	GeeSet* _tmp39_;
	gboolean _tmp40_ = FALSE;
	GeeMap* _tmp41_;
	GeeSet* _tmp42_;
	gint _tmp43_;
	gint _tmp44_;
	GeeMap* _tmp45_;
	GeeSet* _tmp46_;
	GeeSet* _tmp47_;
	GeeSet* _tmp48_;
	gint _tmp49_;
	gint _tmp50_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->test_map;
	_tmp1_ = gee_map_get_keys (_tmp0_);
	_tmp2_ = _tmp1_;
	keys = _tmp2_;
	_tmp3_ = keys;
	_tmp4_ = gee_collection_get_size ((GeeCollection*) _tmp3_);
	_tmp5_ = _tmp4_;
	_vala_assert (_tmp5_ == 0, "keys.size == 0");
	_tmp6_ = self->test_map;
	gee_map_set (_tmp6_, "one", "value_of_one");
	_tmp7_ = keys;
	_tmp8_ = gee_collection_get_size ((GeeCollection*) _tmp7_);
	_tmp9_ = _tmp8_;
	_vala_assert (_tmp9_ == 1, "keys.size == 1");
	_tmp10_ = keys;
	_tmp11_ = gee_collection_contains ((GeeCollection*) _tmp10_, "one");
	_vala_assert (_tmp11_, "keys.contains (\"one\")");
	_tmp12_ = self->test_map;
	_tmp13_ = gee_map_get_keys (_tmp12_);
	_tmp14_ = _tmp13_;
	_g_object_unref0 (keys);
	keys = _tmp14_;
	_tmp15_ = keys;
	_tmp16_ = gee_collection_get_size ((GeeCollection*) _tmp15_);
	_tmp17_ = _tmp16_;
	_vala_assert (_tmp17_ == 1, "keys.size == 1");
	_tmp18_ = keys;
	_tmp19_ = gee_collection_contains ((GeeCollection*) _tmp18_, "one");
	_vala_assert (_tmp19_, "keys.contains (\"one\")");
	_tmp20_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp20_) {
		GeeSet* _tmp21_;
		gboolean _tmp22_ = FALSE;
		_tmp21_ = keys;
		_tmp22_ = gee_collection_add ((GeeCollection*) _tmp21_, "three");
		_vala_assert (!_tmp22_, "! keys.add (\"three\")");
		exit (0);
	}
	g_test_trap_assert_failed ();
	g_test_trap_assert_stderr ("*code should not be reached*");
	_tmp23_ = self->test_map;
	gee_map_set (_tmp23_, "two", "value_of_two");
	_tmp24_ = keys;
	_tmp25_ = gee_collection_get_size ((GeeCollection*) _tmp24_);
	_tmp26_ = _tmp25_;
	_vala_assert (_tmp26_ == 2, "keys.size == 2");
	_tmp27_ = keys;
	_tmp28_ = gee_collection_contains ((GeeCollection*) _tmp27_, "one");
	_vala_assert (_tmp28_, "keys.contains (\"one\")");
	_tmp29_ = keys;
	_tmp30_ = gee_collection_contains ((GeeCollection*) _tmp29_, "two");
	_vala_assert (_tmp30_, "keys.contains (\"two\")");
	_tmp31_ = self->test_map;
	_tmp32_ = gee_map_get_keys (_tmp31_);
	_tmp33_ = _tmp32_;
	_g_object_unref0 (keys);
	keys = _tmp33_;
	_tmp34_ = keys;
	_tmp35_ = gee_collection_get_size ((GeeCollection*) _tmp34_);
	_tmp36_ = _tmp35_;
	_vala_assert (_tmp36_ == 2, "keys.size == 2");
	_tmp37_ = keys;
	_tmp38_ = gee_collection_contains ((GeeCollection*) _tmp37_, "one");
	_vala_assert (_tmp38_, "keys.contains (\"one\")");
	_tmp39_ = keys;
	_tmp40_ = gee_collection_contains ((GeeCollection*) _tmp39_, "two");
	_vala_assert (_tmp40_, "keys.contains (\"two\")");
	_tmp41_ = self->test_map;
	gee_map_clear (_tmp41_);
	_tmp42_ = keys;
	_tmp43_ = gee_collection_get_size ((GeeCollection*) _tmp42_);
	_tmp44_ = _tmp43_;
	_vala_assert (_tmp44_ == 0, "keys.size == 0");
	_tmp45_ = self->test_map;
	_tmp46_ = gee_map_get_keys (_tmp45_);
	_tmp47_ = _tmp46_;
	_g_object_unref0 (keys);
	keys = _tmp47_;
	_tmp48_ = keys;
	_tmp49_ = gee_collection_get_size ((GeeCollection*) _tmp48_);
	_tmp50_ = _tmp49_;
	_vala_assert (_tmp50_ == 0, "keys.size == 0");
	_g_object_unref0 (keys);
}


void map_tests_test_values (MapTests* self) {
	GeeMap* _tmp0_;
	GeeCollection* _tmp1_;
	GeeCollection* _tmp2_;
	GeeCollection* values;
	GeeCollection* _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	GeeMap* _tmp6_;
	GeeCollection* _tmp7_;
	gint _tmp8_;
	gint _tmp9_;
	GeeCollection* _tmp10_;
	gboolean _tmp11_ = FALSE;
	GeeMap* _tmp12_;
	GeeCollection* _tmp13_;
	GeeCollection* _tmp14_;
	GeeCollection* _tmp15_;
	gint _tmp16_;
	gint _tmp17_;
	GeeCollection* _tmp18_;
	gboolean _tmp19_ = FALSE;
	gboolean _tmp20_ = FALSE;
	GeeMap* _tmp23_;
	GeeCollection* _tmp24_;
	gint _tmp25_;
	gint _tmp26_;
	GeeCollection* _tmp27_;
	gboolean _tmp28_ = FALSE;
	GeeCollection* _tmp29_;
	gboolean _tmp30_ = FALSE;
	GeeMap* _tmp31_;
	GeeCollection* _tmp32_;
	GeeCollection* _tmp33_;
	GeeCollection* _tmp34_;
	gint _tmp35_;
	gint _tmp36_;
	GeeCollection* _tmp37_;
	gboolean _tmp38_ = FALSE;
	GeeCollection* _tmp39_;
	gboolean _tmp40_ = FALSE;
	GeeMap* _tmp41_;
	GeeCollection* _tmp42_;
	gint _tmp43_;
	gint _tmp44_;
	GeeMap* _tmp45_;
	GeeCollection* _tmp46_;
	GeeCollection* _tmp47_;
	GeeCollection* _tmp48_;
	gint _tmp49_;
	gint _tmp50_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->test_map;
	_tmp1_ = gee_map_get_values (_tmp0_);
	_tmp2_ = _tmp1_;
	values = _tmp2_;
	_tmp3_ = values;
	_tmp4_ = gee_collection_get_size (_tmp3_);
	_tmp5_ = _tmp4_;
	_vala_assert (_tmp5_ == 0, "values.size == 0");
	_tmp6_ = self->test_map;
	gee_map_set (_tmp6_, "one", "value_of_one");
	_tmp7_ = values;
	_tmp8_ = gee_collection_get_size (_tmp7_);
	_tmp9_ = _tmp8_;
	_vala_assert (_tmp9_ == 1, "values.size == 1");
	_tmp10_ = values;
	_tmp11_ = gee_collection_contains (_tmp10_, "value_of_one");
	_vala_assert (_tmp11_, "values.contains (\"value_of_one\")");
	_tmp12_ = self->test_map;
	_tmp13_ = gee_map_get_values (_tmp12_);
	_tmp14_ = _tmp13_;
	_g_object_unref0 (values);
	values = _tmp14_;
	_tmp15_ = values;
	_tmp16_ = gee_collection_get_size (_tmp15_);
	_tmp17_ = _tmp16_;
	_vala_assert (_tmp17_ == 1, "values.size == 1");
	_tmp18_ = values;
	_tmp19_ = gee_collection_contains (_tmp18_, "value_of_one");
	_vala_assert (_tmp19_, "values.contains (\"value_of_one\")");
	_tmp20_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp20_) {
		GeeCollection* _tmp21_;
		gboolean _tmp22_ = FALSE;
		_tmp21_ = values;
		_tmp22_ = gee_collection_add (_tmp21_, "two");
		_vala_assert (!_tmp22_, "! values.add (\"two\")");
		exit (0);
	}
	g_test_trap_assert_failed ();
	g_test_trap_assert_stderr ("*code should not be reached*");
	_tmp23_ = self->test_map;
	gee_map_set (_tmp23_, "two", "value_of_two");
	_tmp24_ = values;
	_tmp25_ = gee_collection_get_size (_tmp24_);
	_tmp26_ = _tmp25_;
	_vala_assert (_tmp26_ == 2, "values.size == 2");
	_tmp27_ = values;
	_tmp28_ = gee_collection_contains (_tmp27_, "value_of_one");
	_vala_assert (_tmp28_, "values.contains (\"value_of_one\")");
	_tmp29_ = values;
	_tmp30_ = gee_collection_contains (_tmp29_, "value_of_two");
	_vala_assert (_tmp30_, "values.contains (\"value_of_two\")");
	_tmp31_ = self->test_map;
	_tmp32_ = gee_map_get_values (_tmp31_);
	_tmp33_ = _tmp32_;
	_g_object_unref0 (values);
	values = _tmp33_;
	_tmp34_ = values;
	_tmp35_ = gee_collection_get_size (_tmp34_);
	_tmp36_ = _tmp35_;
	_vala_assert (_tmp36_ == 2, "values.size == 2");
	_tmp37_ = values;
	_tmp38_ = gee_collection_contains (_tmp37_, "value_of_one");
	_vala_assert (_tmp38_, "values.contains (\"value_of_one\")");
	_tmp39_ = values;
	_tmp40_ = gee_collection_contains (_tmp39_, "value_of_two");
	_vala_assert (_tmp40_, "values.contains (\"value_of_two\")");
	_tmp41_ = self->test_map;
	gee_map_clear (_tmp41_);
	_tmp42_ = values;
	_tmp43_ = gee_collection_get_size (_tmp42_);
	_tmp44_ = _tmp43_;
	_vala_assert (_tmp44_ == 0, "values.size == 0");
	_tmp45_ = self->test_map;
	_tmp46_ = gee_map_get_values (_tmp45_);
	_tmp47_ = _tmp46_;
	_g_object_unref0 (values);
	values = _tmp47_;
	_tmp48_ = values;
	_tmp49_ = gee_collection_get_size (_tmp48_);
	_tmp50_ = _tmp49_;
	_vala_assert (_tmp50_ == 0, "values.size == 0");
	_g_object_unref0 (values);
}


void map_tests_test_entries (MapTests* self) {
	GeeMap* _tmp0_;
	GeeSet* _tmp1_;
	GeeSet* _tmp2_;
	GeeSet* entries;
	GeeSet* _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	GeeMap* _tmp6_;
	GeeSet* _tmp7_;
	gint _tmp8_;
	gint _tmp9_;
	GeeSet* _tmp10_;
	MapTestsTestEntry* _tmp11_;
	MapTestsTestEntry* _tmp12_;
	gboolean _tmp13_ = FALSE;
	GeeMap* _tmp14_;
	GeeSet* _tmp15_;
	GeeSet* _tmp16_;
	GeeSet* _tmp17_;
	gint _tmp18_;
	gint _tmp19_;
	GeeSet* _tmp20_;
	MapTestsTestEntry* _tmp21_;
	MapTestsTestEntry* _tmp22_;
	gboolean _tmp23_ = FALSE;
	gboolean _tmp24_ = FALSE;
	GeeMap* _tmp29_;
	GeeSet* _tmp30_;
	gint _tmp31_;
	gint _tmp32_;
	GeeSet* _tmp33_;
	MapTestsTestEntry* _tmp34_;
	MapTestsTestEntry* _tmp35_;
	gboolean _tmp36_ = FALSE;
	GeeSet* _tmp37_;
	MapTestsTestEntry* _tmp38_;
	MapTestsTestEntry* _tmp39_;
	gboolean _tmp40_ = FALSE;
	GeeMap* _tmp41_;
	GeeSet* _tmp42_;
	GeeSet* _tmp43_;
	GeeSet* _tmp44_;
	gint _tmp45_;
	gint _tmp46_;
	GeeSet* _tmp47_;
	MapTestsTestEntry* _tmp48_;
	MapTestsTestEntry* _tmp49_;
	gboolean _tmp50_ = FALSE;
	GeeSet* _tmp51_;
	MapTestsTestEntry* _tmp52_;
	MapTestsTestEntry* _tmp53_;
	gboolean _tmp54_ = FALSE;
	GeeMap* _tmp55_;
	GeeSet* _tmp56_;
	gint _tmp57_;
	gint _tmp58_;
	GeeMap* _tmp59_;
	GeeSet* _tmp60_;
	GeeSet* _tmp61_;
	GeeSet* _tmp62_;
	gint _tmp63_;
	gint _tmp64_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->test_map;
	_tmp1_ = gee_map_get_entries (_tmp0_);
	_tmp2_ = _tmp1_;
	entries = _tmp2_;
	_tmp3_ = entries;
	_tmp4_ = gee_collection_get_size ((GeeCollection*) _tmp3_);
	_tmp5_ = _tmp4_;
	_vala_assert (_tmp5_ == 0, "entries.size == 0");
	_tmp6_ = self->test_map;
	gee_map_set (_tmp6_, "one", "value_of_one");
	_tmp7_ = entries;
	_tmp8_ = gee_collection_get_size ((GeeCollection*) _tmp7_);
	_tmp9_ = _tmp8_;
	_vala_assert (_tmp9_ == 1, "entries.size == 1");
	_tmp10_ = entries;
	_tmp11_ = map_tests_test_entry_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "one", "value_of_one");
	_tmp12_ = _tmp11_;
	_tmp13_ = gee_collection_contains ((GeeCollection*) _tmp10_, (GeeMapEntry*) _tmp12_);
	_vala_assert (_tmp13_, "entries.contains (new TestEntry<string,string> (\"one\", \"value_of_one\"))");
	_g_object_unref0 (_tmp12_);
	_tmp14_ = self->test_map;
	_tmp15_ = gee_map_get_entries (_tmp14_);
	_tmp16_ = _tmp15_;
	_g_object_unref0 (entries);
	entries = _tmp16_;
	_tmp17_ = entries;
	_tmp18_ = gee_collection_get_size ((GeeCollection*) _tmp17_);
	_tmp19_ = _tmp18_;
	_vala_assert (_tmp19_ == 1, "entries.size == 1");
	_tmp20_ = entries;
	_tmp21_ = map_tests_test_entry_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "one", "value_of_one");
	_tmp22_ = _tmp21_;
	_tmp23_ = gee_collection_contains ((GeeCollection*) _tmp20_, (GeeMapEntry*) _tmp22_);
	_vala_assert (_tmp23_, "entries.contains (new TestEntry<string,string> (\"one\", \"value_of_one\"))");
	_g_object_unref0 (_tmp22_);
	_tmp24_ = g_test_trap_fork ((guint64) 0, G_TEST_TRAP_SILENCE_STDOUT | G_TEST_TRAP_SILENCE_STDERR);
	if (_tmp24_) {
		GeeSet* _tmp25_;
		MapTestsTestEntry* _tmp26_;
		MapTestsTestEntry* _tmp27_;
		gboolean _tmp28_ = FALSE;
		_tmp25_ = entries;
		_tmp26_ = map_tests_test_entry_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "two", "value_of_two");
		_tmp27_ = _tmp26_;
		_tmp28_ = gee_collection_add ((GeeCollection*) _tmp25_, (GeeMapEntry*) _tmp27_);
		_vala_assert (!_tmp28_, "! entries.add (new TestEntry<string,string> (\"two\", \"value_of_two\"))");
		_g_object_unref0 (_tmp27_);
		exit (0);
	}
	g_test_trap_assert_failed ();
	g_test_trap_assert_stderr ("*code should not be reached*");
	_tmp29_ = self->test_map;
	gee_map_set (_tmp29_, "two", "value_of_two");
	_tmp30_ = entries;
	_tmp31_ = gee_collection_get_size ((GeeCollection*) _tmp30_);
	_tmp32_ = _tmp31_;
	_vala_assert (_tmp32_ == 2, "entries.size == 2");
	_tmp33_ = entries;
	_tmp34_ = map_tests_test_entry_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "one", "value_of_one");
	_tmp35_ = _tmp34_;
	_tmp36_ = gee_collection_contains ((GeeCollection*) _tmp33_, (GeeMapEntry*) _tmp35_);
	_vala_assert (_tmp36_, "entries.contains (new TestEntry<string,string> (\"one\", \"value_of_one\"))");
	_g_object_unref0 (_tmp35_);
	_tmp37_ = entries;
	_tmp38_ = map_tests_test_entry_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "two", "value_of_two");
	_tmp39_ = _tmp38_;
	_tmp40_ = gee_collection_contains ((GeeCollection*) _tmp37_, (GeeMapEntry*) _tmp39_);
	_vala_assert (_tmp40_, "entries.contains (new TestEntry<string,string> (\"two\", \"value_of_two\"))");
	_g_object_unref0 (_tmp39_);
	_tmp41_ = self->test_map;
	_tmp42_ = gee_map_get_entries (_tmp41_);
	_tmp43_ = _tmp42_;
	_g_object_unref0 (entries);
	entries = _tmp43_;
	_tmp44_ = entries;
	_tmp45_ = gee_collection_get_size ((GeeCollection*) _tmp44_);
	_tmp46_ = _tmp45_;
	_vala_assert (_tmp46_ == 2, "entries.size == 2");
	_tmp47_ = entries;
	_tmp48_ = map_tests_test_entry_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "one", "value_of_one");
	_tmp49_ = _tmp48_;
	_tmp50_ = gee_collection_contains ((GeeCollection*) _tmp47_, (GeeMapEntry*) _tmp49_);
	_vala_assert (_tmp50_, "entries.contains (new TestEntry<string,string> (\"one\", \"value_of_one\"))");
	_g_object_unref0 (_tmp49_);
	_tmp51_ = entries;
	_tmp52_ = map_tests_test_entry_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, "two", "value_of_two");
	_tmp53_ = _tmp52_;
	_tmp54_ = gee_collection_contains ((GeeCollection*) _tmp51_, (GeeMapEntry*) _tmp53_);
	_vala_assert (_tmp54_, "entries.contains (new TestEntry<string,string> (\"two\", \"value_of_two\"))");
	_g_object_unref0 (_tmp53_);
	_tmp55_ = self->test_map;
	gee_map_clear (_tmp55_);
	_tmp56_ = entries;
	_tmp57_ = gee_collection_get_size ((GeeCollection*) _tmp56_);
	_tmp58_ = _tmp57_;
	_vala_assert (_tmp58_ == 0, "entries.size == 0");
	_tmp59_ = self->test_map;
	_tmp60_ = gee_map_get_entries (_tmp59_);
	_tmp61_ = _tmp60_;
	_g_object_unref0 (entries);
	entries = _tmp61_;
	_tmp62_ = entries;
	_tmp63_ = gee_collection_get_size ((GeeCollection*) _tmp62_);
	_tmp64_ = _tmp63_;
	_vala_assert (_tmp64_ == 0, "entries.size == 0");
	_g_object_unref0 (entries);
}


void map_tests_test_clear (MapTests* self) {
	GeeMap* _tmp0_;
	GeeMap* _tmp1_;
	GeeMap* _tmp2_;
	GeeMap* _tmp3_;
	GeeMap* _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	GeeMap* _tmp7_;
	GeeSet* _tmp8_;
	GeeSet* _tmp9_;
	GeeSet* keys;
	GeeIterator* _tmp10_ = NULL;
	GeeIterator* ikeys;
	gboolean _tmp11_ = FALSE;
	GeeMap* _tmp12_;
	GeeCollection* _tmp13_;
	GeeCollection* _tmp14_;
	GeeCollection* vals;
	GeeIterator* _tmp15_ = NULL;
	GeeIterator* ivals;
	gboolean _tmp16_ = FALSE;
	GeeMap* _tmp17_;
	GeeSet* _tmp18_;
	GeeSet* _tmp19_;
	GeeSet* ents;
	GeeIterator* _tmp20_ = NULL;
	GeeIterator* ients;
	gboolean _tmp21_ = FALSE;
	GeeMap* _tmp22_;
	GeeMapIterator* _tmp23_ = NULL;
	GeeMapIterator* iter;
	gboolean _tmp24_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->test_map;
	gee_map_set (_tmp0_, "one", "value_of_one");
	_tmp1_ = self->test_map;
	gee_map_set (_tmp1_, "two", "value_of_two");
	_tmp2_ = self->test_map;
	gee_map_set (_tmp2_, "three", "value_of_three");
	_tmp3_ = self->test_map;
	gee_map_clear (_tmp3_);
	_tmp4_ = self->test_map;
	_tmp5_ = gee_map_get_size (_tmp4_);
	_tmp6_ = _tmp5_;
	_vala_assert (_tmp6_ == 0, "test_map.size == 0");
	_tmp7_ = self->test_map;
	_tmp8_ = gee_map_get_keys (_tmp7_);
	_tmp9_ = _tmp8_;
	keys = _tmp9_;
	_vala_assert (keys != NULL, "keys != null");
	_tmp10_ = gee_iterable_iterator ((GeeIterable*) keys);
	ikeys = _tmp10_;
	_vala_assert (ikeys != NULL, "ikeys != null");
	_tmp11_ = gee_iterator_has_next (ikeys);
	_vala_assert (!_tmp11_, "!ikeys.has_next ()");
	_tmp12_ = self->test_map;
	_tmp13_ = gee_map_get_values (_tmp12_);
	_tmp14_ = _tmp13_;
	vals = _tmp14_;
	_vala_assert (vals != NULL, "vals != null");
	_tmp15_ = gee_iterable_iterator ((GeeIterable*) vals);
	ivals = _tmp15_;
	_vala_assert (ivals != NULL, "ivals != null");
	_tmp16_ = gee_iterator_has_next (ivals);
	_vala_assert (!_tmp16_, "!ivals.has_next ()");
	_tmp17_ = self->test_map;
	_tmp18_ = gee_map_get_entries (_tmp17_);
	_tmp19_ = _tmp18_;
	ents = _tmp19_;
	_vala_assert (ents != NULL, "ents != null");
	_tmp20_ = gee_iterable_iterator ((GeeIterable*) ents);
	ients = _tmp20_;
	_vala_assert (ients != NULL, "ients != null");
	_tmp21_ = gee_iterator_has_next (ients);
	_vala_assert (!_tmp21_, "!ients.has_next ()");
	_tmp22_ = self->test_map;
	_tmp23_ = gee_map_map_iterator (_tmp22_);
	iter = _tmp23_;
	_vala_assert (iter != NULL, "iter != null");
	_tmp24_ = gee_map_iterator_has_next (iter);
	_vala_assert (!_tmp24_, "!iter.has_next ()");
	_g_object_unref0 (iter);
	_g_object_unref0 (ients);
	_g_object_unref0 (ents);
	_g_object_unref0 (ivals);
	_g_object_unref0 (vals);
	_g_object_unref0 (ikeys);
	_g_object_unref0 (keys);
}


void map_tests_test_set_all (MapTests* self) {
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GEqualFunc _tmp2_;
	GeeHashMap* _tmp3_;
	GeeHashMap* another_map;
	GeeMap* _tmp4_;
	GeeMap* _tmp5_;
	GeeMap* _tmp6_;
	GeeMap* _tmp7_;
	GeeMap* _tmp8_;
	gint _tmp9_;
	gint _tmp10_;
	GeeMap* _tmp11_;
	gboolean _tmp12_ = FALSE;
	GeeMap* _tmp13_;
	gboolean _tmp14_ = FALSE;
	GeeMap* _tmp15_;
	gboolean _tmp16_ = FALSE;
	GeeMap* _tmp17_;
	gboolean _tmp18_ = FALSE;
	GeeMap* _tmp19_;
	gboolean _tmp20_ = FALSE;
	GeeMap* _tmp21_;
	gboolean _tmp22_ = FALSE;
	GeeMap* _tmp23_;
	gpointer _tmp24_ = NULL;
	gchar* _tmp25_;
	GeeMap* _tmp26_;
	gpointer _tmp27_ = NULL;
	gchar* _tmp28_;
	GeeMap* _tmp29_;
	gpointer _tmp30_ = NULL;
	gchar* _tmp31_;
	GeeMap* _tmp32_;
	gpointer _tmp33_ = NULL;
	gchar* _tmp34_;
	GeeMap* _tmp35_;
	gpointer _tmp36_ = NULL;
	gchar* _tmp37_;
	GeeMap* _tmp38_;
	gpointer _tmp39_ = NULL;
	gchar* _tmp40_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_str_equal;
	_tmp3_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, _tmp0_, _tmp1_, _tmp2_);
	another_map = _tmp3_;
	_tmp4_ = self->test_map;
	gee_map_set (_tmp4_, "one", "value_of_one");
	_tmp5_ = self->test_map;
	gee_map_set (_tmp5_, "two", "value_of_two");
	_tmp6_ = self->test_map;
	gee_map_set (_tmp6_, "three", "value_of_three");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "four", "value_of_four");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "five", "value_of_five");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "six", "value_of_six");
	_tmp7_ = self->test_map;
	gee_map_set_all (_tmp7_, (GeeMap*) another_map);
	_tmp8_ = self->test_map;
	_tmp9_ = gee_map_get_size (_tmp8_);
	_tmp10_ = _tmp9_;
	_vala_assert (_tmp10_ == 6, "test_map.size == 6");
	_tmp11_ = self->test_map;
	_tmp12_ = gee_map_has_key (_tmp11_, "one");
	_vala_assert (_tmp12_, "test_map.has_key (\"one\")");
	_tmp13_ = self->test_map;
	_tmp14_ = gee_map_has_key (_tmp13_, "two");
	_vala_assert (_tmp14_, "test_map.has_key (\"two\")");
	_tmp15_ = self->test_map;
	_tmp16_ = gee_map_has_key (_tmp15_, "three");
	_vala_assert (_tmp16_, "test_map.has_key (\"three\")");
	_tmp17_ = self->test_map;
	_tmp18_ = gee_map_has_key (_tmp17_, "four");
	_vala_assert (_tmp18_, "test_map.has_key (\"four\")");
	_tmp19_ = self->test_map;
	_tmp20_ = gee_map_has_key (_tmp19_, "five");
	_vala_assert (_tmp20_, "test_map.has_key (\"five\")");
	_tmp21_ = self->test_map;
	_tmp22_ = gee_map_has_key (_tmp21_, "six");
	_vala_assert (_tmp22_, "test_map.has_key (\"six\")");
	_tmp23_ = self->test_map;
	_tmp24_ = gee_map_get (_tmp23_, "one");
	_tmp25_ = (gchar*) _tmp24_;
	_vala_assert (g_strcmp0 (_tmp25_, "value_of_one") == 0, "test_map.get (\"one\") == \"value_of_one\"");
	_g_free0 (_tmp25_);
	_tmp26_ = self->test_map;
	_tmp27_ = gee_map_get (_tmp26_, "two");
	_tmp28_ = (gchar*) _tmp27_;
	_vala_assert (g_strcmp0 (_tmp28_, "value_of_two") == 0, "test_map.get (\"two\") == \"value_of_two\"");
	_g_free0 (_tmp28_);
	_tmp29_ = self->test_map;
	_tmp30_ = gee_map_get (_tmp29_, "three");
	_tmp31_ = (gchar*) _tmp30_;
	_vala_assert (g_strcmp0 (_tmp31_, "value_of_three") == 0, "test_map.get (\"three\") == \"value_of_three\"");
	_g_free0 (_tmp31_);
	_tmp32_ = self->test_map;
	_tmp33_ = gee_map_get (_tmp32_, "four");
	_tmp34_ = (gchar*) _tmp33_;
	_vala_assert (g_strcmp0 (_tmp34_, "value_of_four") == 0, "test_map.get (\"four\") == \"value_of_four\"");
	_g_free0 (_tmp34_);
	_tmp35_ = self->test_map;
	_tmp36_ = gee_map_get (_tmp35_, "five");
	_tmp37_ = (gchar*) _tmp36_;
	_vala_assert (g_strcmp0 (_tmp37_, "value_of_five") == 0, "test_map.get (\"five\") == \"value_of_five\"");
	_g_free0 (_tmp37_);
	_tmp38_ = self->test_map;
	_tmp39_ = gee_map_get (_tmp38_, "six");
	_tmp40_ = (gchar*) _tmp39_;
	_vala_assert (g_strcmp0 (_tmp40_, "value_of_six") == 0, "test_map.get (\"six\") == \"value_of_six\"");
	_g_free0 (_tmp40_);
	_g_object_unref0 (another_map);
}


void map_tests_test_unset_all (MapTests* self) {
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GEqualFunc _tmp2_;
	GeeHashMap* _tmp3_;
	GeeHashMap* another_map;
	GeeMap* _tmp4_;
	gboolean _tmp5_;
	gboolean _tmp6_;
	gboolean _tmp7_;
	gboolean _tmp8_;
	GeeMap* _tmp9_;
	gboolean _tmp10_ = FALSE;
	GeeMap* _tmp11_;
	gboolean _tmp12_;
	gboolean _tmp13_;
	gboolean _tmp14_;
	gboolean _tmp15_;
	GeeMap* _tmp16_;
	GeeMap* _tmp17_;
	gboolean _tmp18_;
	gboolean _tmp19_;
	gint _tmp20_;
	gint _tmp21_;
	GeeMap* _tmp22_;
	gboolean _tmp23_ = FALSE;
	GeeMap* _tmp24_;
	gboolean _tmp25_;
	gboolean _tmp26_;
	gint _tmp27_;
	gint _tmp28_;
	GeeMap* _tmp29_;
	GeeMap* _tmp30_;
	GeeMap* _tmp31_;
	GeeMap* _tmp32_;
	gint _tmp33_;
	gint _tmp34_;
	gboolean _tmp35_;
	gboolean _tmp36_;
	GeeMap* _tmp37_;
	gboolean _tmp38_ = FALSE;
	GeeMap* _tmp39_;
	gint _tmp40_;
	gint _tmp41_;
	gboolean _tmp42_;
	gboolean _tmp43_;
	GeeMap* _tmp44_;
	GeeMap* _tmp45_;
	GeeMap* _tmp46_;
	GeeMap* _tmp47_;
	gint _tmp48_;
	gint _tmp49_;
	gint _tmp50_;
	gint _tmp51_;
	GeeMap* _tmp52_;
	gboolean _tmp53_ = FALSE;
	GeeMap* _tmp54_;
	gboolean _tmp55_;
	gboolean _tmp56_;
	gint _tmp57_;
	gint _tmp58_;
	GeeMap* _tmp59_;
	GeeMap* _tmp60_;
	GeeMap* _tmp61_;
	GeeMap* _tmp62_;
	GeeMap* _tmp63_;
	gint _tmp64_;
	gint _tmp65_;
	gint _tmp66_;
	gint _tmp67_;
	GeeMap* _tmp68_;
	gboolean _tmp69_ = FALSE;
	GeeMap* _tmp70_;
	gint _tmp71_;
	gint _tmp72_;
	gint _tmp73_;
	gint _tmp74_;
	GeeMap* _tmp75_;
	gboolean _tmp76_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_str_equal;
	_tmp3_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, _tmp0_, _tmp1_, _tmp2_);
	another_map = _tmp3_;
	_tmp4_ = self->test_map;
	_tmp5_ = gee_map_get_is_empty (_tmp4_);
	_tmp6_ = _tmp5_;
	_vala_assert (_tmp6_, "test_map.is_empty");
	_tmp7_ = gee_abstract_map_get_is_empty ((GeeAbstractMap*) another_map);
	_tmp8_ = _tmp7_;
	_vala_assert (_tmp8_, "another_map.is_empty");
	_tmp9_ = self->test_map;
	_tmp10_ = gee_map_unset_all (_tmp9_, (GeeMap*) another_map);
	_vala_assert (!_tmp10_, "! test_map.unset_all (another_map)");
	_tmp11_ = self->test_map;
	_tmp12_ = gee_map_get_is_empty (_tmp11_);
	_tmp13_ = _tmp12_;
	_vala_assert (_tmp13_, "test_map.is_empty");
	_tmp14_ = gee_abstract_map_get_is_empty ((GeeAbstractMap*) another_map);
	_tmp15_ = _tmp14_;
	_vala_assert (_tmp15_, "another_map.is_empty");
	_tmp16_ = self->test_map;
	gee_map_clear (_tmp16_);
	gee_abstract_map_clear ((GeeAbstractMap*) another_map);
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "one", "value_of_one");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "two", "value_of_two");
	_tmp17_ = self->test_map;
	_tmp18_ = gee_map_get_is_empty (_tmp17_);
	_tmp19_ = _tmp18_;
	_vala_assert (_tmp19_, "test_map.is_empty");
	_tmp20_ = gee_abstract_map_get_size ((GeeMap*) another_map);
	_tmp21_ = _tmp20_;
	_vala_assert (_tmp21_ == 2, "another_map.size == 2");
	_tmp22_ = self->test_map;
	_tmp23_ = gee_map_unset_all (_tmp22_, (GeeMap*) another_map);
	_vala_assert (!_tmp23_, "! test_map.unset_all (another_map)");
	_tmp24_ = self->test_map;
	_tmp25_ = gee_map_get_is_empty (_tmp24_);
	_tmp26_ = _tmp25_;
	_vala_assert (_tmp26_, "test_map.is_empty");
	_tmp27_ = gee_abstract_map_get_size ((GeeMap*) another_map);
	_tmp28_ = _tmp27_;
	_vala_assert (_tmp28_ == 2, "another_map.size == 2");
	_tmp29_ = self->test_map;
	gee_map_clear (_tmp29_);
	gee_abstract_map_clear ((GeeAbstractMap*) another_map);
	_tmp30_ = self->test_map;
	gee_map_set (_tmp30_, "one", "value_of_one");
	_tmp31_ = self->test_map;
	gee_map_set (_tmp31_, "two", "value_of_two");
	_tmp32_ = self->test_map;
	_tmp33_ = gee_map_get_size (_tmp32_);
	_tmp34_ = _tmp33_;
	_vala_assert (_tmp34_ == 2, "test_map.size == 2");
	_tmp35_ = gee_abstract_map_get_is_empty ((GeeAbstractMap*) another_map);
	_tmp36_ = _tmp35_;
	_vala_assert (_tmp36_, "another_map.is_empty");
	_tmp37_ = self->test_map;
	_tmp38_ = gee_map_unset_all (_tmp37_, (GeeMap*) another_map);
	_vala_assert (!_tmp38_, "! test_map.unset_all (another_map)");
	_tmp39_ = self->test_map;
	_tmp40_ = gee_map_get_size (_tmp39_);
	_tmp41_ = _tmp40_;
	_vala_assert (_tmp41_ == 2, "test_map.size == 2");
	_tmp42_ = gee_abstract_map_get_is_empty ((GeeAbstractMap*) another_map);
	_tmp43_ = _tmp42_;
	_vala_assert (_tmp43_, "another_map.is_empty");
	_tmp44_ = self->test_map;
	gee_map_clear (_tmp44_);
	gee_abstract_map_clear ((GeeAbstractMap*) another_map);
	_tmp45_ = self->test_map;
	gee_map_set (_tmp45_, "one", "value_of_one");
	_tmp46_ = self->test_map;
	gee_map_set (_tmp46_, "two", "value_of_two");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "one", "value_of_one");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "two", "value_of_two");
	_tmp47_ = self->test_map;
	_tmp48_ = gee_map_get_size (_tmp47_);
	_tmp49_ = _tmp48_;
	_vala_assert (_tmp49_ == 2, "test_map.size == 2");
	_tmp50_ = gee_abstract_map_get_size ((GeeMap*) another_map);
	_tmp51_ = _tmp50_;
	_vala_assert (_tmp51_ == 2, "another_map.size == 2");
	_tmp52_ = self->test_map;
	_tmp53_ = gee_map_unset_all (_tmp52_, (GeeMap*) another_map);
	_vala_assert (_tmp53_, "test_map.unset_all (another_map)");
	_tmp54_ = self->test_map;
	_tmp55_ = gee_map_get_is_empty (_tmp54_);
	_tmp56_ = _tmp55_;
	_vala_assert (_tmp56_, "test_map.is_empty");
	_tmp57_ = gee_abstract_map_get_size ((GeeMap*) another_map);
	_tmp58_ = _tmp57_;
	_vala_assert (_tmp58_ == 2, "another_map.size == 2");
	_tmp59_ = self->test_map;
	gee_map_clear (_tmp59_);
	gee_abstract_map_clear ((GeeAbstractMap*) another_map);
	_tmp60_ = self->test_map;
	gee_map_set (_tmp60_, "one", "value_of_one");
	_tmp61_ = self->test_map;
	gee_map_set (_tmp61_, "two", "value_of_two");
	_tmp62_ = self->test_map;
	gee_map_set (_tmp62_, "three", "value_of_three");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "two", "value_of_two");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "three", "value_of_three");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "four", "value_of_four");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "five", "value_of_five");
	_tmp63_ = self->test_map;
	_tmp64_ = gee_map_get_size (_tmp63_);
	_tmp65_ = _tmp64_;
	_vala_assert (_tmp65_ == 3, "test_map.size == 3");
	_tmp66_ = gee_abstract_map_get_size ((GeeMap*) another_map);
	_tmp67_ = _tmp66_;
	_vala_assert (_tmp67_ == 4, "another_map.size == 4");
	_tmp68_ = self->test_map;
	_tmp69_ = gee_map_unset_all (_tmp68_, (GeeMap*) another_map);
	_vala_assert (_tmp69_, "test_map.unset_all (another_map)");
	_tmp70_ = self->test_map;
	_tmp71_ = gee_map_get_size (_tmp70_);
	_tmp72_ = _tmp71_;
	_vala_assert (_tmp72_ == 1, "test_map.size == 1");
	_tmp73_ = gee_abstract_map_get_size ((GeeMap*) another_map);
	_tmp74_ = _tmp73_;
	_vala_assert (_tmp74_ == 4, "another_map.size == 4");
	_tmp75_ = self->test_map;
	_tmp76_ = gee_map_has_key (_tmp75_, "one");
	_vala_assert (_tmp76_, "test_map.has_key (\"one\")");
	_g_object_unref0 (another_map);
}


void map_tests_test_has_all (MapTests* self) {
	GHashFunc _tmp0_;
	GEqualFunc _tmp1_;
	GEqualFunc _tmp2_;
	GeeHashMap* _tmp3_;
	GeeHashMap* another_map;
	GeeMap* _tmp4_;
	gboolean _tmp5_ = FALSE;
	GeeMap* _tmp6_;
	GeeMap* _tmp7_;
	gboolean _tmp8_ = FALSE;
	GeeMap* _tmp9_;
	GeeMap* _tmp10_;
	gboolean _tmp11_ = FALSE;
	GeeMap* _tmp12_;
	GeeMap* _tmp13_;
	GeeMap* _tmp14_;
	GeeMap* _tmp15_;
	gboolean _tmp16_ = FALSE;
	GeeMap* _tmp17_;
	GeeMap* _tmp18_;
	GeeMap* _tmp19_;
	GeeMap* _tmp20_;
	gboolean _tmp21_ = FALSE;
	GeeMap* _tmp22_;
	GeeMap* _tmp23_;
	GeeMap* _tmp24_;
	gboolean _tmp25_ = FALSE;
	GeeMap* _tmp26_;
	GeeMap* _tmp27_;
	GeeMap* _tmp28_;
	GeeMap* _tmp29_;
	GeeMap* _tmp30_;
	GeeMap* _tmp31_;
	GeeMap* _tmp32_;
	GeeMap* _tmp33_;
	gboolean _tmp34_ = FALSE;
	GeeMap* _tmp35_;
	GeeMap* _tmp36_;
	GeeMap* _tmp37_;
	GeeMap* _tmp38_;
	GeeMap* _tmp39_;
	GeeMap* _tmp40_;
	GeeMap* _tmp41_;
	GeeMap* _tmp42_;
	gboolean _tmp43_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_str_equal;
	_tmp3_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, _tmp0_, _tmp1_, _tmp2_);
	another_map = _tmp3_;
	_tmp4_ = self->test_map;
	_tmp5_ = gee_map_has_all (_tmp4_, (GeeMap*) another_map);
	_vala_assert (_tmp5_, "test_map.has_all (another_map)");
	_tmp6_ = self->test_map;
	gee_map_set (_tmp6_, "one", "value_of_one");
	_tmp7_ = self->test_map;
	_tmp8_ = gee_map_has_all (_tmp7_, (GeeMap*) another_map);
	_vala_assert (_tmp8_, "test_map.has_all (another_map)");
	_tmp9_ = self->test_map;
	gee_map_clear (_tmp9_);
	gee_abstract_map_clear ((GeeAbstractMap*) another_map);
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "one", "value_of_one");
	_tmp10_ = self->test_map;
	_tmp11_ = gee_map_has_all (_tmp10_, (GeeMap*) another_map);
	_vala_assert (!_tmp11_, "! test_map.has_all (another_map)");
	_tmp12_ = self->test_map;
	gee_map_clear (_tmp12_);
	gee_abstract_map_clear ((GeeAbstractMap*) another_map);
	_tmp13_ = self->test_map;
	gee_map_set (_tmp13_, "one", "value_of_one");
	_tmp14_ = self->test_map;
	gee_map_set (_tmp14_, "two", "value_of_two");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "one", "value_of_one");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "two", "value_of_two");
	_tmp15_ = self->test_map;
	_tmp16_ = gee_map_has_all (_tmp15_, (GeeMap*) another_map);
	_vala_assert (_tmp16_, "test_map.has_all (another_map)");
	_tmp17_ = self->test_map;
	gee_map_clear (_tmp17_);
	gee_abstract_map_clear ((GeeAbstractMap*) another_map);
	_tmp18_ = self->test_map;
	gee_map_set (_tmp18_, "one", "value_of_one");
	_tmp19_ = self->test_map;
	gee_map_set (_tmp19_, "two", "value_of_two");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "one", "another_value_of_one");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "two", "another_value_of_two");
	_tmp20_ = self->test_map;
	_tmp21_ = gee_map_has_all (_tmp20_, (GeeMap*) another_map);
	_vala_assert (!_tmp21_, "! test_map.has_all (another_map)");
	_tmp22_ = self->test_map;
	gee_map_clear (_tmp22_);
	gee_abstract_map_clear ((GeeAbstractMap*) another_map);
	_tmp23_ = self->test_map;
	gee_map_set (_tmp23_, "one", "value_of_one");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "two", "value_of_two");
	_tmp24_ = self->test_map;
	_tmp25_ = gee_map_has_all (_tmp24_, (GeeMap*) another_map);
	_vala_assert (!_tmp25_, "! test_map.has_all (another_map)");
	_tmp26_ = self->test_map;
	gee_map_clear (_tmp26_);
	gee_abstract_map_clear ((GeeAbstractMap*) another_map);
	_tmp27_ = self->test_map;
	gee_map_set (_tmp27_, "one", "value_of_one");
	_tmp28_ = self->test_map;
	gee_map_set (_tmp28_, "two", "value_of_two");
	_tmp29_ = self->test_map;
	gee_map_set (_tmp29_, "three", "value_of_three");
	_tmp30_ = self->test_map;
	gee_map_set (_tmp30_, "four", "value_of_four");
	_tmp31_ = self->test_map;
	gee_map_set (_tmp31_, "five", "value_of_five");
	_tmp32_ = self->test_map;
	gee_map_set (_tmp32_, "six", "value_of_six");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "two", "value_of_two");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "three", "value_of_three");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "four", "value_of_four");
	_tmp33_ = self->test_map;
	_tmp34_ = gee_map_has_all (_tmp33_, (GeeMap*) another_map);
	_vala_assert (_tmp34_, "test_map.has_all (another_map)");
	_tmp35_ = self->test_map;
	gee_map_clear (_tmp35_);
	gee_abstract_map_clear ((GeeAbstractMap*) another_map);
	_tmp36_ = self->test_map;
	gee_map_set (_tmp36_, "one", "value_of_one");
	_tmp37_ = self->test_map;
	gee_map_set (_tmp37_, "two", "value_of_two");
	_tmp38_ = self->test_map;
	gee_map_set (_tmp38_, "three", "value_of_three");
	_tmp39_ = self->test_map;
	gee_map_set (_tmp39_, "four", "value_of_four");
	_tmp40_ = self->test_map;
	gee_map_set (_tmp40_, "five", "value_of_five");
	_tmp41_ = self->test_map;
	gee_map_set (_tmp41_, "six", "value_of_six");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "two", "value_of_two");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "three", "value_of_three");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "four", "value_of_four");
	gee_abstract_map_set ((GeeAbstractMap*) another_map, "height", "value_of_height");
	_tmp42_ = self->test_map;
	_tmp43_ = gee_map_has_all (_tmp42_, (GeeMap*) another_map);
	_vala_assert (!_tmp43_, "! test_map.has_all (another_map)");
	_g_object_unref0 (another_map);
}


void map_tests_test_gobject_properties (MapTests* self) {
	GeeMap* _tmp0_;
	GValue value = {0};
	GValue _tmp1_ = {0};
	GValue _tmp2_;
	GeeMap* _tmp3_;
	gboolean _tmp4_ = FALSE;
	GeeMap* _tmp5_;
	gboolean _tmp6_;
	gboolean _tmp7_;
	GValue _tmp8_ = {0};
	GValue _tmp9_;
	GeeMap* _tmp10_;
	gint _tmp11_ = 0;
	GeeMap* _tmp12_;
	gint _tmp13_;
	gint _tmp14_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->test_map;
	_vala_assert (_tmp0_ != NULL, "test_map != null");
	g_value_init (&_tmp1_, G_TYPE_BOOLEAN);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
	value = _tmp1_;
	_tmp2_ = value;
	_tmp3_ = self->test_map;
	g_object_get_property ((GObject*) _tmp3_, "is-empty", &value);
	_tmp4_ = g_value_get_boolean (&value);
	_tmp5_ = self->test_map;
	_tmp6_ = gee_map_get_is_empty (_tmp5_);
	_tmp7_ = _tmp6_;
	_vala_assert (_tmp4_ == _tmp7_, "value.get_boolean () == test_map.is_empty");
	g_value_unset (&value);
	g_value_init (&_tmp8_, G_TYPE_INT);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
	value = _tmp8_;
	_tmp9_ = value;
	_tmp10_ = self->test_map;
	g_object_get_property ((GObject*) _tmp10_, "size", &value);
	_tmp11_ = g_value_get_int (&value);
	_tmp12_ = self->test_map;
	_tmp13_ = gee_map_get_size (_tmp12_);
	_tmp14_ = _tmp13_;
	_vala_assert (_tmp11_ == _tmp14_, "value.get_int () == test_map.size");
	g_value_unset (&value);
	G_IS_VALUE (&value) ? (g_value_unset (&value), NULL) : NULL;
}


MapTestsTestEntry* map_tests_test_entry_construct (GType object_type, GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, gconstpointer key, gconstpointer value) {
	MapTestsTestEntry * self = NULL;
	gconstpointer _tmp0_;
	gpointer _tmp1_;
	gconstpointer _tmp2_;
	self = (MapTestsTestEntry*) gee_map_entry_construct (object_type, k_type, (GBoxedCopyFunc) k_dup_func, k_destroy_func, v_type, (GBoxedCopyFunc) v_dup_func, v_destroy_func);
	self->priv->k_type = k_type;
	self->priv->k_dup_func = k_dup_func;
	self->priv->k_destroy_func = k_destroy_func;
	self->priv->v_type = v_type;
	self->priv->v_dup_func = v_dup_func;
	self->priv->v_destroy_func = v_destroy_func;
	_tmp0_ = key;
	_tmp1_ = ((_tmp0_ != NULL) && (k_dup_func != NULL)) ? k_dup_func ((gpointer) _tmp0_) : ((gpointer) _tmp0_);
	_k_destroy_func0 (self->priv->_key);
	self->priv->_key = _tmp1_;
	_tmp2_ = value;
	gee_map_entry_set_value ((GeeMapEntry*) self, _tmp2_);
	return self;
}


MapTestsTestEntry* map_tests_test_entry_new (GType k_type, GBoxedCopyFunc k_dup_func, GDestroyNotify k_destroy_func, GType v_type, GBoxedCopyFunc v_dup_func, GDestroyNotify v_destroy_func, gconstpointer key, gconstpointer value) {
	return map_tests_test_entry_construct (MAP_TESTS_TYPE_TEST_ENTRY, k_type, k_dup_func, k_destroy_func, v_type, v_dup_func, v_destroy_func, key, value);
}


static gconstpointer map_tests_test_entry_real_get_key (GeeMapEntry* base) {
	gconstpointer result;
	MapTestsTestEntry* self;
	gconstpointer _tmp0_;
	self = (MapTestsTestEntry*) base;
	_tmp0_ = self->priv->_key;
	result = _tmp0_;
	return result;
}


static gconstpointer map_tests_test_entry_real_get_value (GeeMapEntry* base) {
	gconstpointer result;
	MapTestsTestEntry* self;
	gconstpointer _tmp0_;
	self = (MapTestsTestEntry*) base;
	_tmp0_ = self->priv->_value;
	result = _tmp0_;
	return result;
}


static void map_tests_test_entry_real_set_value (GeeMapEntry* base, gconstpointer value) {
	MapTestsTestEntry* self;
	gconstpointer _tmp0_;
	gpointer _tmp1_;
	self = (MapTestsTestEntry*) base;
	_tmp0_ = value;
	_tmp1_ = ((_tmp0_ != NULL) && (self->priv->v_dup_func != NULL)) ? self->priv->v_dup_func ((gpointer) _tmp0_) : ((gpointer) _tmp0_);
	((self->priv->_value == NULL) || (self->priv->v_destroy_func == NULL)) ? NULL : (self->priv->_value = (self->priv->v_destroy_func (self->priv->_value), NULL));
	self->priv->_value = _tmp1_;
	g_object_notify ((GObject *) self, "value");
}


static void map_tests_test_entry_class_init (MapTestsTestEntryClass * klass) {
	map_tests_test_entry_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (MapTestsTestEntryPrivate));
	GEE_MAP_ENTRY_CLASS (klass)->get_key = map_tests_test_entry_real_get_key;
	GEE_MAP_ENTRY_CLASS (klass)->get_value = map_tests_test_entry_real_get_value;
	GEE_MAP_ENTRY_CLASS (klass)->set_value = map_tests_test_entry_real_set_value;
	G_OBJECT_CLASS (klass)->get_property = _vala_map_tests_test_entry_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_map_tests_test_entry_set_property;
	G_OBJECT_CLASS (klass)->finalize = map_tests_test_entry_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAP_TESTS_TEST_ENTRY_K_TYPE, g_param_spec_gtype ("k-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAP_TESTS_TEST_ENTRY_K_DUP_FUNC, g_param_spec_pointer ("k-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAP_TESTS_TEST_ENTRY_K_DESTROY_FUNC, g_param_spec_pointer ("k-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAP_TESTS_TEST_ENTRY_V_TYPE, g_param_spec_gtype ("v-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAP_TESTS_TEST_ENTRY_V_DUP_FUNC, g_param_spec_pointer ("v-dup-func", "dup func", "dup func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAP_TESTS_TEST_ENTRY_V_DESTROY_FUNC, g_param_spec_pointer ("v-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAP_TESTS_TEST_ENTRY_KEY, g_param_spec_pointer ("key", "key", "key", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MAP_TESTS_TEST_ENTRY_VALUE, g_param_spec_pointer ("value", "value", "value", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void map_tests_test_entry_instance_init (MapTestsTestEntry * self) {
	self->priv = MAP_TESTS_TEST_ENTRY_GET_PRIVATE (self);
}


static void map_tests_test_entry_finalize (GObject* obj) {
	MapTestsTestEntry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, MAP_TESTS_TYPE_TEST_ENTRY, MapTestsTestEntry);
	((self->priv->_key == NULL) || (self->priv->k_destroy_func == NULL)) ? NULL : (self->priv->_key = (self->priv->k_destroy_func (self->priv->_key), NULL));
	((self->priv->_value == NULL) || (self->priv->v_destroy_func == NULL)) ? NULL : (self->priv->_value = (self->priv->v_destroy_func (self->priv->_value), NULL));
	G_OBJECT_CLASS (map_tests_test_entry_parent_class)->finalize (obj);
}


GType map_tests_test_entry_get_type (void) {
	static volatile gsize map_tests_test_entry_type_id__volatile = 0;
	if (g_once_init_enter (&map_tests_test_entry_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MapTestsTestEntryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) map_tests_test_entry_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MapTestsTestEntry), 0, (GInstanceInitFunc) map_tests_test_entry_instance_init, NULL };
		GType map_tests_test_entry_type_id;
		map_tests_test_entry_type_id = g_type_register_static (GEE_MAP_TYPE_ENTRY, "MapTestsTestEntry", &g_define_type_info, 0);
		g_once_init_leave (&map_tests_test_entry_type_id__volatile, map_tests_test_entry_type_id);
	}
	return map_tests_test_entry_type_id__volatile;
}


static void _vala_map_tests_test_entry_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	MapTestsTestEntry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, MAP_TESTS_TYPE_TEST_ENTRY, MapTestsTestEntry);
	switch (property_id) {
		case MAP_TESTS_TEST_ENTRY_KEY:
		g_value_set_pointer (value, gee_map_entry_get_key ((GeeMapEntry*) self));
		break;
		case MAP_TESTS_TEST_ENTRY_VALUE:
		g_value_set_pointer (value, gee_map_entry_get_value ((GeeMapEntry*) self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_map_tests_test_entry_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	MapTestsTestEntry * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, MAP_TESTS_TYPE_TEST_ENTRY, MapTestsTestEntry);
	switch (property_id) {
		case MAP_TESTS_TEST_ENTRY_VALUE:
		gee_map_entry_set_value ((GeeMapEntry*) self, g_value_get_pointer (value));
		break;
		case MAP_TESTS_TEST_ENTRY_K_TYPE:
		self->priv->k_type = g_value_get_gtype (value);
		break;
		case MAP_TESTS_TEST_ENTRY_K_DUP_FUNC:
		self->priv->k_dup_func = g_value_get_pointer (value);
		break;
		case MAP_TESTS_TEST_ENTRY_K_DESTROY_FUNC:
		self->priv->k_destroy_func = g_value_get_pointer (value);
		break;
		case MAP_TESTS_TEST_ENTRY_V_TYPE:
		self->priv->v_type = g_value_get_gtype (value);
		break;
		case MAP_TESTS_TEST_ENTRY_V_DUP_FUNC:
		self->priv->v_dup_func = g_value_get_pointer (value);
		break;
		case MAP_TESTS_TEST_ENTRY_V_DESTROY_FUNC:
		self->priv->v_destroy_func = g_value_get_pointer (value);
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void map_tests_class_init (MapTestsClass * klass) {
	map_tests_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = map_tests_finalize;
}


static void map_tests_instance_init (MapTests * self) {
}


static void map_tests_finalize (GObject* obj) {
	MapTests * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_MAP_TESTS, MapTests);
	_g_object_unref0 (self->test_map);
	G_OBJECT_CLASS (map_tests_parent_class)->finalize (obj);
}


GType map_tests_get_type (void) {
	static volatile gsize map_tests_type_id__volatile = 0;
	if (g_once_init_enter (&map_tests_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MapTestsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) map_tests_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MapTests), 0, (GInstanceInitFunc) map_tests_instance_init, NULL };
		GType map_tests_type_id;
		map_tests_type_id = g_type_register_static (GEE_TYPE_TEST_CASE, "MapTests", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&map_tests_type_id__volatile, map_tests_type_id);
	}
	return map_tests_type_id__volatile;
}



