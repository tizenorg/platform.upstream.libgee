/* testcomparable.c generated by valac 0.18.0, the Vala compiler
 * generated from testcomparable.vala, do not modify */

/* testcomparable.vala
 *
 * Copyright (C) 2009  Didier Villevalois
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Didier 'Ptitjes' Villevalois <ptitjes@free.fr>
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>


#define GEE_TYPE_TEST_CASE (gee_test_case_get_type ())
#define GEE_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_TEST_CASE, GeeTestCase))
#define GEE_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_TEST_CASE, GeeTestCaseClass))
#define GEE_IS_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_TEST_CASE))
#define GEE_IS_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_TEST_CASE))
#define GEE_TEST_CASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_TEST_CASE, GeeTestCaseClass))

typedef struct _GeeTestCase GeeTestCase;
typedef struct _GeeTestCaseClass GeeTestCaseClass;
typedef struct _GeeTestCasePrivate GeeTestCasePrivate;

#define TYPE_COMPARABLE_TESTS (comparable_tests_get_type ())
#define COMPARABLE_TESTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_COMPARABLE_TESTS, ComparableTests))
#define COMPARABLE_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_COMPARABLE_TESTS, ComparableTestsClass))
#define IS_COMPARABLE_TESTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_COMPARABLE_TESTS))
#define IS_COMPARABLE_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_COMPARABLE_TESTS))
#define COMPARABLE_TESTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_COMPARABLE_TESTS, ComparableTestsClass))

typedef struct _ComparableTests ComparableTests;
typedef struct _ComparableTestsClass ComparableTestsClass;
typedef struct _ComparableTestsPrivate ComparableTestsPrivate;

#define COMPARABLE_TESTS_TYPE_TEST_COMPARABLE (comparable_tests_test_comparable_get_type ())
#define COMPARABLE_TESTS_TEST_COMPARABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), COMPARABLE_TESTS_TYPE_TEST_COMPARABLE, ComparableTestsTestComparable))
#define COMPARABLE_TESTS_TEST_COMPARABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), COMPARABLE_TESTS_TYPE_TEST_COMPARABLE, ComparableTestsTestComparableClass))
#define COMPARABLE_TESTS_IS_TEST_COMPARABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), COMPARABLE_TESTS_TYPE_TEST_COMPARABLE))
#define COMPARABLE_TESTS_IS_TEST_COMPARABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), COMPARABLE_TESTS_TYPE_TEST_COMPARABLE))
#define COMPARABLE_TESTS_TEST_COMPARABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), COMPARABLE_TESTS_TYPE_TEST_COMPARABLE, ComparableTestsTestComparableClass))

typedef struct _ComparableTestsTestComparable ComparableTestsTestComparable;
typedef struct _ComparableTestsTestComparableClass ComparableTestsTestComparableClass;
typedef struct _ComparableTestsTestComparablePrivate ComparableTestsTestComparablePrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _GeeTestCase {
	GObject parent_instance;
	GeeTestCasePrivate * priv;
};

struct _GeeTestCaseClass {
	GObjectClass parent_class;
	void (*set_up) (GeeTestCase* self);
	void (*tear_down) (GeeTestCase* self);
};

struct _ComparableTests {
	GeeTestCase parent_instance;
	ComparableTestsPrivate * priv;
};

struct _ComparableTestsClass {
	GeeTestCaseClass parent_class;
};

typedef void (*GeeTestCaseTestMethod) (void* user_data);
struct _ComparableTestsTestComparable {
	GObject parent_instance;
	ComparableTestsTestComparablePrivate * priv;
	gint _a;
};

struct _ComparableTestsTestComparableClass {
	GObjectClass parent_class;
};


static gpointer comparable_tests_parent_class = NULL;
static gpointer comparable_tests_test_comparable_parent_class = NULL;
static GeeComparableIface* comparable_tests_test_comparable_gee_comparable_parent_iface = NULL;

GType gee_test_case_get_type (void) G_GNUC_CONST;
GType comparable_tests_get_type (void) G_GNUC_CONST;
enum  {
	COMPARABLE_TESTS_DUMMY_PROPERTY
};
ComparableTests* comparable_tests_new (void);
ComparableTests* comparable_tests_construct (GType object_type);
GeeTestCase* gee_test_case_construct (GType object_type, const gchar* name);
void gee_test_case_add_test (GeeTestCase* self, const gchar* name, GeeTestCaseTestMethod test, void* test_target);
void comparable_tests_test_selected_functions (ComparableTests* self);
static void _comparable_tests_test_selected_functions_gee_test_case_test_method (gpointer self);
static ComparableTestsTestComparable* comparable_tests_test_comparable_new (gint a);
static ComparableTestsTestComparable* comparable_tests_test_comparable_construct (GType object_type, gint a);
static GType comparable_tests_test_comparable_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
enum  {
	COMPARABLE_TESTS_TEST_COMPARABLE_DUMMY_PROPERTY
};
static gint comparable_tests_test_comparable_real_compare_to (GeeComparable* base, ComparableTestsTestComparable* object);
static void comparable_tests_test_comparable_finalize (GObject* obj);


static void _comparable_tests_test_selected_functions_gee_test_case_test_method (gpointer self) {
	comparable_tests_test_selected_functions (self);
}


ComparableTests* comparable_tests_construct (GType object_type) {
	ComparableTests * self = NULL;
	self = (ComparableTests*) gee_test_case_construct (object_type, "Comparable");
	gee_test_case_add_test ((GeeTestCase*) self, "[Comparable] selected functions", _comparable_tests_test_selected_functions_gee_test_case_test_method, self);
	return self;
}


ComparableTests* comparable_tests_new (void) {
	return comparable_tests_construct (TYPE_COMPARABLE_TESTS);
}


void comparable_tests_test_selected_functions (ComparableTests* self) {
	ComparableTestsTestComparable* _tmp0_;
	ComparableTestsTestComparable* o1;
	ComparableTestsTestComparable* _tmp1_;
	ComparableTestsTestComparable* o2;
	GCompareFunc _tmp2_ = NULL;
	GCompareFunc compare;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = comparable_tests_test_comparable_new (10);
	o1 = _tmp0_;
	_tmp1_ = comparable_tests_test_comparable_new (20);
	o2 = _tmp1_;
	_tmp2_ = gee_functions_get_compare_func_for (COMPARABLE_TESTS_TYPE_TEST_COMPARABLE);
	compare = _tmp2_;
	_tmp3_ = compare (o1, o2);
	_vala_assert (_tmp3_ < 0, "compare (o1, o2) < 0");
	o1->_a = 42;
	_tmp4_ = compare (o1, o2);
	_vala_assert (_tmp4_ > 0, "compare (o1, o2) > 0");
	_g_object_unref0 (o2);
	_g_object_unref0 (o1);
}


static ComparableTestsTestComparable* comparable_tests_test_comparable_construct (GType object_type, gint a) {
	ComparableTestsTestComparable * self = NULL;
	gint _tmp0_;
	self = (ComparableTestsTestComparable*) g_object_new (object_type, NULL);
	_tmp0_ = a;
	self->_a = _tmp0_;
	return self;
}


static ComparableTestsTestComparable* comparable_tests_test_comparable_new (gint a) {
	return comparable_tests_test_comparable_construct (COMPARABLE_TESTS_TYPE_TEST_COMPARABLE, a);
}


static gint comparable_tests_test_comparable_real_compare_to (GeeComparable* base, ComparableTestsTestComparable* object) {
	ComparableTestsTestComparable * self;
	gint result = 0;
	gint _tmp0_;
	ComparableTestsTestComparable* _tmp1_;
	gint _tmp2_;
	self = (ComparableTestsTestComparable*) base;
	g_return_val_if_fail (object != NULL, 0);
	_tmp0_ = self->_a;
	_tmp1_ = object;
	_tmp2_ = _tmp1_->_a;
	result = _tmp0_ - _tmp2_;
	return result;
}


static void comparable_tests_test_comparable_class_init (ComparableTestsTestComparableClass * klass) {
	comparable_tests_test_comparable_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = comparable_tests_test_comparable_finalize;
}


static void comparable_tests_test_comparable_gee_comparable_interface_init (GeeComparableIface * iface) {
	comparable_tests_test_comparable_gee_comparable_parent_iface = g_type_interface_peek_parent (iface);
	iface->compare_to = (gint (*)(GeeComparable*, gconstpointer)) comparable_tests_test_comparable_real_compare_to;
}


static void comparable_tests_test_comparable_instance_init (ComparableTestsTestComparable * self) {
}


static void comparable_tests_test_comparable_finalize (GObject* obj) {
	ComparableTestsTestComparable * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, COMPARABLE_TESTS_TYPE_TEST_COMPARABLE, ComparableTestsTestComparable);
	G_OBJECT_CLASS (comparable_tests_test_comparable_parent_class)->finalize (obj);
}


static GType comparable_tests_test_comparable_get_type (void) {
	static volatile gsize comparable_tests_test_comparable_type_id__volatile = 0;
	if (g_once_init_enter (&comparable_tests_test_comparable_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ComparableTestsTestComparableClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) comparable_tests_test_comparable_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ComparableTestsTestComparable), 0, (GInstanceInitFunc) comparable_tests_test_comparable_instance_init, NULL };
		static const GInterfaceInfo gee_comparable_info = { (GInterfaceInitFunc) comparable_tests_test_comparable_gee_comparable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType comparable_tests_test_comparable_type_id;
		comparable_tests_test_comparable_type_id = g_type_register_static (G_TYPE_OBJECT, "ComparableTestsTestComparable", &g_define_type_info, 0);
		g_type_add_interface_static (comparable_tests_test_comparable_type_id, GEE_TYPE_COMPARABLE, &gee_comparable_info);
		g_once_init_leave (&comparable_tests_test_comparable_type_id__volatile, comparable_tests_test_comparable_type_id);
	}
	return comparable_tests_test_comparable_type_id__volatile;
}


static void comparable_tests_class_init (ComparableTestsClass * klass) {
	comparable_tests_parent_class = g_type_class_peek_parent (klass);
}


static void comparable_tests_instance_init (ComparableTests * self) {
}


GType comparable_tests_get_type (void) {
	static volatile gsize comparable_tests_type_id__volatile = 0;
	if (g_once_init_enter (&comparable_tests_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ComparableTestsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) comparable_tests_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ComparableTests), 0, (GInstanceInitFunc) comparable_tests_instance_init, NULL };
		GType comparable_tests_type_id;
		comparable_tests_type_id = g_type_register_static (GEE_TYPE_TEST_CASE, "ComparableTests", &g_define_type_info, 0);
		g_once_init_leave (&comparable_tests_type_id__volatile, comparable_tests_type_id);
	}
	return comparable_tests_type_id__volatile;
}



