/* testfunctions.c generated by valac 0.20.1.66-2886, the Vala compiler
 * generated from testfunctions.vala, do not modify */

/* testfunctions.vala
 *
 * Copyright (C) 2010  Maciej Piechotka
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Maciej Piechotka <uzytkownik2@gmail.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gee.h>


#define GEE_TYPE_TEST_CASE (gee_test_case_get_type ())
#define GEE_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), GEE_TYPE_TEST_CASE, GeeTestCase))
#define GEE_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), GEE_TYPE_TEST_CASE, GeeTestCaseClass))
#define GEE_IS_TEST_CASE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GEE_TYPE_TEST_CASE))
#define GEE_IS_TEST_CASE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GEE_TYPE_TEST_CASE))
#define GEE_TEST_CASE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GEE_TYPE_TEST_CASE, GeeTestCaseClass))

typedef struct _GeeTestCase GeeTestCase;
typedef struct _GeeTestCaseClass GeeTestCaseClass;
typedef struct _GeeTestCasePrivate GeeTestCasePrivate;

#define TYPE_FUNCTIONS_TESTS (functions_tests_get_type ())
#define FUNCTIONS_TESTS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FUNCTIONS_TESTS, FunctionsTests))
#define FUNCTIONS_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FUNCTIONS_TESTS, FunctionsTestsClass))
#define IS_FUNCTIONS_TESTS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FUNCTIONS_TESTS))
#define IS_FUNCTIONS_TESTS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FUNCTIONS_TESTS))
#define FUNCTIONS_TESTS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FUNCTIONS_TESTS, FunctionsTestsClass))

typedef struct _FunctionsTests FunctionsTests;
typedef struct _FunctionsTestsClass FunctionsTestsClass;
typedef struct _FunctionsTestsPrivate FunctionsTestsPrivate;
#define _g_free0(var) (var = (g_free (var), NULL))

#define FUNCTIONS_TESTS_TYPE_MY_COMPARABLE (functions_tests_my_comparable_get_type ())
#define FUNCTIONS_TESTS_MY_COMPARABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, FunctionsTestsMyComparable))
#define FUNCTIONS_TESTS_MY_COMPARABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, FunctionsTestsMyComparableClass))
#define FUNCTIONS_TESTS_IS_MY_COMPARABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE))
#define FUNCTIONS_TESTS_IS_MY_COMPARABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE))
#define FUNCTIONS_TESTS_MY_COMPARABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, FunctionsTestsMyComparableClass))

typedef struct _FunctionsTestsMyComparable FunctionsTestsMyComparable;
typedef struct _FunctionsTestsMyComparableClass FunctionsTestsMyComparableClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define FUNCTIONS_TESTS_TYPE_MY_HASHABLE (functions_tests_my_hashable_get_type ())
#define FUNCTIONS_TESTS_MY_HASHABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), FUNCTIONS_TESTS_TYPE_MY_HASHABLE, FunctionsTestsMyHashable))
#define FUNCTIONS_TESTS_MY_HASHABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), FUNCTIONS_TESTS_TYPE_MY_HASHABLE, FunctionsTestsMyHashableClass))
#define FUNCTIONS_TESTS_IS_MY_HASHABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), FUNCTIONS_TESTS_TYPE_MY_HASHABLE))
#define FUNCTIONS_TESTS_IS_MY_HASHABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), FUNCTIONS_TESTS_TYPE_MY_HASHABLE))
#define FUNCTIONS_TESTS_MY_HASHABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), FUNCTIONS_TESTS_TYPE_MY_HASHABLE, FunctionsTestsMyHashableClass))

typedef struct _FunctionsTestsMyHashable FunctionsTestsMyHashable;
typedef struct _FunctionsTestsMyHashableClass FunctionsTestsMyHashableClass;
typedef struct _Block5Data Block5Data;
typedef struct _Block6Data Block6Data;
typedef struct _Block7Data Block7Data;
typedef struct _Block8Data Block8Data;
typedef struct _FunctionsTestsMyComparablePrivate FunctionsTestsMyComparablePrivate;
typedef struct _FunctionsTestsMyHashablePrivate FunctionsTestsMyHashablePrivate;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _GeeTestCase {
	GObject parent_instance;
	GeeTestCasePrivate * priv;
};

struct _GeeTestCaseClass {
	GObjectClass parent_class;
	void (*set_up) (GeeTestCase* self);
	void (*tear_down) (GeeTestCase* self);
};

struct _FunctionsTests {
	GeeTestCase parent_instance;
	FunctionsTestsPrivate * priv;
};

struct _FunctionsTestsClass {
	GeeTestCaseClass parent_class;
};

typedef void (*GeeTestCaseTestMethod) (void* user_data);
struct _Block5Data {
	int _ref_count_;
	FunctionsTests * self;
	gint i;
	gint j;
};

struct _Block6Data {
	int _ref_count_;
	Block5Data * _data5_;
	gint k;
};

struct _Block7Data {
	int _ref_count_;
	FunctionsTests * self;
	gint i;
};

struct _Block8Data {
	int _ref_count_;
	Block7Data * _data7_;
	gint j;
	gint start;
};

struct _FunctionsTestsMyComparable {
	GObject parent_instance;
	FunctionsTestsMyComparablePrivate * priv;
};

struct _FunctionsTestsMyComparableClass {
	GObjectClass parent_class;
};

struct _FunctionsTestsMyComparablePrivate {
	gint i;
};

struct _FunctionsTestsMyHashable {
	GObject parent_instance;
	FunctionsTestsMyHashablePrivate * priv;
};

struct _FunctionsTestsMyHashableClass {
	GObjectClass parent_class;
};

struct _FunctionsTestsMyHashablePrivate {
	gint i;
};


static gpointer functions_tests_parent_class = NULL;
static gpointer functions_tests_my_comparable_parent_class = NULL;
static GeeComparableIface* functions_tests_my_comparable_gee_comparable_parent_iface = NULL;
static gpointer functions_tests_my_hashable_parent_class = NULL;
static GeeComparableIface* functions_tests_my_hashable_gee_comparable_parent_iface = NULL;
static GeeHashableIface* functions_tests_my_hashable_gee_hashable_parent_iface = NULL;

GType gee_test_case_get_type (void) G_GNUC_CONST;
GType functions_tests_get_type (void) G_GNUC_CONST;
enum  {
	FUNCTIONS_TESTS_DUMMY_PROPERTY
};
FunctionsTests* functions_tests_new (void);
FunctionsTests* functions_tests_construct (GType object_type);
GeeTestCase* gee_test_case_construct (GType object_type, const gchar* name);
void gee_test_case_add_test (GeeTestCase* self, const gchar* name, GeeTestCaseTestMethod test, void* test_target, GDestroyNotify test_target_destroy_notify);
void functions_tests_test_string_func (FunctionsTests* self);
static void _functions_tests_test_string_func_gee_test_case_test_method (gpointer self);
void functions_tests_test_int_func (FunctionsTests* self);
static void _functions_tests_test_int_func_gee_test_case_test_method (gpointer self);
void functions_tests_test_compare_func (FunctionsTests* self);
static void _functions_tests_test_compare_func_gee_test_case_test_method (gpointer self);
void functions_tests_test_hash_func (FunctionsTests* self);
static void _functions_tests_test_hash_func_gee_test_case_test_method (gpointer self);
void functions_tests_test_unfold (FunctionsTests* self);
static void _functions_tests_test_unfold_gee_test_case_test_method (gpointer self);
void functions_tests_test_concat (FunctionsTests* self);
static void _functions_tests_test_concat_gee_test_case_test_method (gpointer self);
static GType functions_tests_my_comparable_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static FunctionsTestsMyComparable* functions_tests_my_comparable_new (gint i);
static FunctionsTestsMyComparable* functions_tests_my_comparable_construct (GType object_type, gint i);
static GType functions_tests_my_hashable_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static FunctionsTestsMyHashable* functions_tests_my_hashable_new (gint i);
static FunctionsTestsMyHashable* functions_tests_my_hashable_construct (GType object_type, gint i);
static Block5Data* block5_data_ref (Block5Data* _data5_);
static void block5_data_unref (void * _userdata_);
static GeeLazy* __lambda20_ (Block5Data* _data5_);
static Block6Data* block6_data_ref (Block6Data* _data6_);
static void block6_data_unref (void * _userdata_);
static gint __lambda21_ (Block6Data* _data6_);
static gpointer ___lambda21__gee_lazy_func (gpointer self);
static GeeLazy* ___lambda20__gee_unfold_func (gpointer self);
static Block7Data* block7_data_ref (Block7Data* _data7_);
static void block7_data_unref (void * _userdata_);
static GeeLazy* __lambda22_ (Block7Data* _data7_);
static Block8Data* block8_data_ref (Block8Data* _data8_);
static void block8_data_unref (void * _userdata_);
static GeeLazy* __lambda23_ (Block8Data* _data8_);
static GeeLazy* ___lambda23__gee_unfold_func (gpointer self);
static GeeLazy* ___lambda22__gee_unfold_func (gpointer self);
#define FUNCTIONS_TESTS_MY_COMPARABLE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, FunctionsTestsMyComparablePrivate))
enum  {
	FUNCTIONS_TESTS_MY_COMPARABLE_DUMMY_PROPERTY
};
static gint functions_tests_my_comparable_real_compare_to (GeeComparable* base, FunctionsTestsMyComparable* cmp);
static void functions_tests_my_comparable_finalize (GObject* obj);
#define FUNCTIONS_TESTS_MY_HASHABLE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), FUNCTIONS_TESTS_TYPE_MY_HASHABLE, FunctionsTestsMyHashablePrivate))
enum  {
	FUNCTIONS_TESTS_MY_HASHABLE_DUMMY_PROPERTY
};
static gint functions_tests_my_hashable_real_compare_to (GeeComparable* base, FunctionsTestsMyHashable* cmp);
static guint functions_tests_my_hashable_real_hash (GeeHashable* base);
static gboolean functions_tests_my_hashable_real_equal_to (GeeHashable* base, FunctionsTestsMyHashable* hash);
static void functions_tests_my_hashable_finalize (GObject* obj);


static void _functions_tests_test_string_func_gee_test_case_test_method (gpointer self) {
	functions_tests_test_string_func (self);
}


static void _functions_tests_test_int_func_gee_test_case_test_method (gpointer self) {
	functions_tests_test_int_func (self);
}


static void _functions_tests_test_compare_func_gee_test_case_test_method (gpointer self) {
	functions_tests_test_compare_func (self);
}


static void _functions_tests_test_hash_func_gee_test_case_test_method (gpointer self) {
	functions_tests_test_hash_func (self);
}


static void _functions_tests_test_unfold_gee_test_case_test_method (gpointer self) {
	functions_tests_test_unfold (self);
}


static void _functions_tests_test_concat_gee_test_case_test_method (gpointer self) {
	functions_tests_test_concat (self);
}


FunctionsTests* functions_tests_construct (GType object_type) {
	FunctionsTests * self = NULL;
	self = (FunctionsTests*) gee_test_case_construct (object_type, "Functions");
	gee_test_case_add_test ((GeeTestCase*) self, "[Functions] comparing and hashing strings", _functions_tests_test_string_func_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[Functions] comparing and hashing int", _functions_tests_test_int_func_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[Functions] comparing instances of Comparable", _functions_tests_test_compare_func_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[Functions] comparing and hashing instances of Hashable", _functions_tests_test_hash_func_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[Iterator] unfold", _functions_tests_test_unfold_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	gee_test_case_add_test ((GeeTestCase*) self, "[Iterator] concat", _functions_tests_test_concat_gee_test_case_test_method, g_object_ref (self), g_object_unref);
	return self;
}


FunctionsTests* functions_tests_new (void) {
	return functions_tests_construct (TYPE_FUNCTIONS_TESTS);
}


void functions_tests_test_string_func (FunctionsTests* self) {
	gchar* one = NULL;
	gchar* _tmp0_ = NULL;
	gchar* two = NULL;
	gchar* _tmp1_ = NULL;
	gchar* two_copy = NULL;
	gchar* _tmp2_ = NULL;
	GeeEqualDataFunc eq = NULL;
	void* _tmp3_ = NULL;
	GDestroyNotify _tmp4_ = NULL;
	GeeEqualDataFunc _tmp5_ = NULL;
	void* eq_target = NULL;
	GDestroyNotify eq_target_destroy_notify = NULL;
	GCompareDataFunc cmp = NULL;
	void* _tmp6_ = NULL;
	GDestroyNotify _tmp7_ = NULL;
	GCompareDataFunc _tmp8_ = NULL;
	void* cmp_target = NULL;
	GDestroyNotify cmp_target_destroy_notify = NULL;
	GeeHashDataFunc hash = NULL;
	void* _tmp9_ = NULL;
	GDestroyNotify _tmp10_ = NULL;
	GeeHashDataFunc _tmp11_ = NULL;
	void* hash_target = NULL;
	GDestroyNotify hash_target_destroy_notify = NULL;
	gboolean _tmp12_ = FALSE;
	gint _tmp13_ = 0;
	guint _tmp14_ = 0U;
	guint _tmp15_ = 0U;
	gboolean _tmp16_ = FALSE;
	gint _tmp17_ = 0;
	guint _tmp18_ = 0U;
	guint _tmp19_ = 0U;
	gboolean _tmp20_ = FALSE;
	gint _tmp21_ = 0;
	gboolean _tmp22_ = FALSE;
	gint _tmp23_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup ("one");
	one = _tmp0_;
	_tmp1_ = g_strdup ("two");
	two = _tmp1_;
	_tmp2_ = g_strdup (two);
	two_copy = _tmp2_;
	_tmp5_ = gee_functions_get_equal_func_for (G_TYPE_STRING, &_tmp3_, &_tmp4_);
	eq = _tmp5_;
	eq_target = _tmp3_;
	eq_target_destroy_notify = _tmp4_;
	_tmp8_ = gee_functions_get_compare_func_for (G_TYPE_STRING, &_tmp6_, &_tmp7_);
	cmp = _tmp8_;
	cmp_target = _tmp6_;
	cmp_target_destroy_notify = _tmp7_;
	_tmp11_ = gee_functions_get_hash_func_for (G_TYPE_STRING, &_tmp9_, &_tmp10_);
	hash = _tmp11_;
	hash_target = _tmp9_;
	hash_target_destroy_notify = _tmp10_;
	_vala_assert (eq != NULL, "eq != null");
	_vala_assert (cmp != NULL, "cmp != null");
	_vala_assert (hash != NULL, "hash != null");
	_tmp12_ = eq (two, two, eq_target);
	_vala_assert (_tmp12_, "eq (two, two)");
	_tmp13_ = cmp (two, two, cmp_target);
	_vala_assert (_tmp13_ == 0, "cmp (two, two) == 0");
	_tmp14_ = hash (two, hash_target);
	_tmp15_ = hash (two, hash_target);
	_vala_assert (_tmp14_ == _tmp15_, "hash (two) == hash (two)");
	_tmp16_ = eq (two, two_copy, eq_target);
	_vala_assert (_tmp16_, "eq (two, two_copy)");
	_tmp17_ = cmp (two, two_copy, cmp_target);
	_vala_assert (_tmp17_ == 0, "cmp (two, two_copy) == 0");
	_tmp18_ = hash (two, hash_target);
	_tmp19_ = hash (two_copy, hash_target);
	_vala_assert (_tmp18_ == _tmp19_, "hash (two) == hash (two_copy)");
	_tmp20_ = eq (one, two, eq_target);
	_vala_assert (!_tmp20_, "!eq (one, two)");
	_tmp21_ = cmp (one, two, cmp_target);
	_vala_assert (_tmp21_ < 0, "cmp (one, two) < 0");
	_tmp22_ = eq (two, one, eq_target);
	_vala_assert (!_tmp22_, "!eq (two, one)");
	_tmp23_ = cmp (two, one, cmp_target);
	_vala_assert (_tmp23_ > 0, "cmp (two, one) > 0");
	(hash_target_destroy_notify == NULL) ? NULL : (hash_target_destroy_notify (hash_target), NULL);
	hash = NULL;
	hash_target = NULL;
	hash_target_destroy_notify = NULL;
	(cmp_target_destroy_notify == NULL) ? NULL : (cmp_target_destroy_notify (cmp_target), NULL);
	cmp = NULL;
	cmp_target = NULL;
	cmp_target_destroy_notify = NULL;
	(eq_target_destroy_notify == NULL) ? NULL : (eq_target_destroy_notify (eq_target), NULL);
	eq = NULL;
	eq_target = NULL;
	eq_target_destroy_notify = NULL;
	_g_free0 (two_copy);
	_g_free0 (two);
	_g_free0 (one);
}


void functions_tests_test_int_func (FunctionsTests* self) {
	void* one = NULL;
	void* two = NULL;
	GeeEqualDataFunc eq = NULL;
	void* _tmp0_ = NULL;
	GDestroyNotify _tmp1_ = NULL;
	GeeEqualDataFunc _tmp2_ = NULL;
	void* eq_target = NULL;
	GDestroyNotify eq_target_destroy_notify = NULL;
	GCompareDataFunc cmp = NULL;
	void* _tmp3_ = NULL;
	GDestroyNotify _tmp4_ = NULL;
	GCompareDataFunc _tmp5_ = NULL;
	void* cmp_target = NULL;
	GDestroyNotify cmp_target_destroy_notify = NULL;
	GeeHashDataFunc hash = NULL;
	void* _tmp6_ = NULL;
	GDestroyNotify _tmp7_ = NULL;
	GeeHashDataFunc _tmp8_ = NULL;
	void* hash_target = NULL;
	GDestroyNotify hash_target_destroy_notify = NULL;
	gboolean _tmp9_ = FALSE;
	gint _tmp10_ = 0;
	guint _tmp11_ = 0U;
	guint _tmp12_ = 0U;
	gboolean _tmp13_ = FALSE;
	gint _tmp14_ = 0;
	gboolean _tmp15_ = FALSE;
	gint _tmp16_ = 0;
	g_return_if_fail (self != NULL);
	one = (void*) 1;
	two = (void*) 2;
	_tmp2_ = gee_functions_get_equal_func_for (G_TYPE_INT, &_tmp0_, &_tmp1_);
	eq = _tmp2_;
	eq_target = _tmp0_;
	eq_target_destroy_notify = _tmp1_;
	_tmp5_ = gee_functions_get_compare_func_for (G_TYPE_INT, &_tmp3_, &_tmp4_);
	cmp = _tmp5_;
	cmp_target = _tmp3_;
	cmp_target_destroy_notify = _tmp4_;
	_tmp8_ = gee_functions_get_hash_func_for (G_TYPE_INT, &_tmp6_, &_tmp7_);
	hash = _tmp8_;
	hash_target = _tmp6_;
	hash_target_destroy_notify = _tmp7_;
	_vala_assert (eq != NULL, "eq != null");
	_vala_assert (cmp != NULL, "cmp != null");
	_vala_assert (hash != NULL, "hash != null");
	_tmp9_ = eq (two, two, eq_target);
	_vala_assert (_tmp9_, "eq (two, two)");
	_tmp10_ = cmp (two, two, cmp_target);
	_vala_assert (_tmp10_ == 0, "cmp (two, two) == 0");
	_tmp11_ = hash (two, hash_target);
	_tmp12_ = hash (two, hash_target);
	_vala_assert (_tmp11_ == _tmp12_, "hash (two) == hash (two)");
	_tmp13_ = eq (one, two, eq_target);
	_vala_assert (!_tmp13_, "!eq (one, two)");
	_tmp14_ = cmp (one, two, cmp_target);
	_vala_assert (_tmp14_ < 0, "cmp (one, two) < 0");
	_tmp15_ = eq (two, one, eq_target);
	_vala_assert (!_tmp15_, "!eq (two, one)");
	_tmp16_ = cmp (two, one, cmp_target);
	_vala_assert (_tmp16_ > 0, "cmp (two, one) > 0");
	(hash_target_destroy_notify == NULL) ? NULL : (hash_target_destroy_notify (hash_target), NULL);
	hash = NULL;
	hash_target = NULL;
	hash_target_destroy_notify = NULL;
	(cmp_target_destroy_notify == NULL) ? NULL : (cmp_target_destroy_notify (cmp_target), NULL);
	cmp = NULL;
	cmp_target = NULL;
	cmp_target_destroy_notify = NULL;
	(eq_target_destroy_notify == NULL) ? NULL : (eq_target_destroy_notify (eq_target), NULL);
	eq = NULL;
	eq_target = NULL;
	eq_target_destroy_notify = NULL;
}


void functions_tests_test_compare_func (FunctionsTests* self) {
	FunctionsTestsMyComparable* two = NULL;
	FunctionsTestsMyComparable* _tmp0_ = NULL;
	FunctionsTestsMyComparable* one = NULL;
	FunctionsTestsMyComparable* _tmp1_ = NULL;
	FunctionsTestsMyComparable* two_copy = NULL;
	FunctionsTestsMyComparable* _tmp2_ = NULL;
	GeeEqualDataFunc eq = NULL;
	void* _tmp3_ = NULL;
	GDestroyNotify _tmp4_ = NULL;
	GeeEqualDataFunc _tmp5_ = NULL;
	void* eq_target = NULL;
	GDestroyNotify eq_target_destroy_notify = NULL;
	GCompareDataFunc cmp = NULL;
	void* _tmp6_ = NULL;
	GDestroyNotify _tmp7_ = NULL;
	GCompareDataFunc _tmp8_ = NULL;
	void* cmp_target = NULL;
	GDestroyNotify cmp_target_destroy_notify = NULL;
	gboolean _tmp9_ = FALSE;
	gint _tmp10_ = 0;
	gboolean _tmp11_ = FALSE;
	gint _tmp12_ = 0;
	gboolean _tmp13_ = FALSE;
	gint _tmp14_ = 0;
	gboolean _tmp15_ = FALSE;
	gint _tmp16_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = functions_tests_my_comparable_new (2);
	two = _tmp0_;
	_tmp1_ = functions_tests_my_comparable_new (1);
	one = _tmp1_;
	_tmp2_ = functions_tests_my_comparable_new (2);
	two_copy = _tmp2_;
	_tmp5_ = gee_functions_get_equal_func_for (FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, &_tmp3_, &_tmp4_);
	eq = _tmp5_;
	eq_target = _tmp3_;
	eq_target_destroy_notify = _tmp4_;
	_tmp8_ = gee_functions_get_compare_func_for (FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, &_tmp6_, &_tmp7_);
	cmp = _tmp8_;
	cmp_target = _tmp6_;
	cmp_target_destroy_notify = _tmp7_;
	_vala_assert (eq != NULL, "eq != null");
	_vala_assert (cmp != NULL, "cmp != null");
	_tmp9_ = eq (two, two, eq_target);
	_vala_assert (_tmp9_, "eq (two, two)");
	_tmp10_ = cmp (two, two, cmp_target);
	_vala_assert (_tmp10_ == 0, "cmp (two, two) == 0");
	_tmp11_ = eq (two, two_copy, eq_target);
	_vala_assert (_tmp11_, "eq (two, two_copy)");
	_tmp12_ = cmp (two, two_copy, cmp_target);
	_vala_assert (_tmp12_ == 0, "cmp (two, two_copy) == 0");
	_tmp13_ = eq (one, two, eq_target);
	_vala_assert (!_tmp13_, "!eq (one, two)");
	_tmp14_ = cmp (one, two, cmp_target);
	_vala_assert (_tmp14_ < 0, "cmp (one, two) < 0");
	_tmp15_ = eq (two, one, eq_target);
	_vala_assert (!_tmp15_, "!eq (two, one)");
	_tmp16_ = cmp (two, one, cmp_target);
	_vala_assert (_tmp16_ > 0, "cmp (two, one) > 0");
	(cmp_target_destroy_notify == NULL) ? NULL : (cmp_target_destroy_notify (cmp_target), NULL);
	cmp = NULL;
	cmp_target = NULL;
	cmp_target_destroy_notify = NULL;
	(eq_target_destroy_notify == NULL) ? NULL : (eq_target_destroy_notify (eq_target), NULL);
	eq = NULL;
	eq_target = NULL;
	eq_target_destroy_notify = NULL;
	_g_object_unref0 (two_copy);
	_g_object_unref0 (one);
	_g_object_unref0 (two);
}


void functions_tests_test_hash_func (FunctionsTests* self) {
	FunctionsTestsMyHashable* two = NULL;
	FunctionsTestsMyHashable* _tmp0_ = NULL;
	FunctionsTestsMyHashable* one = NULL;
	FunctionsTestsMyHashable* _tmp1_ = NULL;
	FunctionsTestsMyHashable* two_copy = NULL;
	FunctionsTestsMyHashable* _tmp2_ = NULL;
	FunctionsTestsMyHashable* minus_one = NULL;
	FunctionsTestsMyHashable* _tmp3_ = NULL;
	FunctionsTestsMyHashable* minus_one2 = NULL;
	FunctionsTestsMyHashable* _tmp4_ = NULL;
	GeeEqualDataFunc eq = NULL;
	void* _tmp5_ = NULL;
	GDestroyNotify _tmp6_ = NULL;
	GeeEqualDataFunc _tmp7_ = NULL;
	void* eq_target = NULL;
	GDestroyNotify eq_target_destroy_notify = NULL;
	GCompareDataFunc cmp = NULL;
	void* _tmp8_ = NULL;
	GDestroyNotify _tmp9_ = NULL;
	GCompareDataFunc _tmp10_ = NULL;
	void* cmp_target = NULL;
	GDestroyNotify cmp_target_destroy_notify = NULL;
	GeeHashDataFunc hash = NULL;
	void* _tmp11_ = NULL;
	GDestroyNotify _tmp12_ = NULL;
	GeeHashDataFunc _tmp13_ = NULL;
	void* hash_target = NULL;
	GDestroyNotify hash_target_destroy_notify = NULL;
	gboolean _tmp14_ = FALSE;
	gint _tmp15_ = 0;
	guint _tmp16_ = 0U;
	guint _tmp17_ = 0U;
	gboolean _tmp18_ = FALSE;
	gint _tmp19_ = 0;
	guint _tmp20_ = 0U;
	guint _tmp21_ = 0U;
	gboolean _tmp22_ = FALSE;
	gint _tmp23_ = 0;
	gboolean _tmp24_ = FALSE;
	gint _tmp25_ = 0;
	guint _tmp26_ = 0U;
	gboolean _tmp27_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = functions_tests_my_hashable_new (2);
	two = _tmp0_;
	_tmp1_ = functions_tests_my_hashable_new (1);
	one = _tmp1_;
	_tmp2_ = functions_tests_my_hashable_new (2);
	two_copy = _tmp2_;
	_tmp3_ = functions_tests_my_hashable_new (-1);
	minus_one = _tmp3_;
	_tmp4_ = functions_tests_my_hashable_new (-1);
	minus_one2 = _tmp4_;
	_tmp7_ = gee_functions_get_equal_func_for (FUNCTIONS_TESTS_TYPE_MY_HASHABLE, &_tmp5_, &_tmp6_);
	eq = _tmp7_;
	eq_target = _tmp5_;
	eq_target_destroy_notify = _tmp6_;
	_tmp10_ = gee_functions_get_compare_func_for (FUNCTIONS_TESTS_TYPE_MY_HASHABLE, &_tmp8_, &_tmp9_);
	cmp = _tmp10_;
	cmp_target = _tmp8_;
	cmp_target_destroy_notify = _tmp9_;
	_tmp13_ = gee_functions_get_hash_func_for (FUNCTIONS_TESTS_TYPE_MY_HASHABLE, &_tmp11_, &_tmp12_);
	hash = _tmp13_;
	hash_target = _tmp11_;
	hash_target_destroy_notify = _tmp12_;
	_vala_assert (eq != NULL, "eq != null");
	_vala_assert (cmp != NULL, "cmp != null");
	_vala_assert (hash != NULL, "hash != null");
	_tmp14_ = eq (two, two, eq_target);
	_vala_assert (_tmp14_, "eq (two, two)");
	_tmp15_ = cmp (two, two, cmp_target);
	_vala_assert (_tmp15_ == 0, "cmp (two, two) == 0");
	_tmp16_ = hash (two, hash_target);
	_tmp17_ = hash (two, hash_target);
	_vala_assert (_tmp16_ == _tmp17_, "hash (two) == hash (two)");
	_tmp18_ = eq (two, two_copy, eq_target);
	_vala_assert (_tmp18_, "eq (two, two_copy)");
	_tmp19_ = cmp (two, two_copy, cmp_target);
	_vala_assert (_tmp19_ == 0, "cmp (two, two_copy) == 0");
	_tmp20_ = hash (two, hash_target);
	_tmp21_ = hash (two_copy, hash_target);
	_vala_assert (_tmp20_ == _tmp21_, "hash (two) == hash (two_copy)");
	_tmp22_ = eq (one, two, eq_target);
	_vala_assert (!_tmp22_, "!eq (one, two)");
	_tmp23_ = cmp (one, two, cmp_target);
	_vala_assert (_tmp23_ < 0, "cmp (one, two) < 0");
	_tmp24_ = eq (two, one, eq_target);
	_vala_assert (!_tmp24_, "!eq (two, one)");
	_tmp25_ = cmp (two, one, cmp_target);
	_vala_assert (_tmp25_ > 0, "cmp (two, one) > 0");
	_tmp26_ = hash (one, hash_target);
	_vala_assert (_tmp26_ == ((guint) 1), "hash (one) == 1");
	_tmp27_ = eq (minus_one, minus_one2, eq_target);
	_vala_assert (!_tmp27_, "!eq (minus_one, minus_one2)");
	(hash_target_destroy_notify == NULL) ? NULL : (hash_target_destroy_notify (hash_target), NULL);
	hash = NULL;
	hash_target = NULL;
	hash_target_destroy_notify = NULL;
	(cmp_target_destroy_notify == NULL) ? NULL : (cmp_target_destroy_notify (cmp_target), NULL);
	cmp = NULL;
	cmp_target = NULL;
	cmp_target_destroy_notify = NULL;
	(eq_target_destroy_notify == NULL) ? NULL : (eq_target_destroy_notify (eq_target), NULL);
	eq = NULL;
	eq_target = NULL;
	eq_target_destroy_notify = NULL;
	_g_object_unref0 (minus_one2);
	_g_object_unref0 (minus_one);
	_g_object_unref0 (two_copy);
	_g_object_unref0 (one);
	_g_object_unref0 (two);
}


static Block5Data* block5_data_ref (Block5Data* _data5_) {
	g_atomic_int_inc (&_data5_->_ref_count_);
	return _data5_;
}


static void block5_data_unref (void * _userdata_) {
	Block5Data* _data5_;
	_data5_ = (Block5Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data5_->_ref_count_)) {
		FunctionsTests * self;
		self = _data5_->self;
		_g_object_unref0 (self);
		g_slice_free (Block5Data, _data5_);
	}
}


static Block6Data* block6_data_ref (Block6Data* _data6_) {
	g_atomic_int_inc (&_data6_->_ref_count_);
	return _data6_;
}


static void block6_data_unref (void * _userdata_) {
	Block6Data* _data6_;
	_data6_ = (Block6Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data6_->_ref_count_)) {
		FunctionsTests * self;
		self = _data6_->_data5_->self;
		block5_data_unref (_data6_->_data5_);
		_data6_->_data5_ = NULL;
		g_slice_free (Block6Data, _data6_);
	}
}


static gint __lambda21_ (Block6Data* _data6_) {
	Block5Data* _data5_;
	FunctionsTests * self;
	gint result = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	_data5_ = _data6_->_data5_;
	self = _data5_->self;
	_tmp0_ = _data6_->k;
	_tmp1_ = _data5_->i;
	_vala_assert ((_tmp0_ + 1) == _tmp1_, "k + 1 == i");
	_tmp2_ = _data6_->k;
	_data5_->j = _tmp2_;
	_tmp3_ = _data6_->k;
	result = _tmp3_;
	return result;
}


static gpointer ___lambda21__gee_lazy_func (gpointer self) {
	gpointer result;
	result = __lambda21_ (self);
	return result;
}


static GeeLazy* __lambda20_ (Block5Data* _data5_) {
	FunctionsTests * self;
	GeeLazy* result = NULL;
	Block6Data* _data6_;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	GeeLazy* _tmp4_ = NULL;
	self = _data5_->self;
	_data6_ = g_slice_new0 (Block6Data);
	_data6_->_ref_count_ = 1;
	_data6_->_data5_ = block5_data_ref (_data5_);
	_tmp0_ = _data5_->j;
	_tmp1_ = _data5_->i;
	_vala_assert ((_tmp0_ + 1) == _tmp1_, "j + 1 == i");
	_tmp2_ = _data5_->i;
	if (_tmp2_ == 10) {
		result = NULL;
		block6_data_unref (_data6_);
		_data6_ = NULL;
		return result;
	}
	_tmp3_ = _data5_->i;
	_data5_->i = _tmp3_ + 1;
	_data6_->k = _tmp3_;
	_tmp4_ = gee_lazy_new (G_TYPE_INT, NULL, NULL, ___lambda21__gee_lazy_func, block6_data_ref (_data6_), block6_data_unref);
	result = _tmp4_;
	block6_data_unref (_data6_);
	_data6_ = NULL;
	return result;
}


static GeeLazy* ___lambda20__gee_unfold_func (gpointer self) {
	GeeLazy* result;
	result = __lambda20_ (self);
	return result;
}


void functions_tests_test_unfold (FunctionsTests* self) {
	Block5Data* _data5_;
	GeeIterator* iter = NULL;
	GeeIterator* _tmp0_ = NULL;
	gint k = 0;
	gint _tmp10_ = 0;
	g_return_if_fail (self != NULL);
	_data5_ = g_slice_new0 (Block5Data);
	_data5_->_ref_count_ = 1;
	_data5_->self = g_object_ref (self);
	_data5_->i = 0;
	_data5_->j = -1;
	_tmp0_ = gee_iterator_unfold (G_TYPE_INT, NULL, NULL, ___lambda20__gee_unfold_func, block5_data_ref (_data5_), block5_data_unref, NULL);
	iter = _tmp0_;
	k = 0;
	while (TRUE) {
		GeeIterator* _tmp1_ = NULL;
		gboolean _tmp2_ = FALSE;
		GeeIterator* _tmp3_ = NULL;
		gpointer _tmp4_ = NULL;
		gint _tmp5_ = 0;
		GeeIterator* _tmp6_ = NULL;
		gpointer _tmp7_ = NULL;
		gint _tmp8_ = 0;
		gint _tmp9_ = 0;
		_tmp1_ = iter;
		_tmp2_ = gee_iterator_next (_tmp1_);
		if (!_tmp2_) {
			break;
		}
		_tmp3_ = iter;
		_tmp4_ = gee_iterator_get (_tmp3_);
		_tmp5_ = k;
		_vala_assert (((gint) ((gintptr) _tmp4_)) == _tmp5_, "iter.get () == k");
		_tmp6_ = iter;
		_tmp7_ = gee_iterator_get (_tmp6_);
		_tmp8_ = k;
		_vala_assert (((gint) ((gintptr) _tmp7_)) == _tmp8_, "iter.get () == k");
		_tmp9_ = k;
		k = _tmp9_ + 1;
	}
	_tmp10_ = k;
	_vala_assert (_tmp10_ == 10, "k == 10");
	_g_object_unref0 (iter);
	block5_data_unref (_data5_);
	_data5_ = NULL;
}


static Block7Data* block7_data_ref (Block7Data* _data7_) {
	g_atomic_int_inc (&_data7_->_ref_count_);
	return _data7_;
}


static void block7_data_unref (void * _userdata_) {
	Block7Data* _data7_;
	_data7_ = (Block7Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data7_->_ref_count_)) {
		FunctionsTests * self;
		self = _data7_->self;
		_g_object_unref0 (self);
		g_slice_free (Block7Data, _data7_);
	}
}


static Block8Data* block8_data_ref (Block8Data* _data8_) {
	g_atomic_int_inc (&_data8_->_ref_count_);
	return _data8_;
}


static void block8_data_unref (void * _userdata_) {
	Block8Data* _data8_;
	_data8_ = (Block8Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data8_->_ref_count_)) {
		FunctionsTests * self;
		self = _data8_->_data7_->self;
		block7_data_unref (_data8_->_data7_);
		_data8_->_data7_ = NULL;
		g_slice_free (Block8Data, _data8_);
	}
}


static GeeLazy* __lambda23_ (Block8Data* _data8_) {
	Block7Data* _data7_;
	FunctionsTests * self;
	GeeLazy* result = NULL;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	GeeLazy* _tmp3_ = NULL;
	_data7_ = _data8_->_data7_;
	self = _data7_->self;
	_tmp0_ = _data8_->j;
	_tmp1_ = _data8_->start;
	if (_tmp0_ == (_tmp1_ + 3)) {
		result = NULL;
		return result;
	}
	_tmp2_ = _data8_->j;
	_data8_->j = _tmp2_ + 1;
	_tmp3_ = gee_lazy_new_from_value (G_TYPE_INT, NULL, NULL, (gpointer) ((gintptr) _tmp2_));
	result = _tmp3_;
	return result;
}


static GeeLazy* ___lambda23__gee_unfold_func (gpointer self) {
	GeeLazy* result;
	result = __lambda23_ (self);
	return result;
}


static GeeLazy* __lambda22_ (Block7Data* _data7_) {
	FunctionsTests * self;
	GeeLazy* result = NULL;
	Block8Data* _data8_;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	GeeIterator* iter = NULL;
	GeeIterator* _tmp3_ = NULL;
	GeeIterator* _tmp4_ = NULL;
	GeeLazy* _tmp5_ = NULL;
	self = _data7_->self;
	_data8_ = g_slice_new0 (Block8Data);
	_data8_->_ref_count_ = 1;
	_data8_->_data7_ = block7_data_ref (_data7_);
	_tmp0_ = _data7_->i;
	if (_tmp0_ >= 3) {
		result = NULL;
		block8_data_unref (_data8_);
		_data8_ = NULL;
		return result;
	}
	_tmp1_ = _data7_->i;
	_data7_->i = _tmp1_ + 1;
	_data8_->j = _tmp1_ * 3;
	_tmp2_ = _data8_->j;
	_data8_->start = _tmp2_;
	_tmp3_ = gee_iterator_unfold (G_TYPE_INT, NULL, NULL, ___lambda23__gee_unfold_func, block8_data_ref (_data8_), block8_data_unref, NULL);
	iter = _tmp3_;
	_tmp4_ = iter;
	_tmp5_ = gee_lazy_new_from_value (GEE_TYPE_ITERATOR, (GBoxedCopyFunc) g_object_ref, g_object_unref, _tmp4_);
	result = _tmp5_;
	_g_object_unref0 (iter);
	block8_data_unref (_data8_);
	_data8_ = NULL;
	return result;
}


static GeeLazy* ___lambda22__gee_unfold_func (gpointer self) {
	GeeLazy* result;
	result = __lambda22_ (self);
	return result;
}


void functions_tests_test_concat (FunctionsTests* self) {
	Block7Data* _data7_;
	GeeIterator* iter_ = NULL;
	GeeIterator* _tmp0_ = NULL;
	gint j = 0;
	GeeIterator* iter = NULL;
	GeeIterator* _tmp1_ = NULL;
	GeeIterator* _tmp2_ = NULL;
	gint _tmp12_ = 0;
	gint _tmp13_ = 0;
	g_return_if_fail (self != NULL);
	_data7_ = g_slice_new0 (Block7Data);
	_data7_->_ref_count_ = 1;
	_data7_->self = g_object_ref (self);
	_data7_->i = 0;
	_tmp0_ = gee_iterator_unfold (GEE_TYPE_ITERATOR, (GBoxedCopyFunc) g_object_ref, g_object_unref, ___lambda22__gee_unfold_func, block7_data_ref (_data7_), block7_data_unref, NULL);
	iter_ = _tmp0_;
	j = 0;
	_tmp1_ = iter_;
	_tmp2_ = gee_iterator_concat (G_TYPE_INT, NULL, NULL, _tmp1_);
	iter = _tmp2_;
	while (TRUE) {
		GeeIterator* _tmp3_ = NULL;
		gboolean _tmp4_ = FALSE;
		gint _tmp5_ = 0;
		GeeIterator* _tmp6_ = NULL;
		gpointer _tmp7_ = NULL;
		gint _tmp8_ = 0;
		GeeIterator* _tmp9_ = NULL;
		gpointer _tmp10_ = NULL;
		gint _tmp11_ = 0;
		_tmp3_ = iter;
		_tmp4_ = gee_iterator_next (_tmp3_);
		if (!_tmp4_) {
			break;
		}
		_tmp5_ = j;
		_tmp6_ = iter;
		_tmp7_ = gee_iterator_get (_tmp6_);
		_vala_assert (_tmp5_ == ((gint) ((gintptr) _tmp7_)), "j == iter.get ()");
		_tmp8_ = j;
		_tmp9_ = iter;
		_tmp10_ = gee_iterator_get (_tmp9_);
		_vala_assert (_tmp8_ == ((gint) ((gintptr) _tmp10_)), "j == iter.get ()");
		_tmp11_ = j;
		j = _tmp11_ + 1;
	}
	_tmp12_ = _data7_->i;
	_vala_assert (_tmp12_ == 3, "i == 3");
	_tmp13_ = j;
	_vala_assert (_tmp13_ == 9, "j == 9");
	_g_object_unref0 (iter);
	_g_object_unref0 (iter_);
	block7_data_unref (_data7_);
	_data7_ = NULL;
}


static FunctionsTestsMyComparable* functions_tests_my_comparable_construct (GType object_type, gint i) {
	FunctionsTestsMyComparable * self = NULL;
	gint _tmp0_ = 0;
	self = (FunctionsTestsMyComparable*) g_object_new (object_type, NULL);
	_tmp0_ = i;
	self->priv->i = _tmp0_;
	return self;
}


static FunctionsTestsMyComparable* functions_tests_my_comparable_new (gint i) {
	return functions_tests_my_comparable_construct (FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, i);
}


static gint functions_tests_my_comparable_real_compare_to (GeeComparable* base, FunctionsTestsMyComparable* cmp) {
	FunctionsTestsMyComparable * self;
	gint result = 0;
	gint _tmp0_ = 0;
	FunctionsTestsMyComparable* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	self = (FunctionsTestsMyComparable*) base;
	g_return_val_if_fail (cmp != NULL, 0);
	_tmp0_ = self->priv->i;
	_tmp1_ = cmp;
	_tmp2_ = _tmp1_->priv->i;
	if (_tmp0_ == _tmp2_) {
		result = 0;
		return result;
	} else {
		gint _tmp3_ = 0;
		FunctionsTestsMyComparable* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		_tmp3_ = self->priv->i;
		_tmp4_ = cmp;
		_tmp5_ = _tmp4_->priv->i;
		if (_tmp3_ >= _tmp5_) {
			result = 1;
			return result;
		} else {
			result = -1;
			return result;
		}
	}
}


static void functions_tests_my_comparable_class_init (FunctionsTestsMyComparableClass * klass) {
	functions_tests_my_comparable_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FunctionsTestsMyComparablePrivate));
	G_OBJECT_CLASS (klass)->finalize = functions_tests_my_comparable_finalize;
}


static void functions_tests_my_comparable_gee_comparable_interface_init (GeeComparableIface * iface) {
	functions_tests_my_comparable_gee_comparable_parent_iface = g_type_interface_peek_parent (iface);
	iface->compare_to = (gint (*)(GeeComparable*, gconstpointer)) functions_tests_my_comparable_real_compare_to;
}


static void functions_tests_my_comparable_instance_init (FunctionsTestsMyComparable * self) {
	self->priv = FUNCTIONS_TESTS_MY_COMPARABLE_GET_PRIVATE (self);
}


static void functions_tests_my_comparable_finalize (GObject* obj) {
	FunctionsTestsMyComparable * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FUNCTIONS_TESTS_TYPE_MY_COMPARABLE, FunctionsTestsMyComparable);
	G_OBJECT_CLASS (functions_tests_my_comparable_parent_class)->finalize (obj);
}


static GType functions_tests_my_comparable_get_type (void) {
	static volatile gsize functions_tests_my_comparable_type_id__volatile = 0;
	if (g_once_init_enter (&functions_tests_my_comparable_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FunctionsTestsMyComparableClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) functions_tests_my_comparable_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionsTestsMyComparable), 0, (GInstanceInitFunc) functions_tests_my_comparable_instance_init, NULL };
		static const GInterfaceInfo gee_comparable_info = { (GInterfaceInitFunc) functions_tests_my_comparable_gee_comparable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType functions_tests_my_comparable_type_id;
		functions_tests_my_comparable_type_id = g_type_register_static (G_TYPE_OBJECT, "FunctionsTestsMyComparable", &g_define_type_info, 0);
		g_type_add_interface_static (functions_tests_my_comparable_type_id, GEE_TYPE_COMPARABLE, &gee_comparable_info);
		g_once_init_leave (&functions_tests_my_comparable_type_id__volatile, functions_tests_my_comparable_type_id);
	}
	return functions_tests_my_comparable_type_id__volatile;
}


static FunctionsTestsMyHashable* functions_tests_my_hashable_construct (GType object_type, gint i) {
	FunctionsTestsMyHashable * self = NULL;
	gint _tmp0_ = 0;
	self = (FunctionsTestsMyHashable*) g_object_new (object_type, NULL);
	_tmp0_ = i;
	self->priv->i = _tmp0_;
	return self;
}


static FunctionsTestsMyHashable* functions_tests_my_hashable_new (gint i) {
	return functions_tests_my_hashable_construct (FUNCTIONS_TESTS_TYPE_MY_HASHABLE, i);
}


static gint functions_tests_my_hashable_real_compare_to (GeeComparable* base, FunctionsTestsMyHashable* cmp) {
	FunctionsTestsMyHashable * self;
	gint result = 0;
	gint _tmp0_ = 0;
	FunctionsTestsMyHashable* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	self = (FunctionsTestsMyHashable*) base;
	g_return_val_if_fail (cmp != NULL, 0);
	_tmp0_ = self->priv->i;
	_tmp1_ = cmp;
	_tmp2_ = _tmp1_->priv->i;
	if (_tmp0_ == _tmp2_) {
		result = 0;
		return result;
	} else {
		gint _tmp3_ = 0;
		FunctionsTestsMyHashable* _tmp4_ = NULL;
		gint _tmp5_ = 0;
		_tmp3_ = self->priv->i;
		_tmp4_ = cmp;
		_tmp5_ = _tmp4_->priv->i;
		if (_tmp3_ >= _tmp5_) {
			result = 1;
			return result;
		} else {
			result = -1;
			return result;
		}
	}
}


static guint functions_tests_my_hashable_real_hash (GeeHashable* base) {
	FunctionsTestsMyHashable * self;
	guint result = 0U;
	gint _tmp0_ = 0;
	self = (FunctionsTestsMyHashable*) base;
	_tmp0_ = self->priv->i;
	result = (guint) _tmp0_;
	return result;
}


static gboolean functions_tests_my_hashable_real_equal_to (GeeHashable* base, FunctionsTestsMyHashable* hash) {
	FunctionsTestsMyHashable * self;
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gint _tmp1_ = 0;
	FunctionsTestsMyHashable* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gboolean _tmp5_ = FALSE;
	self = (FunctionsTestsMyHashable*) base;
	g_return_val_if_fail (hash != NULL, FALSE);
	_tmp1_ = self->priv->i;
	_tmp2_ = hash;
	_tmp3_ = _tmp2_->priv->i;
	if (_tmp1_ == _tmp3_) {
		gint _tmp4_ = 0;
		_tmp4_ = self->priv->i;
		_tmp0_ = _tmp4_ != (-1);
	} else {
		_tmp0_ = FALSE;
	}
	_tmp5_ = _tmp0_;
	result = _tmp5_;
	return result;
}


static void functions_tests_my_hashable_class_init (FunctionsTestsMyHashableClass * klass) {
	functions_tests_my_hashable_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (FunctionsTestsMyHashablePrivate));
	G_OBJECT_CLASS (klass)->finalize = functions_tests_my_hashable_finalize;
}


static void functions_tests_my_hashable_gee_comparable_interface_init (GeeComparableIface * iface) {
	functions_tests_my_hashable_gee_comparable_parent_iface = g_type_interface_peek_parent (iface);
	iface->compare_to = (gint (*)(GeeComparable*, gconstpointer)) functions_tests_my_hashable_real_compare_to;
}


static void functions_tests_my_hashable_gee_hashable_interface_init (GeeHashableIface * iface) {
	functions_tests_my_hashable_gee_hashable_parent_iface = g_type_interface_peek_parent (iface);
	iface->hash = (guint (*)(GeeHashable*)) functions_tests_my_hashable_real_hash;
	iface->equal_to = (gboolean (*)(GeeHashable*, gconstpointer)) functions_tests_my_hashable_real_equal_to;
}


static void functions_tests_my_hashable_instance_init (FunctionsTestsMyHashable * self) {
	self->priv = FUNCTIONS_TESTS_MY_HASHABLE_GET_PRIVATE (self);
}


static void functions_tests_my_hashable_finalize (GObject* obj) {
	FunctionsTestsMyHashable * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FUNCTIONS_TESTS_TYPE_MY_HASHABLE, FunctionsTestsMyHashable);
	G_OBJECT_CLASS (functions_tests_my_hashable_parent_class)->finalize (obj);
}


static GType functions_tests_my_hashable_get_type (void) {
	static volatile gsize functions_tests_my_hashable_type_id__volatile = 0;
	if (g_once_init_enter (&functions_tests_my_hashable_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FunctionsTestsMyHashableClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) functions_tests_my_hashable_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionsTestsMyHashable), 0, (GInstanceInitFunc) functions_tests_my_hashable_instance_init, NULL };
		static const GInterfaceInfo gee_comparable_info = { (GInterfaceInitFunc) functions_tests_my_hashable_gee_comparable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		static const GInterfaceInfo gee_hashable_info = { (GInterfaceInitFunc) functions_tests_my_hashable_gee_hashable_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType functions_tests_my_hashable_type_id;
		functions_tests_my_hashable_type_id = g_type_register_static (G_TYPE_OBJECT, "FunctionsTestsMyHashable", &g_define_type_info, 0);
		g_type_add_interface_static (functions_tests_my_hashable_type_id, GEE_TYPE_COMPARABLE, &gee_comparable_info);
		g_type_add_interface_static (functions_tests_my_hashable_type_id, GEE_TYPE_HASHABLE, &gee_hashable_info);
		g_once_init_leave (&functions_tests_my_hashable_type_id__volatile, functions_tests_my_hashable_type_id);
	}
	return functions_tests_my_hashable_type_id__volatile;
}


static void functions_tests_class_init (FunctionsTestsClass * klass) {
	functions_tests_parent_class = g_type_class_peek_parent (klass);
}


static void functions_tests_instance_init (FunctionsTests * self) {
}


GType functions_tests_get_type (void) {
	static volatile gsize functions_tests_type_id__volatile = 0;
	if (g_once_init_enter (&functions_tests_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (FunctionsTestsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) functions_tests_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FunctionsTests), 0, (GInstanceInitFunc) functions_tests_instance_init, NULL };
		GType functions_tests_type_id;
		functions_tests_type_id = g_type_register_static (GEE_TYPE_TEST_CASE, "FunctionsTests", &g_define_type_info, 0);
		g_once_init_leave (&functions_tests_type_id__volatile, functions_tests_type_id);
	}
	return functions_tests_type_id__volatile;
}



